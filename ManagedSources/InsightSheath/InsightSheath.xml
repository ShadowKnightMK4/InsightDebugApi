<?xml version="1.0"?>
<doc>
    <assembly>
        <name>InsightSheath</name>
    </assembly>
    <members>
        <member name="T:InsightSheath.Abstract.NativeStaticContainer">
            <summary>
            Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/C++'s free(). If said Native class needs special free requirements, overwrite <see cref="M:InsightSheath.Abstract.NativeStaticContainer.Dispose(System.Boolean)"/> with a a call to a routine to properly dispose of  it. If your wrapper is handing out multiple natiove pointers to the same object, you'll need something like <see cref="T:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.NativeStaticContainer.UnmanagedConstructorReturnedNull">
            <summary>
            This is using in <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/> based classes when their static builder (For example <see cref="M:InsightSheath.Debugging.Process.InsightProcess.CreateInstance"/>) receive null from the unmanaged constructor routine
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.NativeStaticContainer.ReceivedNullPointerOnConstructor">
            <summary>
            This is used in <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/> based classes a template to an exception message to indicate it received null when being built
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.WrapperConstructorReceivedNullPointerErrorException(System.String,System.String,System.String)">
            <summary>
            Used to make the <see cref="T:System.ArgumentNullException"/> message using <see cref="F:InsightSheath.Abstract.NativeStaticContainer.ReceivedNullPointerOnConstructor"/> template
            </summary>
            <param name="ArgumentPrefix"></param>
            <param name="AlternativeInstance"></param>
            <param name="ArgumentName"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.Equals(System.Object)">
            <summary>
            NativeStaticContrain compares both <see cref="F:InsightSheath.Abstract.NativeStaticContainer.Native"/> pointers and returns true if equal
            </summary>
            <param name="obj">the other one</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.GetHashCode">
            <summary>
            Grab a hash of the native pointer. Logic being if two hashes are the same, we're holding the same native struct/class
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.#ctor(System.IntPtr)">
            <summary>
            Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions.
            </summary>
            <param name="Native">The Native pointer to keep track of.</param>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.#ctor(System.IntPtr,System.Boolean)">
             <summary>
             Create an instance of the class with the object to specify if we free it.
             </summary>
             <param name="Native">Native pointer to the structure this class will reference</param>
             <param name="FreeOnCleanup">if true then the structure is freed via RemoteRead_SimpleFree() which itself is a call to C/C++'s free() . Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated</param>
             <remarks> FreeOnCleanup is a bit dependent on your knowledge of the native code. If the native pointer points to something dynamically allocated with malloc() / HeapAlloc(),  specify true.  If it's declared in the Native source directly or on the stack as a function variable, use false.</remarks>
            
        </member>
        <member name="P:InsightSheath.Abstract.NativeStaticContainer.NativePointer">
            <summary>
            WARNING! WARNING! WARNING! Return the underlying pointer.  Should this block of memory be freed (releases/ deleted), the instance of this <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/> will break.
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.ClearNative">
            <summary>
            place in disposable and call it after calling the current unmanaged cleanup routine.  
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.NativeStaticContainer.Native">
            <summary>
            Holds a physical unmanaged pointer to a relevant structure. Child classes use this 
            </summary>
        </member>
        <member name="P:InsightSheath.Abstract.NativeStaticContainer.FreeOnCleanup">
            <summary>
            Conditional free on dispose. Set this to true if you're manipulated a block of unmanaged memory dynamically located by the API. Set to false if you're working with a previously allocated structure or the struct was given as part of a callback to you or part of a larger structure
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.NativeStaticContainer.FreeOnCleanupContainer">
            <summary>
            Holds the free on cleanup value.  Recommend only disposal() routines modify this.
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.NativeStaticContainer.disposedValue">
            <summary>
            value containing if dispose() was called
            </summary>
        </member>
        <member name="P:InsightSheath.Abstract.NativeStaticContainer.IsDisposed">
            <summary>
            Was this class disposed?
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.Dispose(System.Boolean)">
             <summary>
             Basic <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/> disposal.  Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. 
             </summary>
             <param name="disposing">set to true if disposing of managed resources in addition to unmanaged.</param>
             <remarks>IMPORTANT! If your child class needs special needs beyond C/C++'s free(),  override this and take care of them before calling base(). 
             Should your custom class allocate multiple things for example <see cref="T:InsightSheath.Win32Struct.WindowsUnicodeString"/>'s implementation for reading from remote processes <see cref="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(System.IntPtr,System.IntPtr,System.Boolean,System.Boolean)"/>, you will need to make a routine to properly free.  That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory.
             Design checks:
            <list type="number">
            <listheader>
            <description > First, override disposal() </description >
            </listheader >
            <item>
             <description> Nest, add a private variable in your class called isDisposed. Set this to true  when your class's native pointer is cleaned up completely </description >
            </item >
            <item>
            <description>if <see cref="T:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer"/> is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it.</description>
            </item>
            <item>
            <description>if <see cref="T:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer"/> IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null.   If the  reference counter is more than 0 when decreased, set native to null instead of disposing.</description>
            </item>
             </list>
             </remarks>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.Finalize">
            <summary>
            clean up only the unmanaged parts of <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.NativeStaticContainer.Dispose">
            <summary>
            Trigger cleanup of this <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/> based class
            </summary>
        </member>
        <member name="T:InsightSheath.Abstract.OnDemandMarshalNativeStruct">
            <summary>
            Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct.
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.OnDemandMarshalNativeStruct.Blit">
            <summary>
            This code should marshal the relevant struct from the native pointer if <see cref="F:InsightSheath.Abstract.OnDemandMarshalNativeStruct.WasBlit"/> is not set and set afterwards. Accessors should call this each time they are called to retrieve values.
            Additionally, if the .NET struct will need to make changes to the land, you're going to need to call <see cref="M:InsightSheath.Abstract.OnDemandMarshalNativeStruct.Apply"/> BEFORE reading the managed struct. Not doing this will revert your changes on the managed side
            to the equivalent native values.
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.OnDemandMarshalNativeStruct.Apply">
            <summary>
            This code should convert the relevant struct in .NET land and place it in the <see cref="!:Native"/> if the protected value <see cref="F:InsightSheath.Abstract.OnDemandMarshalNativeStruct.StaleManagedStruct"/> was set to true Unmanaged land. It should throw 
            a <see cref="T:System.InvalidOperationException"/> if it's not a valid thing (native pointer is known to be read only memory/ exist for a callback function for example) 
            <see cref="T:System.NotImplementedException"/> exception if not done yet ecct...
            </summary>
            <exception cref="T:System.InvalidOperationException">Throw this when writing back to the unmanaged struct is not valid (for example read only memory or a local variable in a callback routine allocated on Unamanged heap)</exception>
            <exception cref="T:System.NotSupportedException">Throw this when writing back to the unmanaged struct is not valid (for example read only memory or a local variable in a callback routine allocated on Unamanged heap)</exception>
            <exception cref="T:System.NotImplementedException">The routine was added but not implemented yet.</exception>
        </member>
        <member name="M:InsightSheath.Abstract.OnDemandMarshalNativeStruct.MarshalToNative">
            <summary>
            public access to protects routine to send changes to the managed struct copy back to native land. If the class does not implement or that's not a valid option for the class, an exception may occure
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="F:InsightSheath.Abstract.OnDemandMarshalNativeStruct.WasBlit">
            <summary>
            <see cref="M:InsightSheath.Abstract.OnDemandMarshalNativeStruct.Blit"/> should set this to true after last reading successful marshaling was done in <see cref="M:InsightSheath.Abstract.OnDemandMarshalNativeStruct.Blit"/>from the native side.
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.OnDemandMarshalNativeStruct.StaleManagedStruct">
            <summary>
            When an accessory sets property in the managed struct that needs to be updated in native land, set this.
            </summary>
        </member>
        <member name="T:InsightSheath.Abstract.PlatformDependantNativeStruct">
            <summary>
            This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target.
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.PlatformDependantNativeStruct.#ctor(System.IntPtr,System.Boolean)">
            <summary>
             Create an instance of the class with the object to specify if we free it.
            </summary>
            <param name="Native">Native pointer to the structure this class will reference</param>
            <param name="FreeOnCleanup">if true then the structure is freed via RemoteRead_SimpleFree() which itself is a call to C/C++'s free() . Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated</param>
            <remarks> FreeOnCleanup is a bit dependent on your knowledge of the native code. If the native pointer points to something dynamically allocated with malloc() / HeapAlloc(),  specify true.  If it's declared in the Native source directly or on the stack as a function variable, use false</remarks>
        </member>
        <member name="M:InsightSheath.Abstract.PlatformDependantNativeStruct.#ctor(System.IntPtr,InsightSheath.Win32Struct.StructModeType)">
            <summary>
            Make an instance of this class with the <see cref="P:InsightSheath.Abstract.PlatformDependantNativeStruct.StructType"/> specified.
            </summary>
            <param name="Native">Pointer to an unmanaged memory block this class is dealing with.</param>
            <param name="StructType">Structures with points are different sizes depending on if they're lifting from x86 or x64 code. Indicate if this is a <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/> (for 4 byte pointers) or a <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/> for 8 byte pointers</param>
        </member>
        <member name="M:InsightSheath.Abstract.PlatformDependantNativeStruct.Dispose(System.Boolean)">
            <summary>
            Platform Dependant native structure does not allocate anything and does nothing other than hold the specifics for the child class. Specifically struct
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:InsightSheath.Abstract.PlatformDependantNativeStruct.StructType">
            <summary>
            Get or set the type of structure that's correct for this class to use. Also resets a flag to trigger Marshalling from that native side when set.
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer">
            <summary>
            protected container for <see cref="P:InsightSheath.Abstract.PlatformDependantNativeStruct.StructType"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Abstract.PlatformDependantNativeStruct.MachineTypeUnspecifiedError">
            <summary>
            canned error message for when user does not specify a machine.
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.PlatformDependantNativeStruct.ThrowNewInvalidOpMessage(System.String)">
            <summary>
            This throws a message wither everything except class name prefilled by calling <see cref="M:InsightSheath.Abstract.PlatformDependantNativeStruct.MachineTypeUnspecifiedErrorMakeMessage(System.String,System.String,System.String)"/>
            </summary>
            <param name="classname"></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer">
            <summary>
            This class contains an AddRef()/ Release() component for child classes.
            Destructors(), Call Release() and if that returns 0, free as appropriate.
            Not needed if the class itself is a 1 to 1 ie
            Sheath class pointer that contains one pointer, this can skip.
            Sheath, DebugEvent classes have this in the change, because they
            give out multiple references to a native class like candy.  Each multiple class
            in the sheath points to a single native class.  when the sheath class
            is freed() we need to ensure we don't prematurly free the unamanged component of the class, 
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.#ctor(System.IntPtr)">
            <summary>
            Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to 1.
            </summary>
            <param name="Native">The Native pointer to keep track of.</param>
        </member>
        <member name="M:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to RefereneCount.
            </summary>
            <param name="Native">The Native pointer to keep track of.</param>
            <param name="FreeOnCleanup">indicate  if we are to invoke the unmanaged cleanup routine for free()</param>
            <param name="ReferenceCount">Starting reference count number. The unmanaged  resource should not be freed during disposal if this is more than 0 after decreasing by 1</param>
        </member>
        <member name="M:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to 11.
            </summary>
            <param name="Native">The Native pointer to keep track of.</param>
            <param name="FreeOnCleanup">indicate  if we are to invoke the unmanaged cleanup routine for free()</param>
        </member>
        <member name="P:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.ReferenceCounter">
            <summary>
            Get reference count without adjusting it. Increase the reference counter when returning a pointer to a class
            </summary>
        </member>
        <member name="M:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.AddRef">
            <summary>
            Increase the Reference count to the native pointer and return the value. Call this when returning a seperate sheath class that may outlive the primary sheath class
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.Release">
            <summary>
            Decrease the Reference count to the native pointer and return the value. If zero is returned, your unmanaged native pointer should be ok to safely cleanup/free
            </summary>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Debugging.DebugExceptionInPage_Type">
            
             This file provides a wrapper between c# and the InsightApi.Dll that deals with the debug event structure.
             The base class <see cref="T:InsightSheath.Debugging.DebugEventStaticContainer"/> is the root for the other classes in this file. It
             handles holding an <see cref="T:System.IntPtr"/> that represents the unmanaged DEBUG_EVENT structure.  This pointer gets
             passes to various routines in the InsightApi.Dll DLL which then return data bases on that pointer - usually about 
             the DEBUG_EVENT struct.  Each DEBUG_EVENT in the MSDN documentation has its own C# class <see cref="T:InsightSheath.Debugging.DebugEventType"/>
             About Exceptions
                 The MSDN documentation has certain exceptions listed. Those have been added to the <see cref="T:InsightSheath.Debugging.DebugExceptionTypes"/> enum.
                 That's not actually exhaustive.  winbase.h lists MANY MANY MANY more.
            <summary>
             Type of In Page exception flags.  You can check if the exception is that at <see cref="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode"/>
             </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionInPage_Type.ReadException">
            <summary>
            Target process thread with the <see cref="F:InsightSheath.Debugging.DebugExceptionTypes.InPageError"/> tried reading something it's not allowed too
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionInPage_Type.WriteException">
            <summary>
            Target process thread with the <see cref="F:InsightSheath.Debugging.DebugExceptionTypes.InPageError"/> tried writing to something it's not allowed too
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionInPage_Type.DepException">
            <summary>
            Target process thread had a user mode DEP violation.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugExceptionTypes">
            <summary>
             Enum for the exceptions specifies within the MSDN documentation.  NOT EXHAUSTIVE. Sourced from minwinbase.h in Visual studio
             </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.AccessViolation">
            <summary>
            Target tried reading/ writing to virtual memory it is not allowed too.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.ArrayBoundsExceeded">
            <summary>
            Target tried accessing an array element that's out of bounds (hardware supported bounds checking? according to MSDN documentation)
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Breakpoint">
            <summary>
            Hit a breakpoint in the target. Important! Windows will generate a breakpoint once its finished loading the process before sending your first debugger message to you.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Datatyp_Misalighment">
            <summary>
            tread in the target attempting to read misaligned data 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.FloatPoint_Denormal_Operand">
            <summary>
            MSDN:  float point operation resulted in a value to small to be represented.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Float_DivideByZero">
            <summary>
            Float division by zero
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Float_InexactResult">
            <summary>
            MSDN Can't represent a float as a decimal fraction precisely
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Float_Overflow">
            <summary>
            float's exponent is too big
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Float_StackCheck">
            <summary>
            Float point value over or underflowed after an operation
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Float_Underflow">
            <summary>
            Float point is less that the magnitude allowed
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.IllegalInstrution">
            <summary>
            Invalid instruction attempted
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.InPageError">
            <summary>
            MSDN: Thread tried to access  a page that's not present and system couldn't load page
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Int_DivideByZero">
            <summary>
            Int divide by zero
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.Int_Overflow">
            <summary>
            Inter overflowed the most significant bit
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.InvalidDisposition">
            <summary>
            Exception handled returned invalid disposition
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.NonContinuableException">
            <summary>
            Exception triggered when attempting to continue an exception that says that's not possible
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.PrivInstruction">
            <summary>
            Attempt to execute instructions that aren't allowed in the current machine mode
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.StackOverflow">
            <summary>
            target used up its stack
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.DebugConsoleControlC">
            <summary>
            Console Window/Application: CTRL-C pressed the debugged application
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugExceptionTypes.InvalidHandleCloseException">
            <summary>
            Is generated by Kernel32's CloseHandle() when an invalid handle is attempting to be closed in the process being debuggefd.  
            IMPORTANT.  How you handle this depends if you're debugging / learning about a target. If it's debug resistant (for example malware), your debugger is NOT going  to want to mark that exception as being handled as then it likely will have just revealed itself.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventType">
            <summary>
            Helpful enum for the various debug event types. Also specifies which C# class will assist in reading the event's data.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.ExceptionEvent">
            <summary>
            Event is an exception. <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.CreateTheadEvent">
            <summary>
            Event is a create thread.  <see cref="T:InsightSheath.Debugging.DebugEventCreateThreadInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent">
            <summary>
            Event is a create process event. <see cref="T:InsightSheath.Debugging.DebugEventCreateProcessInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.ExitThreadEvent">
            <summary>
            Event is an exit thread event. <see cref="T:InsightSheath.Debugging.DebugEventExitThreadInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.ExitProcessEvent">
            <summary>
            Event is a exit process event.  <see cref="T:InsightSheath.Debugging.DebugEventExitProcessInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent">
            <summary>
            Event is a load DLL event. <see cref="T:InsightSheath.Debugging.DebugEventLoadDllInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.UnloadDllEvent">
            <summary>
            Event is unload DLL event.  <see cref="T:InsightSheath.Debugging.DebugEventUnloadDllInfo"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.OutputDebugString">
            <summary>
            Event is output debug string (can use <see cref="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadDebugString(System.IntPtr,System.IntPtr)"/> OR <see cref="T:InsightSheath.Debugging.DebugEventStringInfo"/> which does this for you
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventType.RipEvent">
            <summary>
            Event is System RIP Debug Event  <see cref="T:InsightSheath.Debugging.DebugEventRipInfo"/>
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.RipErrorType">
            <summary>
            Type of error that is contained <see cref="P:InsightSheath.Debugging.DebugEventRipInfo.ErrorType"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.RipErrorType.SleNoType">
            <summary>
            Only Error value was set
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.RipErrorType.SleError">
            <summary>
            Invalid data passed to function what caused debugged application to fail
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.RipErrorType.SleMinorError">
            <summary>
            Invalid data passed to a function maybe won't cause the application to fail
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.RipErrorType.SleWarning">
            <summary>
            Potentially Invalid data passed to a function but function finished any.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventStaticContainer">
            <summary>
            Implements the basis of disposal the other DebugEvent classes use.  Also exposes routines to read the ProcessID and ThreadID that triggered the event
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStaticContainer.#ctor(System.IntPtr)">
            <summary>
            Constructor for the base <see cref="T:InsightSheath.Debugging.DebugEvent"/> abstract class
            </summary>
            <param name="Native">Native pointer to the structure</param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStaticContainer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Constructor for the base <see cref="T:InsightSheath.Debugging.DebugEvent"/> abstract class
            </summary>
            <param name="Native">Native pointer to the structure</param>
            <param name="FreeOnCleanup">if true then the structure is freed via RemoteRead_SimpleFree(). Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated</param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStaticContainer.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Constructor for the base <see cref="T:InsightSheath.Debugging.DebugEvent"/> class
            </summary>
            <param name="Native">Native pointer to the structure</param>
            <param name="FreeOnCleanup">if true then the structure is freed via RemoteRead_SimpleFree(). Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated</param>
            <param name="ReferenceCounter">Specify the starting reference count.</param>
        </member>
        <member name="F:InsightSheath.Debugging.DebugEventStaticContainer.disposedValue">
            <summary>
             my personal disposed value
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStaticContainer.Dispose(System.Boolean)">
            <summary>
            Generic <see cref="T:InsightSheath.Debugging.DebugEventStaticContainer"/> dispose action. 
            </summary>
            <param name="disposing">Dispose of managed also?</param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStaticContainer.Finalize">
            <summary>
            Finalizer for the base <see cref="T:InsightSheath.Debugging.DebugEvent"/> class
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventStaticContainer.ProcessID">
            <summary>
            Get the process id that this event happed too
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventStaticContainer.ThreadID">
            <summary>
            Get the thread of the code that this event happened too
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventStaticContainer.EventType">
            <summary>
            Get which type of structure this debug event contains. <see cref="T:InsightSheath.Debugging.DebugEventType"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventStaticContainer.IsEventFrom32BitProcess">
            <summary>
            Makes a couple of calls to GetNativeSystemInfo() and asks IsWow64Process() if the this processID is running under WOW or not.
            This is NOT part of DebugEvent structure itself BUT is useful in letter the debugger know is the debugged application is 32-bit vs 64-bit
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventLoadDllInfo">
            <summary>
            Provides access to a <see cref="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent"/> in a <see cref="T:InsightSheath.Debugging.DebugEvent"/> struct
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventLoadDllInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventLoadDll"/></param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventLoadDllInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventLoadDll"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventLoadDllInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventLoadDll"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unmanaged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventLoadDllInfo.FileHandle">
            <summary>
            Get the Raw handle to the file. You should probably close this if the handle is valid once you no longer need it. If it's valid, MSDN  says you'll have read and write access
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventLoadDllInfo.DllBaseAddress">
            <summary>
            Get the base address of where the DLL was loaded in the debugged process.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventLoadDllInfo.DebugInfoSize">
            <summary>
            Get the size (in bytes?) of the DLL's debug info
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventLoadDllInfo.DebugInfoOffset">
            <summary>
            offer to where debug info is located
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventLoadDllInfo.IsImageNameStringUnicode">
            <summary>
            Is the string in the address space specified here valid?
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventLoadDllInfo.GetDebugInfo">
            <summary>
            return the debug info specified in the DLL as a series of bytes. MSDN documentation says this should be code view 4.0 format - whatever that is
            note: exists in the c# side only
            </summary>
            <returns></returns>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventLoadDllInfo.ImageName">
            <summary>
            This ignores the <see cref="P:InsightSheath.Debugging.DebugEventLoadDllInfo.ImageName"/>  underlying native struct member entirely as seen on MSDN LOAD_DLL_DEBUG_EVENT.  We simple fetch name - assuming the native hfile member is valid. Should the system not include the file handle, null is returned instead
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventExceptionInfo">
            <summary>
            Class Wrapper dealing with extracting Exception information from a <see cref="T:InsightSheath.Debugging.DebugEvent"/>.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExceptionInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExceptionEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventExceptionInfo"/></param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExceptionInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExceptionEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventExceptionInfo"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExceptionInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExceptionEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventExceptionInfo"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unamanged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionParameterCount">
            <summary>
            Return the length of the parameter array for the exception. Range is 0 to 15 or (in C/C++ land EXCEPTION_MAXIMUM_PARAMETERS #define)
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionParameter64">
            <summary>
             Retrieve the contents of the exception parameter list for a 64-bit debugged process. 
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionAddress64">
            <summary>
            return the address where the exception happened in the 64 bit process.  Reading from the upper part for an x86 process should be all 0s.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionAddress32">
            <summary>
            return address where the exception happens in the 32-bit process. Truncates the address if the process is 64-bit.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionFlags">
            <summary>
            Return the flags specific for this exception
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode_as_int">
            <summary>
            Return the Exception value for the exception that trigged as an uint.  Sourced from the same part of the unmanaged struct as <see cref="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode">
            <summary>
            Return the exception value for the exception that this contains as a convienent enumeration. Sourced from the same part of the unamanged struct as <see cref="P:InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode_as_int"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExceptionInfo.IsFirstChanceException">
            <summary>
            return if the debugger (that's you) has seen this first chance exception before.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventCreateThreadInfo">
            <summary>
            Holds a reference to a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing an event of the type of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateTheadEvent"/>. You'll typicalled get this when calling <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateThreadInfo"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateThreadInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateTheadEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateThreadInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateTheadEvent"/>
            </summary>
            <param name="Nat">pointer to an unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <param name="FreeOnCleanup">Set if you want the unamanged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateThreadInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateTheadEvent"/>
            </summary>
            <param name="Nat">pointer to an unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unamanged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadHandle">
            <summary>
            if NOT Null (IntPtr.zero),  handle should have THREAD_GET_CONTEXT/ THREAD_SET_CONTEXT and THREAD_SUSPEND_RESUME access to the thread per MSDN documentation.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadStartAddress">
            <summary>
            Get the approx start address
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadLocalBase">
            <summary>
            get the thread location storage pointer here.   MSDN says offset 0x2C is the ThreadLocationStorage pointer which presumably would let you track what per thread stuff your target is doing.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadLocalStoragePointer">
            <summary>
            ThreadLocalBase + 0x2C
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventExitThreadInfo">
            <summary>
            Holds a reference to a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing an event of the type of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitThreadEvent"/>. You'll typicalled get this when calling <see cref="M:InsightSheath.Debugging.DebugEvent.GetEventExitThreadInfo"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExitThreadInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitThreadEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExitThreadInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitThreadEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExitThreadInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitThreadEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unamanged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExitThreadInfo.ExitCode">
            <summary>
            Get the code that the thread returned when finishing
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventExitProcessInfo">
            <summary>
            Holds a reference to a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing an event of the type of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitProcessEvent"/>. You'll typicalled get this when calling <see cref="M:InsightSheath.Debugging.DebugEvent.GetEventExitProcessInfo"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExitProcessInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitProcessEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExitProcessInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitProcessEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventExitProcessInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitProcessEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="T:InsightSheath.Debugging.DebugEvent"/></param>
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unmanaged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventExitProcessInfo.ExitCode">
            <summary>
            Get the code that the Process returned when finishing
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventCreateProcessInfo">
            <summary>
            Holds a reference to a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing an event of the type of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/>. You'll typicalled get this when calling <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateProcessInfo"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateProcessInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateProcessInfo"/></param> 
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateProcessInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateProcessInfo"/></param> 
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>      
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateProcessInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateProcessInfo"/></param> 
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unmanaged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventCreateProcessInfo.NativeFileHandle">
            <summary>
            Get the HANDLE out of the structure. Warning handle may be null
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventCreateProcessInfo.ImageName">
            <summary>
            Get a string for the image name of the create process event this contains. Depends on the NativeFileHandle being valid and will return null otherwise
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventCreateProcessInfo.GetFileContents">
            <summary>
            Returns the contents of the exefile that the debug create process game from. Will Be null if the CreateProcess Event did not include a valid hFile handle. 
            </summary>
            <exception cref="T:System.IO.IOException"> IO Related exceptions can be thrown if a problem occurs in reading the main module's file contents. <see cref="M:System.IO.File.ReadAllBytes(System.String)"/> to see the list</exception>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventStringInfo">
            <summary>
            Providers a wrapper to process specific <see cref="F:InsightSheath.Debugging.DebugEventType.OutputDebugString"/> components.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStringInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.OutputDebugString"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventStringInfo"/></param> 
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStringInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.OutputDebugString"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventStringInfo"/></param> 
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStringInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.OutputDebugString"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventStringInfo"/></param> 
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unmanaged pointer is freed. </param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventStringInfo.ToString">
            <summary>
            For the user's convienence, returns <see cref="P:InsightSheath.Debugging.DebugEventStringInfo.OutputString"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventStringInfo.OutputString">
            <summary>
            Return the string messaged contained within the debug event. ANSI output strings are converted to Unicode on the Native side before being sent to the Managed side.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventRipInfo">
            <summary>
            Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventRipInfo.#ctor(System.IntPtr)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.RipEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventRipInfo"/></param> 
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventRipInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.RipEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventRipInfo"/></param> 
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <remarks>The reference counter for this class is also set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventRipInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Construct a wrapper class for a <see cref="T:InsightSheath.Debugging.DebugEvent"/> containing a <see cref="T:InsightSheath.Debugging.DebugEventType"/> of <see cref="F:InsightSheath.Debugging.DebugEventType.RipEvent"/>
            </summary>
            <param name="Nat">pointer to a unmanaged DEBUG_EVENT structor one a valid pointer from <see cref="M:InsightSheath.Debugging.DebugEvent.GetDebugEventRipInfo"/></param> 
            <param name="FreeOnCleanup">Set if you want the unmanaged poiner released. </param>
            <param name="RefCount">Specific the current reference counter. When it reaches 0 during cleanup, the unmanaged pointer is freed. </param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventRipInfo.Error">
            <summary>
            Get the Error number that caused the debugging RIP event.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventRipInfo.ErrorType">
            <summary>
            Should be one of the enum values for <see cref="T:InsightSheath.Debugging.RipErrorType"/>. If It's zero, MSDN documentation says only sdwError is set.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventUnloadDllInfo">
            <summary>
            Wrapper for a Debug Event containing an UNLOAD_DLL_DEBUG_EVENT.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventUnloadDllInfo.#ctor(System.IntPtr)">
            <summary>
            Creation.  Does NOT free the underling pointer. Reference counter set to 1.
            </summary>
            <param name="NativePtr">native pointer to a DEUBG_EVENT struct containing one UNLOAD_DLL_DEBUG_EVENT. </param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventUnloadDllInfo.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Creation.  Reference counter set to one.
            </summary>
            <param name="NativePtr">native pointer to a DEUBG_EVENT struct containing one UNLOAD_DLL_DEBUG_EVENT. </param>
            <param name="FreeOnCleanup">Indicate if we're claling free() when GC clean this instance up.</param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventUnloadDllInfo.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Creation.  Reference counter set to one.
            </summary>
            <param name="NativePtr">native pointer to a DEUBG_EVENT struct containing one UNLOAD_DLL_DEBUG_EVENT. </param>
            <param name="FreeOnCleanup">Indicate if we're claling free() when GC clean this instance up.</param>
            <param name="RefCount">Indicate the current reference counter for the unmanaged memory block.  Block is freed only if reference counter decreases to zero during GC collection.</param>
        </member>
        <member name="P:InsightSheath.Debugging.DebugEventUnloadDllInfo.BaseOfDll">
            <summary>
            The base address of the DLL that was previously loaded. 
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEvent">
            <summary>
            This encapsulates the Native DebugEvent structure via calling exported C routines in InsightAPI.dll.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.#ctor(System.IntPtr)">
            <summary>
            Creation.  Does NOT free the underling pointer.
            </summary>
            <param name="NativePtr">Native pointer to one DEBUG</param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create the wrapper for a DEBUG_EVENT native struct. 
            </summary>
            <param name="Nat">block of unmanaged memory that points to a buffer the sizeof of a DEBUG_EVENT</param>
            <param name="FreeOnCleanup">true to call free() when done and false if not</param>
            <remarks>Reference count is set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.#ctor(System.IntPtr,System.Boolean,System.UInt64)">
            <summary>
            Create the wrapper for a DEBUG_EVENT native struct. 
            </summary>
            <param name="Nat">block of unmanaged memory that points to a buffer the sizeof of a DEBUG_EVENT</param>
            <param name="FreeOnCleanup">true to call free() when done and false if not</param>
            <param name="RefCount">Specifies the reference count</param>
            <remarks>Reference count is set to 1</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.CreatePrivateStruct">
            <summary>
            You don't need to use this if the let the debugger code use the worker thread. You'll need to allocate a native block to hold the debug struct should you decide to roll your own
            </summary>
            <returns>a new <see cref="T:InsightSheath.Debugging.DebugEvent"/> class instance with its own private native structure</returns>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.Dispose(System.Boolean)">
            <summary>
            Nothing special needed to dispose off. Defaultis ok.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateProcessInfo">
            <summary>
            Return an instance of the wrapper to deal with <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/> events. The class still points to the native struct and does not need to be freed().
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventCreateThreadInfo">
            <summary>
            Retrieve an instance of <see cref="T:InsightSheath.Debugging.DebugEventCreateThreadInfo"/> pointing to the same unmanaged memory as this class.
            </summary>
            <returns>Returns a new instance of <see cref="T:InsightSheath.Debugging.DebugEventCreateThreadInfo"/> if the contained event is <see cref="F:InsightSheath.Debugging.DebugEventType.CreateTheadEvent"/>. If it does not contain the specific event, it throws <see cref="T:System.InvalidOperationException"/> and pointentially returns null if something else happens</returns>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventExceptionInfo">
            <summary>
            If this is an event of <see cref="F:InsightSheath.Debugging.DebugEventType.ExceptionEvent"/>, return an instance of <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/>
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/> if the contained event matches. Throws <see cref="T:System.InvalidOperationException"/> if not correct type</returns>
            <exception cref="T:System.InvalidOperationException">This is thrown if the event is not the correct type</exception>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetEventExitProcessInfo">
            <summary>
            If this is an event of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitProcessEvent"/>, return an instance of <see cref="T:InsightSheath.Debugging.DebugEventExitProcessInfo"/>
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.DebugEventExitProcessInfo"/> if the contained event matches. Throws <see cref="T:System.InvalidOperationException"/> if not correct type</returns>
            <exception cref="T:System.InvalidOperationException">This is thrown if the event is not the correct type</exception>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetEventExitThreadInfo">
            <summary>
            If this is an event of <see cref="F:InsightSheath.Debugging.DebugEventType.ExitThreadEvent"/>, return an instance of <see cref="T:InsightSheath.Debugging.DebugEventExitThreadInfo"/>
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.DebugEventExitThreadInfo"/> if the contained event matches. Throws <see cref="T:System.InvalidOperationException"/> if not correct type</returns>
            <exception cref="T:System.InvalidOperationException">This is thrown if the event is not the correct type</exception>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventLoadDll">
            <summary>
            If this is an event of <see cref="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent"/>, return an instance of <see cref="T:InsightSheath.Debugging.DebugEventLoadDllInfo"/>
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.DebugEventLoadDllInfo"/> if the contained event matches. Throws <see cref="T:System.InvalidOperationException"/> if not correct type</returns>
            <exception cref="T:System.InvalidOperationException">This is thrown if the event is not the correct type</exception>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventStringInfo">
            <summary>
            If this is an event of <see cref="F:InsightSheath.Debugging.DebugEventType.OutputDebugString"/>, return an instance of <see cref="T:InsightSheath.Debugging.DebugEventStringInfo"/>
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.DebugEventStringInfo"/> if the contained event matches. Throws <see cref="T:System.InvalidOperationException"/> if not correct type</returns>
            <exception cref="T:System.InvalidOperationException">This is thrown if the event is not the correct type</exception>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventRipInfo">
            <summary>
            Get class suitable to reading DEBUG_EVENT_RIP_INFO from this class.  Will throw <see cref="T:System.InvalidOperationException"/> if not the correct event
            </summary>
            <exception cref="T:System.InvalidOperationException"> Is thrown when the contained even is not a <see cref="F:InsightSheath.Debugging.DebugEventType.RipEvent"/></exception>
            <returns>If the contained event is <see cref="F:InsightSheath.Debugging.DebugEventType.RipEvent"/> returns a <see cref="T:InsightSheath.Debugging.DebugEventRipInfo"/> pointing to this event. </returns>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.GetDebugEventUnloadDllInfo">
            <summary>
            If this is an event of <see cref="F:InsightSheath.Debugging.DebugEventType.UnloadDllEvent"/>, return an instance of <see cref="T:InsightSheath.Debugging.DebugEventUnloadDllInfo"/>
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.DebugEventUnloadDllInfo"/> if the contained event matches. Throws <see cref="T:System.InvalidOperationException"/> if not correct type</returns>
            <exception cref="T:System.InvalidOperationException">This is thrown if the event is not the correct type</exception>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEvent.Finalize">
            <summary>
            The destructor that calls the dispose routine
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.DebugEventWorkerThreadSupport">
            <summary>
            If you are wanting to control your debug message pump on the .NET side rather than native (why?), then these routines will help you 
            glue everything together.  This class exists only in the sheath and is not duplicated in Native. Some routines here may be echoed in other classes in the sheath
            Some of the routines here exist as extensions to <see cref="T:InsightSheath.Debugging.DebugEvent"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventWorkerThreadSupport.WaitForDebugEvent(InsightSheath.Debugging.DebugEvent,System.UInt32)">
            <summary>
            Wait for Debug Event to occur and get information regarding it. This Wraps MSDN's WaitForDebugEventEx() (which optpts you into UNICODE) Call it and pass <see cref="T:InsightSheath.Debugging.DebugEvent"/>'s Native Pointer.
            </summary>
            <param name="Output">Allocate a native block correctly sized for debug event or just make an instance with existing routines</param>
            <param name="WaitTime">How long to wait between times. (uint)-1 aka <see cref="F:System.UInt32.MaxValue"/></param> means wait until event triggers
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Debugging.DebugEventWorkerThreadSupport.ContinueDebugEvent(InsightSheath.Debugging.DebugEvent,System.UInt32,System.UInt32,InsightSheath.Debugging.Process.DebugContState)">
            <summary>
            Return Control of the debugged Software back to Windows and specify how to resume. This wraps MSDN's ContinueDebugEvent
            </summary>
            <param name="that">Exists to let this routine to be an extension to <see cref="T:InsightSheath.Debugging.DebugEvent"/> </param>
            <param name="ProcessId">Process ID of the debug event that was generated</param>
            <param name="ThreadId">thread id of the debug event that was generated</param>
            <param name="ContinueState">how to return control back to Windows</param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Debugging.Process.InsightMemory">
            <summary>
            Get memory data about an arbitrary process of your choice
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.CreateInstance">
            <summary>
            Create an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> from the unmanaged DLL and return a pointer encapsulated in the .NET class.
            </summary>
            <returns>Returns an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> already set to point to the unmanaged DLL's code</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.CreateInstance(System.IntPtr)">
            <summary>
            Duplicate an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> from the passed pointer.  
            </summary>
            <param name="Handle"></param>
            <returns>Returns an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> already set to point to the same process that the passed pointer. Each instance can separately point to other pointers</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.CreateInstance(System.UInt32)">
            <summary>
            Create an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> and point it to read about the passed process.
            </summary>
            <param name="Process">process id to read about. It must be able to be opened for PROCESS_QUERY_INFORMATION and PROECSS_VM_READ </param>
            <returns>Returns an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> already set to point to the unmanaged DLL's code. The class is pointed to use the passed process</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.DuplicateInstance(InsightSheath.Debugging.Process.InsightMemory)">
            <summary>
            Duplicate an instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> from an existing copy.
            </summary>
            <param name="Other">separate instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/></param>
            <returns>Returns a separate  instance of <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> already set.</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.#ctor(System.IntPtr)">
            <summary>
            Create an instance of the wrapper class and point to the native pointer for the native side of the class.
            </summary>
            <param name="that">Non-null pointer</param>
            <exception cref="T:System.ArgumentNullException">Raises this if argument is null</exception>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create an instance of the wrapper class and point to the native pointer for the native side of the class.
            </summary>
            <param name="that">Non-null pointer</param>
            <param name="FreeOnCleanup">Ignored</param>
            <exception cref="T:System.ArgumentNullException">Raises this if argument is null</exception>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.Dispose(System.Boolean)">
            <summary>
            Invoke the proper clean up routine for <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> for unmanaged resources and also managed if dispose is true
            </summary>
            <param name="disposing">set to true if disposing of managed resources also.</param>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory">
            <summary>
            Control if each call to one of these values will result in another call to get an updated value. The default is true; however, that can BE A PERFORMANCE PENALTY if you're getting the value individually for each setting frequently in a loop.
            Recommend False if you're reading them a lot
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.MemoryStatsBulk32">
            <summary>
            Return the x86 bit version of the underlying structure containing the memory statistics.
            </summary>
            <remarks>Know if you're asking about an x86 or x64 process. While this shouldn't crash, grabbing the wrong one will produce garbage values</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.MemoryStatsBulk64">
            <summary>
            Return the x64 bit version of the underlying structure containing the memory statistics.
            </summary>
            <remarks>Know if you're asking about an x86 or x64 process. While this shouldn't crash, grabbing the wrong one will produce garbage values</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.SetTargetProcess(System.IntPtr)">
            <summary>
            Choose which process this instance of the class is going to ask about via a Win32 Handle.
            </summary>
            <param name="Handle">Win32 Native Handle that should at least have PROCESS_QUERY_INFORMATION and likely PROCESS_VM_READ. Handle is duplicated to a private variable in the native side. You don't need to keep this handle open afterwards</param>
            <returns>true if we successfully switched to this handle and false otherwise.</returns>
            <remarks>The Native routine duplicates the handle for PROCESS_QUERY_INFORMATION and PROCES_VM_READ. You do not need the keep the handle open afterwards</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.SetTargetProcess(System.UInt32)">
            <summary>
            Choose which process this instance of the class is going to ask about via a process Handle.
            </summary>
            <param name="ProcessId">The process should be able to be opened for PROCESS_QUERY_INFOMRAITON and likely PROCES_VM_READ.  Handle is kept in a private variable for the life of the class until the Native copy is deleted</param>
            <returns>true if we successfully switched to this handle and false otherwise.</returns>
            <remarks>The Native routine opens the process for PROCESS_QUERY_INFORMATION and PROCES_VM_READ. You do not need the keep the handle open afterwards</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats">
            <summary>
            Trigger a manual refresh of the Memory information. Note if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is true, this routine does NOT need to be called.
            </summary>
            <returns>returns true if it worked and false if it did not</returns>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.PageFaultCount">
            <summary>
            Get the number of page faults for the targeted process.
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.PeakWorkingSetSize">
            <summary>
            Get the peak working set size, in bytes for the targeted process. 
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.WorkingSetSize">
            <summary>
            Get the current working set size in bytes for the targeted process
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.QuotaPeakPagedPoolUsage">
            <summary>
            Get the peak paged pool usage in bytes for the targeted process
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.QuotaPagedPoolUsage">
            <summary>
            Get the current paged pool usage in bytes for the targeted process
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.QuotaPeakNonPagedPoolUsage">
            <summary>
            Get the peak non paged pool usage in bytes.
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.QuotaNonPagedPoolUsage">
            <summary>
            Get the current non paged pool usage in bytes.
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.PageFileUsage">
            <summary>
            Get the Commit Charge for the targeted process in bytes. This  is the total private amount of memory allocated to the targeted process by Windows.
            </summary>
            <remarks>In a preWidows 7/ Server 2012 R2 World this is always zero. Please use <see cref="P:InsightSheath.Debugging.Process.InsightMemory.PrivateUsage"/> instead. Don't forget to  <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.PeakPageFileUsage">
            <summary>
            Get the peak value in bytes  of the Commit Charge during the targeted process's lifetime.
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightMemory.PrivateUsage">
            <summary>
            Same as <see cref="P:InsightSheath.Debugging.Process.InsightMemory.PageFileUsage"/> in a post Windows 7+/Windows Server 2012+ world per MSDN documentation
            </summary>
            <remarks>Call <see cref="M:InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats"/> if <see cref="P:InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory"/> is false get up to date values.</remarks>
        </member>
        <member name="T:InsightSheath.Debugging.Process.DebugContState">
            <summary>
            Enum to control how to return control of a debugged process your debugger is respending too back to Windows. Used in several spots. <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/>, <see cref="T:InsightSheath.Debugging.DebugEventWorkerThreadSupport"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.DebugContState.DebugContinueState">
            <summary>
            The event was processed OK and program execution can continue safely (Use to continue all events and if an Exception Was Handled
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.DebugContState.DebugExceptionNotHandled">
            <summary>
            The Exception Was not handled at all by the your debugger,  pass it back to the debugged program
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.DebugContState.DebugExceptionReplyLater">
            <summary>
            I'm sorry, I'm not in right now to deal with this exception.  Tells Windows to reply the event later.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.DebugModeType">
            <summary>
            Flags to indicate to <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> how to spawn  the target and connect with the debugging code.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.DebugModeType.Default">
            <summary>
            Do not spawn teh worker thread and do not drop calling your call in said worker thread (i.e do nother and your code must deal with communicating with the Windows Debugger API)
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.DebugModeType.EnableWorkerThread">
            <summary>
            When Spawning a process for debugger, InsightApi.DLL implements a debug loop and offloads the loop to a worker thread.  Put a call to <see cref="M:InsightSheath.Debugging.Process.InsightProcess.PulseDebugEventThead"/> to continue after handling your debug event on a regular basis.  Skipping that means, your debugged process won't continue after the first event.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.DebugModeType.WorkerDropCallbackForNoEvents">
            <summary>
            Only if EnableWorkerThread is active too.  This tells the worker thread to DROP calling your event callback if there's no event after the time ror awaiting for debug event expires
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.InsightProcess">
            <summary>
            choose an environment and spawn a process.
            This class is a wrapper for the C++ Class named "InsightProcess" implemented as a native DLL in the source PS_ProcessInformation.cpp
            and said class is the functionally the heart of the DLL.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.#ctor(System.IntPtr)">
            <summary>
            return an instance of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> with it's native pointer set to the unmanaged part of InsightAPI's InsightProcess
            </summary>
            <param name="That">non null instance of the unmanaged part of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/></param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is equal to null."/></exception>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            return an instance of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> with it's native pointer set to the unmanaged part of InsightAPI's InsightProcess
            </summary>
            <param name="That">non null instance of the unmanaged part of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/></param>
            <param name="FreeOnCleanup">Indicate if during GC cleanup, we'll get calling an unmanaged routine to delete this. You usually will want this to bve true unless your playing with multiple wraooe classes pointing to the same unmanaged pointer</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is equal to null."/></exception>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.GetHashCode">
            <summary>
            Get a hash of the native pointer used by this current <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> instance
            </summary>
            <returns>Returns a hash of the native pointer used by this current <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> instance</returns>
        </member>
        <member name="T:InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine">
            <summary>
            This delegate is used in the native worker thread to notify your .NET code when a debug event occurs.
            </summary>
            <param name="DebugEvent">Pointer to a DEBUG_EVENT struct. <see cref="T:InsightSheath.Debugging.DebugEvent"/> to make a wrapper for it. IMPORTANT: Your stub is receiving a pointer off the unmanaged heap and should make your wrapper with FreeOnCleanUp=false aka <see cref="M:InsightSheath.Debugging.DebugEvent.#ctor(System.IntPtr)"/></param>
            <param name="ContinueState">Pointer to a 4 byte value where to write how your debugger callback responded to the routine. <see cref="M:InsightSheath.Debugging.Process.InsightProcess.SetDebugEventCallbackResponse(System.IntPtr,InsightSheath.Debugging.Process.DebugContState)"/> or <see cref="!:LocalUnmanagedMemory.SetDebugEventCallbackResponse(IntPtr, DebugContState)"/> or <see cref="M:InsightSheath.MemoryNative.Poke4(System.IntPtr,System.UInt32)"></see></param>
            <param name="WaitTimer">Pointer to a 4 byte value where to write how long to wait until receiving the next debug event. Note: If this timer expires, the worker thread is NOT going to call your callback. <see cref="!:LocalUnmanagedMemory.Poke4(IntPtr, uint)"/></param>
            <param name="CustomArg">Reserved. Always 0. TODO: Add way to pass values too it </param>
            <returns>Your delegate should return 0 to keep going and non zero to quit. Value does not matter currently.</returns>
            <remarks> current C/C++ callback define for this is "typedef int(WINAPI* DebugEventCallBackRoutine)(LPDEBUG_EVENT lpCurEvent, DWORD* ContinueStatus, DWORD* WaitTimer, DWORD CustomArg);" </remarks>
        </member>
        <member name="T:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction">
            <summary>
            TODO: something with this. (These are constants defined is PS_ProcessInformation.h and should be kept synced) That's the only reason i've not deleted this as I'm figuring I'll forgot to add it again
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.DropFileReadRequests">
            <summary>
            Strip generic read from NtOpen/ NtCreate
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.PositiveDenyFileReadRequests">
            <summary>
            report success BUT do not actually open the file for reading
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.NegativeDenyFileReadRequest">
            <summary>
            Report access denied and do not open file 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.DropFileWriteRequests">
            <summary>
            Strip generic write from NtOpen/ NtCreate
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.PositiveDenyFileWriteRequest">
            <summary>
            report success BUT do not actually open file for writing
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.NegativeDenyFileWriteRequests">
            <summary>
            report access denied and don't open file
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.NegativeDenyProcessSpawn">
            <summary>
            report failure and do not spawn Processes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.CommandProcessProperate">
            <summary>
            force the process to load the helper DLL.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction.CommadMaxValue">
            <summary>
             A theoretical cap for the values. 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.BackUpCopy">
            <summary>
            I've read that the GC will sometimes collect function pointers passed to native routines that will need to call back.
            This gets an assignment with calling <see cref="P:InsightSheath.Debugging.Process.InsightProcess.UserDebugCallRoutine"/> while sending the pointer into native land. This
            should in theory let the GC know that the pointer needs to be kept in memory.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.InsightProcess.CreationFlagValues">
            <summary>
            Flags to change how the process is spawned. From <see href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.CreationFlagValues.CreateUnicodeEnviroment">
            <summary>
            Functionally unnessary for <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/>. The native code (InsightAPI.DLL) always includes this flag which indicates the passed enviroment block is Unicode characters when spawning the target. 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.CreationFlagValues.DebugOnlyThisProcess">
            <summary>
            You'll receive debug messages from windows about only your spawned process. Child processes spawned aren't debugged
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.CreationFlagValues.DebugProcess">
            <summary>
            You'll receive debug messages from windows for your spawned process and any child processes it spawns
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.CreationFlagValues.ExtendedStartupInfoPresent">
            <summary>
            Functionally 
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.InsightProcess.SpecialCaseFlags">
            <summary>
            Used to make 'typical' flags like ResumeThread, DebugProcess and DebugOnlyThisProcess without needing to look values up. You also can just look the values up.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.SpecialCaseFlags.None">
            <summary>
            nothing needed
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.SpecialCaseFlags.DebugOnlyThis">
            <summary>
            Add  the "DEBUG_ONLY_THIS_PROCESS" value when spawning the process
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.SpecialCaseFlags.DebugChild">
            <summary>
            Add  the "DEBUG_PROCESS" value when spawning the process
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.SpecialCaseFlags.CreateSuspended">
            <summary>
            Add the CREATE_SUSPENDED value when spawning the process
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.CreateInstance">
            <summary>
            Create an instance of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> on  the native side and return an instance of the wrapper class <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> set to use this native pointer
            </summary>
            <returns>returns instance of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> already set to us the unmanaged pointer of the class</returns>
            <exception cref="T:System.InvalidOperationException">Should the unmanaged constructor routine fail to make an intance (return 0), this is thrown</exception>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.SpawnProcess">
            <summary>
            Spawn the process contained within the underlying class.  Return Value is the spawned process's ID on OK and 0 on failure.
            </summary>
            <returns>process id </returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.PulseDebugEventThead">
            <summary>
            When  Spawning a process with a DEBUG option and  <see cref="P:InsightSheath.Debugging.Process.InsightProcess.DebugMode"/> is set to <see cref="!:DebugModeType.WorkerThread"/>, the native DLL spawns a thread to handle consuming events.
            The thread also using an native Event object to sync giving the events back to the caller so that the caller's GUI is not interrupted. Does not actually pulse event.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.GetSymbolHandler">
            <summary>
            get an instance of the symbol handler uses by this process context.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.UpdateSymbolEngine(System.IntPtr)">
            <summary>
            If you don't want the worker thread, you'll need to call this routine to update symbol engine with new data when you get process debug events
            </summary>
            <param name="DebugEnvent"></param>
            <returns></returns>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.DebugMode">
            <summary>
            Specify if you want the native DLL to handling spawning the process or if you're code will.  Should you make it so your code will. You'll need to include WaitForDebugEvent() and ContinueDebugEvent() calls in a debugger loop
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.RequestDebugPriv">
            <summary>
            Ask for the "SeDebugPriv" if spawning things to Debug PROCESS_DEBUG and PROCESS_DEBUG_ONLY_THIS
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.UserDebugCallRoutine">
            <summary>
            Get (or set) the routine that the debug worker thread will be calling.
            null (or unassigned) means use the default one which does nothing with events and exceptions, does not handle exceptions, and continues until it gets a single exit process debug event
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.DetourList">
            <summary>
            Return an unmodifiable list of the entries in the Current Detours List. Please use other routines to change this entry.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.ProcessName">
            <summary>
            Contains the process that was / will be launched.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.ProcessArguments">
            <summary>
            Contains the process arguments that will be passed to the process when it is launched.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.WorkingDirectory">
            <summary>
             Set the starting directory for the process to be launched
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.DetourMustSucceed">
            <summary>
            Default is TRUE.  Should the code be unable to detour, process is killed and failure is returned.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.InheritDefaultEnviroment">
            <summary>
            Default is false.  If false, only environment variables you explicitly define will be in the spawned process.  If true, the spawned process will inherit your debugger environment variables BUT the explicit variables you define will override the inherited ones.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.EnableSymbolEngine">
            <summary>
            Enable or Disable the symbol engine. Symbol engine is active once first process starts.  Disabling the engine means it will no longer get updates until enabled again.  <see cref="P:InsightSheath.Debugging.Process.InsightProcess.DebugMode"/>  should be set to <see cref="!:DebugModeType.WorkerThread"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.CreationFlags">
            <summary>
            Specify process creation flags (or get them).  Look at the CreateProcessA/W <see href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa"/> flags online for more info. 
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.ExtraFlags">
            <summary>
            Specify some specific case flags. Or you can just directly Set CreationFlags itself.
            Implemented only in the C# wrapper. NOT IMPLMENTING in the C++ code.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.SetExplicitEnviromentValue(System.String,System.String)">
            <summary>
            Specify an explicit environmental value.  Values that match the default environment will overwrite the default onces for the process
            </summary>
            <param name="Name">This is the name of the environment value to define. For example "PATH"</param>
            <param name="Value">This is the value of the environment value to define. For example "C:\Windows;C:\Windows\system32;</param>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.GetExplicitEnviromentValue(System.String)">
            <summary>
            Get an explicit environmental value from a previous call to <see cref="M:InsightSheath.Debugging.Process.InsightProcess.SetExplicitEnviromentValue(System.String,System.String)"/>
            </summary>
            <param name="Name">This is the name of the environment value to define. For example "PATH"</param>
            <returns>Returns a string if the value exists or null if it does NOT</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.GetStartupInfoClass">
            <summary>
            Retrieve instance of the class that handles the startup info management. 
            </summary>
            <remarks>Should the Native size for this instance of StartupInfo change to be allocated, this routine will need to be updated to prevent a memeory leak.</remarks>
            <returns>This routines an instance to a <see cref="T:InsightSheath.Win32Struct.StartupInfoExW"/> class that you can use to customize startup settings. This instance is part of the underlying instance of <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> and should not be freed/deleted on clean up if duplicated</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.AddDetoursDll(System.String)">
            <summary>
            Add a DLL to list of Detours DLLs to force the target process to load on spawn.
            DOES NOT WORK if process is running 
            </summary>
            <param name="NewDllToForceLoad"></param>
            <remarks>Currently detouring from parent to child with matching bitness works; however, x64 bit code is limited currently to detouring x64 processes. x86 can do both.</remarks>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.ResetDetoursDllList">
            <summary>
            Clear the detours list back to empty.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.HelperDll_AddLoadLibraryPath(System.String)">
            <summary>
            Add an entry to the list of paths that the LoadLibraryXXXX() routines will check first before assuming normal search path
            </summary>
            <param name="NewLocation"></param>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.HelperDll_ClearLoadLibraryPath">
            <summary>
            Remove all entries for the HelperDll's priority LoadLibrary search path
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.HelperDll_GetLoadLibraryPathCount">
            <summary>
            return how many entries are in the helperdll's priority LoadLibrary search path
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.HelperDll_IndexLoadLibraryPath(System.Int32)">
            <summary>
            return a string index pointed to the helper DLL's search path (or null) if index out of bounds
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk">
            <summary>
            Get all the memory stats in once call and return a struct containing them. May return null if it can't fetch it.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.PageFaultCount">
            <summary>
            Number of Page Faults for the main process.
            </summary>
            <remarks>Why is this hidden? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.PeakWorkingSet">
            <summary>
            Peaked working set size, in bytes
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.WorkingSet">
            <summary>
            Working set size, in bytes
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.QuotaPeakPagePoolUsage">
            <summary>
            peaked page pool usage, in bytes
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.QuotaPagePoolUsage">
            <summary>
            current page pool usage, in bytes
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.QuotaPeakNonPagePoolUsage">
            <summary>
            peaked nonpaged pool usage, in bytes
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.QuotaNonPagePoolUsage">
            <summary>
            current non page pool usage, in bytes
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.PageFileUsage">
            <summary>
            Commit change value for the process in bytes.  Note: MSDN Windows 7/ Server 2008 says check <see cref="P:InsightSheath.Debugging.Process.InsightProcess.PrivateUsage"/> instead
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.PeakPageFileUsage">
            <summary>
            Peak value of committed change during process lifetime
            </summary>
            <remarks>Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Process.InsightProcess.PrivateUsage">
            <summary>
            Private memory usage.
            </summary>
            <remarks>Why is this hidden Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with <see cref="P:InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk"/></remarks>
        </member>
        <member name="M:InsightSheath.Debugging.Process.InsightProcess.SetDebugEventCallbackResponse(System.IntPtr,InsightSheath.Debugging.Process.DebugContState)">
            <summary>
            For the <see cref="T:InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine"/>.  Use the <see cref="T:System.IntPtr"/> passed containing the location of where to write the continue state.
            </summary>
            <param name="contStat">Pointer receiving in the <see cref="T:InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine"/> to process events</param> 
            <param name="Response">Indicate your response to Windows using <see cref="T:InsightSheath.Debugging.Process.DebugContState"/></param>
        </member>
        <member name="F:InsightSheath.Debugging.Process.InsightProcess.IsCleanned">
            <summary>
            Once the dispose()/ finalize() is ran, this is set to true
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.ProcessMemoryCount64">
            <summary>
            Process Memory count for 64-bit process
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.cb">
            <summary>
            Size of this structure in unmanaged land.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PageFaultCount">
            <summary>
            Number of Page Faults for a given process.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PeakWorkingSetSize">
            <summary>
            Peaked working set size, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.WorkingSetSize">
            <summary>
            Working set size, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaPeakedPagedPoolUsage">
            <summary>
            peaked page pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaPagedPoolUsage">
            <summary>
            current page pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaPeakedNonPagePoolUsage">
            <summary>
            peaked non paged pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaNonPagePoolUsage">
            <summary>
            current non page pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PageFileUsage">
            <summary>
            Commit change value for the process in bytes.  Note: MSDN Windows 7/ Server 2008 says check <see cref="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PrivateUsage"/> instead
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PeakPageFileUsaged">
            <summary>
            Peak value of committed change during process lifetime
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PrivateUsage">
            <summary>
            same as <see cref="F:InsightSheath.Debugging.Process.ProcessMemoryCount64.PageFileUsage"/>,  Current Commit Charge value in butes for this process.  This is the amount that the memory manage as allocated for this process.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.ProcessMemoryCount32">
            <summary>
            Process Memory count for 32-bit process
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.cb">
            <summary>
            Size of this structure in unmanaged land.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PageFaultCount">
            <summary>
            Number of Page Faults for a given process.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PeakWorkingSetSize">
            <summary>
            Peaked working set size, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.WorkingSetSize">
            <summary>
            Working set size, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaPeakedPagedPoolUsage">
            <summary>
            peaked page pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaPagedPoolUsage">
            <summary>
            current page pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaPeakedNonPagePoolUsage">
            <summary>
            peaked non paged pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaNonPagePoolUsage">
            <summary>
            current non page pool usage, in bytes
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PageFileUsage">
            <summary>
            Commit change value for the process in bytes.  Note: MSDN Windows 7/ Server 2008 says check <see cref="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PrivateUsage"/> instead
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PeakPageFileUsaged">
            <summary>
            Peak value of committed change during process lifetime
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PrivateUsage">
            <summary>
            same as <see cref="F:InsightSheath.Debugging.Process.ProcessMemoryCount32.PageFileUsage"/>,  Current Commit Charge value in butes for this process.  This is the amount that the memory manage as allocated for this process.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK">
            <summary>
            https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.API_VERSION">
            <summary>
            API_VERSION struct for DebugHelp symbol library.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.API_VERSION.MajorVersion">
            <summary>
            The Major Version of the API
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.API_VERSION.MinorVersion">
            <summary>
            Minor Version of the API
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.API_VERSION.Revision">
            <summary>
            Revision of the API
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.API_VERSION.Reserved">
            <summary>
            Reserved  for future use
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct">
            <summary>
            Wrappers for Api Version struture. Note: Impementation in Insight has the struct as part of it, you DON'T want to free any pointer to it you get from insite.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.#ctor(System.IntPtr)">
            <summary>
            Initialize this wrapper class to point to an unmanaged memory structure containing one API_VERISON structy
            </summary>
            <param name="Native">non null native pointer</param>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initialize this wrapper class to point to an unmanaged memory structure containing one API_VERISON structy.
            </summary>
            <param name="Native">non null native pointer</param>
            <param name="FreeOnClean">Ignored. Always false when calling the base <see cref="T:InsightSheath.Abstract.NativeStaticContainer"/> contructor</param>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.Revision">
            <summary>
            Get the Revison member of the API_VERSION data struct the Native pointer points too
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.Major">
            <summary>
            Get the Major member of the API_VERSION data struct the Native pointer points too
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.Minor">
            <summary>
            Get the Minor member of the API_VERSION data struct the Native pointer points too
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSearchCallBackRoutine">
            <summary>
            This is the callback for <see cref="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.EnumerateSymbols(System.String,InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSearchCallBackRoutine)"/>. The passed pointer to your routine is a native pointer to a struct <see cref="T:InsightSheath.Debugging.SymbolEngine.SymbolInfo"/>'s that exists for while your routine is active. 
            </summary>
            <param name="SymbolInfo">Your routine will get an <see cref="T:System.IntPtr"/> pointing to a an unmanaged memory block contaiing symbol data that matched. <see cref="T:InsightSheath.Debugging.SymbolEngine.SymbolInfo"/>. This unmanaged memory only contains it for the life of your callback. Duplicate if you need to store or use later.</param>
            <returns>Your Routine should return TRUE to keep going and FALSE to quit</returns>
            <remarks>The exact routine pointer  that this is based off is  typedef BOOL (WINAPI* SymbolSearchCallback)(SYMBOL_INFOW);  MSDC documentation 
            for the callback being invoked here: <see href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nc-dbghelp-psym_enumsourcefiles_callback"/> and the API being called is <see href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symenumsourcefilesw"/>  </remarks>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSourceCallbackRoutine">
            Callback for Enumerating source files. Return true to continue and false to quit
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.InsightHunter">
            <summary>
            A part of the symbol engine exported in InsightAPI in the Native DLL. 
            This class is VERY VERY VERY tightly coupled with the <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> class but distinct enough to warrent its own class/wrapper wrappers. 
            If you need not have symbol processing, disabling <see cref="P:InsightSheath.Debugging.Process.InsightProcess.EnableSymbolEngine"/> is set to false if fine. That turns off the code that updates the native <see cref="T:InsightSheath.Debugging.SymbolEngine.InsightHunter"/> class when the worker thread receives a debug event
            NOTE: You'll need to spawn at least one process with <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> to get much use out of this.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags">
            <summary>
            Specifies combinations of flags to Set for the symbol engine as seein in MSDN's <see href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symsetoptions"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.AllowAbsoluteSymbols">
            <summary>
            Enable use of symboled stored as absolute instead only of Relative Addressing that get converted to absolute addresses.  Requires DbgHelp version 5.2 or later.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.AllowZeroAddress">
            <summary>
            Enable seeing symbols that have no defined address. Default is that the Symbol Engine filters these out.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.AutoPublics">
            <summary>
            Disables searching publics symbols when searchin by address/ enumarting or not found in global and current score.  Ignored if <see cref="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.PublicsOnly"/> is set also.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.CaseInsensitive">
            <summary>
            If set, searches in the symbol engine are case insensitive. 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.DebugMode">
            <summary>
            Enable additional output to either a callback function (TODO: write that wrapper) or <see href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringw"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.DeferredLoad">
            <summary>
            Symbols are not loaded until a reference is encountered.  Better for performance.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.DisableSymServerAutoDetect">
            <summary>
            Disable the autodetecting of symbovl server stores in the server path.  Requires 6.6 or later.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.ExactSymbolRequired">
            <summary>
            Refuse to load Symbol files that don't have a matching binary. Do not load export symbols.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.FailCriticalErrors">
            <summary>
            Should a critical issue such as a resource is not avaialble (cd removed for example), fail the request without informing the user.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.FavorCompressed">
            <summary>
            Tell the Dbghelp routines to favor compressed symbol files over uncompressed should both be accessible.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.FlatDirectory">
            <summary>
            Symbols are stored in the root directory default downstream store.  Requires Dbhhelp 6.2 or greater.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.IgnoreCodeViewRecord">
            <summary>
            Tell Dbghlp to ignore any CodeView records it finds when loading symbols.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.IgnoreImageDir">
            <summary>
            Tell Dbghlp to ignore the image directory.  Requires Dbghelp 6.2 or greater.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.IgnoreNtSymPath">
            <summary>
            Do not use the _NT_SYMBOL_PATH if setting an invalid path.  Not supported for Debug Help 5.1.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.Include32BitModules">
            <summary>
            x64 Windows.  Tell the symbol engine to load for 32-bit modules also.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.LoadAnything">
            <summary>
            Disable checks that ensure loaded files are valid.  Loads the first file found.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.LoadLines">
            <summary>
            Load Line information for files.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.SYMOPT_NO_CPP">
            <summary>
            This has the symbol engine replace C++ decorated symbols including '::' with '__'.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.NoImageSearch">
            <summary>
            Disables searching the image for the current symbol path when loading symbols for a module that cannot be read.  Not supported for DbhHlp 5.1
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.NoPrompts">
            <summary>
            Disabling showing a prompt to validate that the correct symbol server is used.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.NoPublics">
            <summary>
             Disable searching public tables for symbols.  MSDN documentation says global tables likely will have duplicates of public table data. Not supported for DbgHlp 5.1
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.NoUnqualifiedLoads">
            <summary>
            Prevent symbols from being loaded when caller examines symbols accross multiple module boundries. 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.Overwrite">
            <summary>
            Overrite download store from the symbol table. Requires Dbghlp 6.2 or greater.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.PublicsOnly">
            <summary>
            Disables loading private disable.  Requires DbgHlp 5.2 or greater.  Before 5.2, it only loaded public symbols.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.SecureMode">
            <summary>
            Refuse to load symbols not in the symbserver and _NT_SYMBOL_PATH DbgHelp 6.0-6.1 Says flag can be cleared and 5.1 says not supported.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags.UndecorateSymbols">
            <summary>
            Undecorate public symbols when encournted.
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.#ctor(System.IntPtr)">
            <summary>
            Initialize an instance of the wrapper for the ummanaged <see cref="T:InsightSheath.Debugging.SymbolEngine.InsightHunter"/> class to use the copy pointed to by that. 
            </summary>
            <param name="That">non null pointer to an instance of the unmanaged class.</param>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initialize an instance of the wrapper for the ummanaged <see cref="T:InsightSheath.Debugging.SymbolEngine.InsightHunter"/> class to use the copy pointed to by that. 
            </summary>
            <param name="That">non null pointer to an instance of the unmanaged class.</param>
            <param name="FreeOnDispose">Indicate if the object is subject to being freed() when GC cleans up. Recommand FALSE providea a dispose handling cleanup</param>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.LoadExeSymbolInfo(InsightSheath.Debugging.DebugEvent)">
            <summary>
                   
            </summary>
            <param name="debugEvent"><see cref="T:InsightSheath.Debugging.DebugEvent"/> class instance containing a <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/> event</param>
            <returns>true if ok, false on failuree</returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.LoadExeSymbolInfo(System.IntPtr)">
             <summary>
            
             </summary>
             <param name="DebugEvent"><see cref="T:InsightSheath.Debugging.DebugEvent"/> class instance containing a <see cref="F:InsightSheath.Debugging.DebugEventType.CreateProcessEvent"/> event</param>
             <returns>true if ok, false on failuree</returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.LoadDllSymbolInfo(InsightSheath.Debugging.DebugEvent)">
             <summary>
            
             </summary>
             <param name="DebugEvent">class instance containing a <see cref="F:InsightSheath.Debugging.DebugEventType.LoadDllEvent"/> event</param>
             <returns>true if ok, false on failuree</returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.UnloadDllSymbolInfo(InsightSheath.Debugging.DebugEvent)">
            <summary>
                   
            </summary>
            <param name="DebugEvent">class instance containing a <see cref="F:InsightSheath.Debugging.DebugEventType.UnloadDllEvent"/> event</param>
            <returns>true if it worked, false otherwise</returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.UnloadDllSymbolInfo(System.IntPtr)">
            <summary>
                   
            </summary>
            <param name="DebugEvent">class instance containing a <see cref="F:InsightSheath.Debugging.DebugEventType.UnloadDllEvent"/> event</param>
            <returns>true if it worked, false otherwise</returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.SetParentWindow(System.IntPtr)">
            <summary>
            Set the parent window for the symbol engine/ debug help api
            </summary>
            <param name="HWND">Handle to Win32 Window that the debug help api will assume you're outputting info too</param>
            <returns>True if it worked and false if it did not.</returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.EnumerateSymbols(System.String,InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSearchCallBackRoutine)">
            <summary>
            Enumerate loaded symbols for the debugged exe
            </summary>
            <param name="SearchString"></param>
            <param name="DotNetCallback"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.EnumerateSourceFiles(System.String,InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSourceCallbackRoutine)">
            <summary>
            Enumerate loaded source files for symbol 
            </summary>
            <param name="SearchString"></param>
            <param name="DotNetCallBack"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Debugging.SymbolEngine.InsightHunter.RefreshModules">
            <summary>
            reload loaded modules.  
            </summary>
            <returns>true if it worked and false otherwise</returns>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.InsightHunter.SyncAccess">
            <summary>
            Default is true.  This being true means the NativeClass InsightHunter synchronizes calls to the Debug Help Symbol Engine with a CRITICAL_SECTION Win32 Object
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptions">
            <summary>
            Specify what you want to the symbol handler to too.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.InsightHunter.DebugHelp_Version">
            <summary>
            Get or set Version Data on the Debug Help API the symbol engine actually uses.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.InsightHunter.DebugHelp_Version2">
            <summary>
            Get or a copy of the Debug Version or set version compatibility. 
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SourceFile.ModBase">
            <summary>
            Base address of the module this source file is to be used for
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SourceFile.FileName">
            <summary>
            location to read the source file from.
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.SymbolTagType">
            <summary>
            Should be from the SymTagEnum at MSDN https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/bkedss5f(v=vs.100)
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.ClrToken">
            <summary>
            The symbol is a CLR token.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Constant">
            <summary>
            The symbol is a constant.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Export">
            <summary>
            The symbol is from the export table.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Forwarder">
            <summary>
            The symbol is a forwarder.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.FrameRel">
            <summary>
            Offsets are frame relative.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Function">
            <summary>
            The symbol is a known function.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.IrlRel">
            <summary>
            The symbol address is an offset relative to the beginning of the intermediate language block. This applies to managed code only.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Local">
            <summary>
            The symbol is a local variable.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Metadata">
            <summary>
            The symbol is managed meta data.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Parameter">
            <summary>
            The symbol is a parameter.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Register">
            <summary>
            The symbol is a register. The Register member is used.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Regrel">
            <summary>
            Offsets are register relative.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Slot">
            <summary>
            The symbol is a managed code slot.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Thunk">
            <summary>
            The symbol is a thunk.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.TlsRel">
            <summary>
            The symbol is an offset into the TLS data area.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.ValuePresent">
            <summary>
            The Value member is used.
            </summary>
        </member>
        <member name="F:InsightSheath.Debugging.SymbolEngine.SymbolFlags.Virtual">
            <summary>
            The symbol is a virtual symbol created by the SymAddSymbol function.    
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.SymbolEngine.SymbolInfo">
            <summary>
            Wrappers imported for dealing with SymbolInfoW Native structures. 
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.SymbolInfo.TypeDataIndex">
            <summary>
            Get the type index for symbol for this
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolIndex">
            <summary>
            Get the unique value used by the symbol handler for this symbol
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolSize">
            <summary>
            How big is the symbol's data in bytes
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.SymbolInfo.BaseModuleAddress">
            <summary>
            get base address for the symbol's module
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.SymbolEngine.SymbolInfo.Flags">
            <summary>
            Get the flags that describe what's in this structure
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Thread.ThreadContext">
            <summary>
            ThreadContext is a class indented for reading/writing information about threads receives in the main <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> structure
            We duplicate some of the functionality of the <see cref="T:System.Diagnostics.ProcessThread"/> class for C# user familiarity. 
            </summary>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.CreateInstance(System.UInt32)">
            <summary>
            Create a new instance of <see cref="T:InsightSheath.Debugging.Thread.ThreadContext"/> and point it to the passed thread whose id is this.
            </summary>
            <param name="threadId">id of thread to point this class to</param>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.CreateInstance(System.IntPtr)">
            <summary>
            Create a new instance of <see cref="T:InsightSheath.Debugging.Thread.ThreadContext"/> and point it to the thread specified by this handle. You don't need the handle afterwards.
            </summary>
            <param name="ThreadHandle">Win32 Handle to thread you want to point this class instance to. You don't need the handle after this.</param>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.#ctor(System.IntPtr)">
            <summary>
            This links an instance of the ThreadContext on the native side with your Managed code.  Use <see cref="M:InsightSheath.Debugging.Thread.ThreadContext.CreateInstance(System.IntPtr)"/> or <see cref="M:InsightSheath.Debugging.Thread.ThreadContext.CreateInstance(System.UInt32)"/>to make a new instance. This constructor links your .Net Wrapper to a Native underlying instance of the C++ class.
            </summary>
            <exception cref="T:System.ArgumentNullException">If passing null, this is thrown</exception>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            This is required because of how the parent child classes work, Same as <see cref="M:InsightSheath.Debugging.Thread.ThreadContext.#ctor(System.IntPtr)"/> 
            </summary>
            <param name="Native"></param>
            <param name="FreeOnCleanup">Ignored. Always false.  Dispose() has been overwritten to safely kill the instance</param>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.Dispose(System.Boolean)">
            <summary>
            call the proper disposal routine for ThreadContext
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.SuspendThread">
            <summary>
            Suspend either a wow64 thread or x64 bit thread. Will trigger LoadLibrary calls the first time used on wow64
            </summary>
            <returns>current suspend value. Values > 0 mean thread suspended.</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.ResumeThread">
            <summary>
            Resume either a wow64 thread or x64 bit thread. Will trigger LoadLibrary calls the first time used on wow64
            </summary>
            <returns>current suspend value. Values > 0 mean thread suspended.</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.SetTargetThread(System.IntPtr)">
            <summary>
            Set the thread this class is handling based on thread parameter. Once set, you may do what you will with  the original handle
            </summary>
            <param name="ThreadHandleNative"></param>
            <returns>returns true if the call worked and false if it did not</returns>
        </member>
        <member name="M:InsightSheath.Debugging.Thread.ThreadContext.SetTargetThread(System.UInt32)">
            <summary>
            Set the thread this class is handling based on thread id. Discards existing info that this class knowns about for the original thread (if any)
            </summary>
            <param name="ThreadId"></param>
            <returns></returns>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadDescription">
            <summary>
            retrieve or set the thread's description. WARNING May Heap Corruption on Getting value. 
            Current fix is in Native Debug Build and it just does not call local free per the MSDN documentation BUT does not cause appear memory leak after looping thru code to get/set 1000000 times so either so \_()_/
            Want to ensure the fix follows the documentation on MSDN unless MSDN is wrong.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadId">
            <summary>
            Get the ID of the thread this class is paired with.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.IdealProcessor">
            <summary>
            Get or set the Ideal / preferred processor for this thread.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadPriority">
            <summary>
            Get or set the targeted thread's priority.
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.PriorityBoost">
            <summary>
            Get or set the value indicating if Windows should temporarily boost the thread's priority if a window that the thread handles receives focus
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ProcessorAffinity">
            <summary>
            Get or set processor affinity / desired process this thread runs on. Warning. Does not work support more than 64-bit logical processors
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadStartAddress">
            <summary>
            NOT IMPLEMENTED
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadState">
            <summary>
            Here for future.  NOT IMPLEMENTED for this class. TODO: Add this feature with support of the native DLL
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadWaitReason">
            <summary>
            Here for future.  NOT IMPLEMENTED for this class. TODO: Add this feature with support of the native DLL
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadCreationTime">
            <summary>
            When the Thread was created. Note this Refresh ALL items <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadCreationTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadExitTime"/>,  <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime"/> values and returns the one you want
            </summary>
            <remarks>Because of performance reasons in watching in debugger browsing/viewing - this is not browsable.</remarks>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadExitTime">
            <summary>
            If thread active,  (defined as MSDN's getThreadExitCode gets 259 for a exit code), returns 0 instead of ExitTime,  Note this Refershs ALL <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadCreationTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadExitTime"/>,  <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime"/> values and returns the one you want
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime">
            <summary>
            Amount of Time that the thread runs user level code,  Note this Refreshes ALL <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadCreationTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadExitTime"/>,  <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime"/> values and returns the one you want
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime">
            <summary>
            Amount of Time  that the thread runs kernel level code,  Note this Refreshes ALL <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadCreationTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.ThreadExitTime"/>,  <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime"/>, <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime"/> values and returns the one you want
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.TotalProcessorTime">
            <summary>
            Return <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime"/> and <see cref="P:InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime"/> added together for your convenience. 
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.Context">
            <summary>
            Retreieve a pointer to either a wow64_context or a Context struct depending on the thread's type. 
            </summary>
        </member>
        <member name="P:InsightSheath.Debugging.Thread.ThreadContext.Wow64Context">
            <summary>
            Get a pointer to a wow64 context stuct for this thread. If it's not a wow64 thread, returns <see cref="F:System.IntPtr.Zero"/> instead. You can use <see cref="T:InsightSheath.Debugging.Thread.Wow64ContextLayout"/> to access
            </summary>
        </member>
        <member name="T:InsightSheath.Debugging.Thread.Wow64ContextLayout">
            <summary>
            Handler for reading from / writing to a Wow64ContextString
            </summary>
        </member>
        <member name="T:InsightSheath.Detours.DetourBinary_ImportList">
            <summary>
            Used with <see cref="M:InsightSheath.Detours.DetourBinary.GetImports(System.Boolean,System.Boolean)"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Detours.DetourBinary_ImportList.RoutineName">
            <summary>
            Name of routine as seen in the data gathering
            </summary>
        </member>
        <member name="P:InsightSheath.Detours.DetourBinary_ImportList.OrdinalNumber">
            <summary>
            Ordinal of the routine as seen in the data gathering.
            </summary>
        </member>
        <member name="P:InsightSheath.Detours.DetourBinary_ImportList.ModuleName">
            <summary>
            The EXE/DLL/ shared library that this routine is imported from.
            </summary>
        </member>
        <member name="T:InsightSheath.Detours.DetourBinary">
            <summary>
            Wraps DetourBinary routines from detours and exported in insight to  let one inspect/ alter the EXE/DLL's import table. There's also come code to just fetch the imports.
            </summary>
        </member>
        <member name="F:InsightSheath.Detours.DetourBinary.ExeResource">
            <summary>
            the file handle that we hold for the life of this class
            </summary>
        </member>
        <member name="F:InsightSheath.Detours.DetourBinary.DetourBinaryNativeHandle">
            <summary>
            The DetourBinaryXXX routine handle for the life of this class
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:InsightSheath.Detours.DetourBinary.BinaryByWayscallback" -->
        <member name="P:InsightSheath.Detours.DetourBinary.CommitOnDispose">
            <summary>
            If set and GC triggers or dispose is called, we commit changes to the opened file. Will not commit if the file was opened for readonly.
            </summary>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.SaveTo(System.String)">
            <summary>
            Save the modified binary to the location of your choice.
            </summary>
            <param name="Output"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.CommonClass_IniRoutine(System.String,System.IO.FileAccess)">
            <summary>
            this is the common ini routine for the public constructors.
            </summary>
            <param name="ExeName">name of exe or dll to open</param>
            <param name="AccessNeeds">the file access notes we need to acess with</param>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Open the passed executable file (DLL likely fine also) for detourbinary handling
            </summary>
            <param name="ExecutableName">exe to open</param>
            <param name="AccessHandle">open for read/wrte ect..</param>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.#ctor(System.String)">
            <summary>
            Open the passed executable file (DLL likely fine also) for detourbinary handling for reading only
            </summary>
            <param name="ExecutableName">exe to open</param>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.FindPayload(System.Guid,System.UInt32@)">
            <summary>
            TODO: Locate the payload indicated by the passed guid.
            </summary>
            <param name="RefGuid">guid of the payload to look for.</param>
            <param name="SizeOfPayload">If the payload exists, receives its size in bytes, otherwise is set to 0</param>
            <returns>IntPtr.Zero if the payload belonging to the gui is non existant.  Returns pointer to the payload if it does and sets sizeofpayload</returns>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.EnumeratePayloads">
            <summary>
            TODO: Wrap routine https://github.com/microsoft/Detours/wiki/DetourBinaryEnumeratePayloads
            </summary>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.PayloadToArray(System.IntPtr,System.UInt32)">
            <summary>
            TODO: Conventent way to put the payload found by <see cref="M:InsightSheath.Detours.DetourBinary.FindPayload(System.Guid,System.UInt32@)"/>
            </summary>
            <param name="PayloadPtr"></param>
            <param name="SizeOFPayload"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.ResetImports">
            <summary>
            Reset changes made via DetourBinaryImports/ect... 
            </summary>
            <returns>True if it worked and false if not.</returns>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.EditImports(System.IntPtr,InsightSheath.Detours.DetourBinary.BinaryByWayscallback,InsightSheath.Detours.DetourBinary.BinaryFileCallback,InsightSheath.Detours.DetourBinary.BinarySymbolCallback,InsightSheath.Detours.DetourBinary.BinaryFinalCallback)">
            <summary>
            Enumerate the import tample and receive callbacks for each option.  
            </summary>
            <param name="Context">This is raw value that is passed bytween your code and Insight's Native DLL. It's the size of a pointer..</param>
            <param name="pfByway">This called once before each import DLL in the target</param>
            <param name="FpfFile">This is called once for each import DLL's name in the target</param>
            <param name="pfSymbol">This is called once for each symbol imported from each file in the target</param>
            <param name="pfFinal">This is called once the enumartion is finished if there were no errors.</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.GetInputs_filecallback(System.IntPtr,System.String,System.String,System.IntPtr)">
            <summary>
            callback that receives the routine name for <see cref="M:InsightSheath.Detours.DetourBinary.GetImports(System.Boolean,System.Boolean)"/>. Just sets <see cref="F:InsightSheath.Detours.DetourBinary.GetImportsCurrentKey"/> to the passed import library name.
            </summary>
            <param name="Context"></param>
            <param name="originalFile"></param>
            <param name="currentFile"></param>
            <param name="newfile"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.GetInputs_symbolcallback(System.IntPtr,System.UInt64,System.UInt64,System.UIntPtr,System.String,System.String,System.IntPtr)">
            <summary>
            callback that receives the routine name for <see cref="M:InsightSheath.Detours.DetourBinary.GetImports(System.Boolean,System.Boolean)"/>.  Checks if the list we're building has a key of <see cref="F:InsightSheath.Detours.DetourBinary.GetImportsCurrentKey"/> , creates it if not and adds the passed the argument CurrentSymbol to the list in that key slot
            </summary>
            <param name="Context"></param>
            <param name="original_ordinal"></param>
            <param name="current_ordinal"></param>
            <param name="DesiredOrginal"></param>
            <param name="OrigSymbol"></param>
            <param name="CurrentSymbol"></param>
            <param name="SymbolToUse"></param>
            <returns></returns>
        </member>
        <member name="F:InsightSheath.Detours.DetourBinary.GetImportsCurrentKey">
            <summary>
            this gets set to what eventual is a key in the <see cref="F:InsightSheath.Detours.DetourBinary.ImportList"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Detours.DetourBinary.ImportList">
            <summary>
            This is used to build the list generated by <see cref="M:InsightSheath.Detours.DetourBinary.GetImports(System.Boolean,System.Boolean)"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Detours.DetourBinary.GetInputsLock">
            <summary>
            used to prevent corruting in the list we are building should multiple threads attempt to call
            </summary>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.GetImports(System.Boolean,System.Boolean)">
            <summary>
            Collect the Import table and optionally also load the import table to DLLS you import.
            </summary>
            <param name="FollowDependants"></param>
            <param name="SkipDups">If set then import libraries of name X that export a routine named Y are treated as identicle.</param>
            <returns>Returns a dictionary list lists. Key is import library (ex kernel32.dll). List is the list of imports presented by the callback.  They should be in ordinal order.  You're free to sort as you see fit however.</returns>   
            <remarks>With how the routine works, (i.e. private variable contained in the life of the class), this routine locks a handle to prevent multiple threads from calling this at the same time.</remarks>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.Dispose(System.Boolean)">
            <summary>
            Release the handle and DetourBinary handle for this file.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.Finalize">
            <summary>
            GC cleanup disposing of resources.
            </summary>
        </member>
        <member name="M:InsightSheath.Detours.DetourBinary.Dispose">
            <summary>
            dispose of this DetourBinary based object's resources.
            </summary>
        </member>
        <member name="T:InsightSheath.MemoryNative">
            <summary>
            Read and write to native memory via Peek and Poke routines.
            </summary>
            <remarks>IMPORTANT! This is accessing unmanaged memory outside of C#'s GC. The InsightAPI.dll does deal with given  and receiving native pointers ect and there will be times you'll need to do that with a separate process. </remarks>
        </member>
        <member name="M:InsightSheath.MemoryNative.Peek4(System.IntPtr)">
            <summary>
            Read a 4 byte value from unmanaged memory
            </summary>
            <param name="Target">non null pointer to location to read from</param>
            <returns>return contains of passed memory location</returns>
        </member>
        <member name="M:InsightSheath.MemoryNative.Poke4(System.IntPtr,System.UInt32)">
            <summary>
            Write a 4 byte value to the memory location passed
            </summary>
            <param name="Target">non null pointer to location to write to </param>
            <param name="value">4 byte value to write</param>
        </member>
        <member name="M:InsightSheath.MemoryNative.SetDebugEventCallbackResponse(System.IntPtr,InsightSheath.Debugging.Process.DebugContState)">
            <summary>
            For the <see cref="T:InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine"/>.  Use the <see cref="T:System.IntPtr"/> passed containing the location of where to write the continue state.
            </summary>
            <param name="ContState">Pointer received as the ContState value in <seealso cref="T:InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine"/> callback</param>
            <param name="Response">Indicate what your debugger did to handle it or not <see cref="T:InsightSheath.Debugging.Process.DebugContState"/></param>
            <remarks>This is a thin wrapper round <see cref="M:InsightSheath.MemoryNative.Poke4(System.IntPtr,System.UInt32)"/></remarks> to be used in the <see cref="T:InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine"/> so one does not need to typecast and use the unchecked keyboard
        </member>
        <member name="M:InsightSheath.MemoryNative.Peek8(System.IntPtr)">
            <summary>
            read an 8 byte value from memory
            </summary>
            <param name="Target">non null local target pointer to read from</param>
            <returns>Returns memory contents OR 0 if you pass a null target</returns>
        </member>
        <member name="M:InsightSheath.MemoryNative.Poke8(System.IntPtr,System.UInt64)">
            <summary>
             write a 8 byte value to memory
            </summary>
            <param name="Target">non null pointer to location to write to </param>
            <param name="val">8 byte value to right</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.MemoryNative.RemotePoke4(System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            Write a 4 byte value to the process you indicate.
            </summary>
            <param name="ProcessHandle">  Native Handle to a process with at least  PROCESS_VM_WRITE and maybe PROCESS_VM_OPERATION </param>
            <param name="val">value to write</param>
            <param name="RemoteLocation">Virtual Memory in the remote process to write too. This is not a pointer to memory in your process.</param>
            <returns>returns true it if worked and false if it did not</returns>
        </member>
        <member name="M:InsightSheath.MemoryNative.RemotePoke8(System.IntPtr,System.UInt64,System.IntPtr)">
            <summary>
            Write an 8 byte value to a process you specify
            </summary>
            <param name="ProcessHandle">Handle to the target</param>
            <param name="val">value to write</param>
            <param name="RemoteLocation">local in virtual memory of the target to write too</param>
            <returns>true if it worked and false if it did not</returns>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist">
            <summary>
            Implements an event debugger system for processing events. You will need to link a way to call <see cref="M:InsightSheath.Misc.EventDebugAssist.FireEvents(InsightSheath.Debugging.DebugEvent)"/> in order to actually make to the thing work
            </summary>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.CreateProcessEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.CreateThreadEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.ExceptionDebugEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.ExitProcessDebugEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.ExitThreadDebugEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.LoadDllDebugEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.OutputDebugStringCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.RipCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.UnloadDebugEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.EventDebugAssist.GeneralDebugEventCallback">
            <summary>
            
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.CreateProcessEvent">
            <summary>
            Subscribe to get CreateProcess Events 
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.CreateThreadEvent">
            <summary>
            Subsrubte to get CreateThread 
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.ExceptionEvent">
            <summary>
            Subscribe to get Exceptions
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.ExitProcessEvent">
            <summary>
            Subscribe to get ExitProess
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.ExitThreadEvent">
            <summary>
            Subscvribe to get ExitThread
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.LoadDllEvent">
            <summary>
            Subscribe to load Dll events
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.OutputDebugStringEvent">
            <summary>
            Subsvrube to get output debug strings
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.RipEvent">
            <summary>
            
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.UnloadDllEvent">
            <summary>
            Subscvribe to get RIp events
            </summary>
        </member>
        <member name="E:InsightSheath.Misc.EventDebugAssist.GeneralEvent">
            <summary>
            Subscribe to catch all the other invents. IMPORTANT!.  This is called before the others!
            </summary>
        </member>
        <member name="M:InsightSheath.Misc.EventDebugAssist.FireEvents(InsightSheath.Debugging.DebugEvent)">
            <summary>
            Your code will need to actual call this to trigger getting events.
            </summary>
            <param name="Ptr"></param>
        </member>
        <member name="T:InsightSheath.Misc.ReferenceCounter">
            <summary>
            Used by the <see cref="!:ReferenceCounterNativeStaticContainer"/> to track and change a reference.
            This is primary used by the <see cref="!:DebugEvent"/> class collection as we're handing out
            Multiple References to the same Native Pointer like candy and need to take steps to prevent users
            of the library from prematuring freeing the same sheath.
            
            Why?
                GC knows DebugEvent, DebugEventCreateProcess both end up using NativecStaticContainer
                GC does NOT know of the Native Side being a block of memory for a DEBUG_EVENT struct.
                GC does not know that DebugEvent hands out DebugEventCreateProcesses that point to the same NativePointer
                
                Got the above? Consider this example
                      GC frees DebugEventCreateProcess, memory is invalided on the nativeside
                      GC has not freed DebugEvent but memory thsi class points too is now invalid
                        DebugEvent breaks.
                
            </summary>
        </member>
        <member name="M:InsightSheath.Misc.ReferenceCounter.AddRef">
            <summary>
            Inclease the reference counter for this class.  Call this when sucessfully creating a class instance that points to the same unmanaged memory block.
            </summary>
            <returns>Returns number of live instances after increasing value</returns>
        </member>
        <member name="M:InsightSheath.Misc.ReferenceCounter.DecRef">
            <summary>
            Decrease the reference counter for this class.   Call this during your disposal() event and actually free the unmanaged memory only when the return value is 0.  
            </summary>
            <returns>Returns remaining vlaues.</returns>
        </member>
        <member name="T:InsightSheath.NativeImports.DebugEventNative">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Debugging.DebugEvent"/> class
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.DebugEventNative.DebugEvent_GetProcessID(System.IntPtr)">
            <summary>
            Return the Process ID contained within the Native DEBUG_EVENT struct
            </summary>
            <param name="LPDebugEvent"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.DebugEventNative.DebugEvent_GetThreadID(System.IntPtr)">
            <summary>
            Return the Thread ID contained within the Native DEBUG_EVENT struct
            </summary>
            <param name="LPDebugEvent"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.DebugEventNative.DebugEvent_GetEventType(System.IntPtr)">
            <summary>
            Return the Event Tuype Contrained within the DEBUG_EVENT struct
            </summary>
            <param name="LPDebugEvent"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.DebugEventNative.DebugEvent_RipGetErrorType(System.IntPtr)">
            <summary>
            If the Event type is a RIP_EVENT ( <see cref="M:InsightSheath.NativeImports.DebugEventNative.DebugEvent_GetEventType(System.IntPtr)"/> returns <see cref="F:InsightSheath.Debugging.DebugEventType.RipEvent"/>, returns the Type of Rip Event
            </summary>
            <param name="LPDebugEvent"></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.NativeImports.InternalInsightMemory">
            <summary>
            Internal Class. Contains the routines imported from InsightAPI.DLL for use in the <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> class. Not really planned to be accessible outside of this project.
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.MakeInstance">
            <summary>
            Imports "InsightMemory_MakeInstance" from InsightAPI.DLL which creates the native class that <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wraps.
            </summary>
            <returns>Returns a pointer to the unmanaged class that <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/>  wraps null</returns>
            <remarks>You're likely going to get an out of memory C/C++ exception if this actually does not have enough to allocate. C++ users, this is a raw pointed to a C++ class made via the new operator.</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.DupInstance(System.IntPtr)">
            <summary>
            Imports "InsightMemory_DupInstance" from InsightAPI.DLL which creates the a copy of the <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> class you specified via pointer.
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>Returns a pointer to the new instance of the class or null</returns>    
            <remarks>You're likely going to get an out of memory C/C++ exception if this actually does not have enough to allocate. C++ users, this is a raw pointed to a C++ class made via the new operator.</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.KillInstance(System.IntPtr)">
            <summary>
            Imports "InsightMemory_KillInstance" from InsightAPI.dll which cleans up the native class that <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wraps.
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>true if the call worked and false if it did not</returns>
            <remarks>C++ usages, this is calling delete against the pointer you indicate.  Ideally it should a pointer returned via <see cref="M:InsightSheath.NativeImports.InternalInsightMemory.MakeInstance"/> or <see cref="M:InsightSheath.NativeImports.InternalInsightMemory.DupInstance(System.IntPtr)"/> </remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.UpdateMemoryStats(System.IntPtr)">
            <summary>
            Imports "InsightMemory_UpdateMemoryStats" from InsightAPI.dll which manually refreshes the native side of this class's info
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>TRUE if it did work and FALSE if it did not</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetPageFaultCount(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetPageFaultCount" which may trigger a refresh of the native class data and then returns the relevant memory requested (PageFaultCount)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the number of page faults memory stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetPeakWorkingSetSize(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetPeakWorkingSetSize" which may trigger a refresh of the native class data and then returns the relevant memory requested (PeakWorkingSetSize)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the peaked working set size member stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetWorkingSetSize(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetWorkingSetSize" which may trigger a refresh of the native class data and then returns the relevant memory requested (WorkingSetSize)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the current working set size member stored within the native class (and zeros 0 on error) </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:InsightSheath.NativeImports.InternalInsightMemory.GetQuotaPeakPagedPoolUsage(System.IntPtr)" -->
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetQuotaPagePoolUsage(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetQuotaPagePoolUsage" which may trigger a refresh of the native class data and then returns the relevant memory requested (QuotaPagedPoolUsage)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the current page usage member stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetPeakNonPagePoolUsage(System.IntPtr)">
            <summary>
            Imports "GetPeakNonPagePoolUsage" which may trigger a refresh of the native class data and then returns the relevant memory requested (PeakNonPagedPoolUsage)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the peak nonpaged pool usage member stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetQuotaNonPagedPoolUsage(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetQuotaNonPagedPoolUsage" which may trigger a refresh of the native class data and then returns the relevant memory requested (QuotaNonPagedPoolUsage)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the current nonpaged pool usage member stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetPageFileUsage(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetQuotaNonPagedPoolUsage" which may trigger a refresh of the native class data and then returns the relevant memory requested (PageFileUsage)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the current "Page File"/Commit Charge member stored within the native class (and zeros 0 on error).  </returns>
            <remarks>Note that In Windows versions before Windows 7 and Windows Server 2012 R2+, MSDN documentation says to use PrivateUsage member instead aka <see cref="M:InsightSheath.NativeImports.InternalInsightMemory.GetPrivateUsage(System.IntPtr)"/></remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetPeakPageFileUsage(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetPeakPageFileUsage" which may trigger a refresh of the native class data and then returns the relevant memory requested (PeakPageFileUsage)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the peak paged file usage member stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.GetPrivateUsage(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetPrivateUsage" which may trigger a refresh of the native class data and then returns the relevant memory requested (PrivateUsage)
            </summary>
            <param name="That">Unmanaged pointer to an instance of an <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wrapped class</param>
            <returns>This returns the Private Memory member (Commit Charge) stored within the native class (and zeros 0 on error) </returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightMemory.InsightMemory_GetMemoryStatsBulk(System.IntPtr)">
            <summary>
            Imports "InsightMemory_GetMemoryStatsBulk" which may rigger a refresh of the native class data and then returns a pointer to a "PROCESS_MEMORY_COUNTERS_EX" structure
            </summary>
            <param name="That"></param>
            <returns>This returns a pointer specifically a <see href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex"/> PROCESS_MEMORY_COUNTERS_EX. It does not and should not need to be freed until you're done with the class as is part of the class <see cref="T:InsightSheath.Debugging.Process.InsightMemory"/> wraps directly.</returns>
        </member>
        <member name="T:InsightSheath.NativeImports.InsightProcessInternal">
            <summary>
            Internal Class.  Contains the routines imported from InsightAPI.DLL for use in the <see cref="T:InsightSheath.Debugging.Process.InsightProcess"/> class
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_GetDetourListSize(System.IntPtr)">
            <summary>
            Wrapper for calling InsightAPI's InsightProcess_GetDetourListSize which calls InsightProcess::GetDetourListSize().  
            </summary>
            <param name="that">Native pointer that points to an instance of the class aka 'this'</param>
            <returns>Returns the number of entries in the detour DLL list that the spawned process will be forced to load</returns>
            <remarks>The reason for ulong is that's the size of the x64 size_t in C++ land. x86 size is uint sized. The API/sheath use the 64-bit size so the source can match.</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.CreateInsightProcessNativeClass">
            <summary>
            Imports InsightProcess_MakeInstance() from InsightApi.Dll
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.DuplicateInsightProcessNativeClass(System.IntPtr)">
            <summary>
            Invokes copy constructor via InsightProcess_DupInstance from InsightAPI.DLL
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_KillInstance(System.IntPtr)">
            <summary>
            Wrap the InsightProcess_KillInstance routine
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetProcessName(System.IntPtr,System.String)">
            <summary>
            Wrap the InsightProcess_SetProcessName routine
            </summary>
            <param name="that"></param>
            <param name="NewName"></param>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_GetProcessName(System.IntPtr)">
            <summary>
            Wrap the InsightProcess_GetProcessName 
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_Spawn(System.IntPtr)">
            <summary>
            Wraps the InsightProcess_SpawnProcess method
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetProcessArgument(System.IntPtr,System.String)">
            <summary>
            Wrap the InsightProcess_SetProcessArgument routine
            </summary>
            <param name="that"></param>
            <param name="NewName"></param>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_GetProcessArgument(System.IntPtr)">
            <summary>
            Wrap the InsightProcess_GetProcessArgument
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetCreationFlags(System.IntPtr,System.UInt32)">
            <summary>
            Wraps the InsightProcess_SetCreationFlags command. 
            </summary>
            <param name="That"></param>
            <param name="NewFlags">See CreateProcessW() on MSDN for more info.</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.PsProcessInformation_SetCreationFlagDebug(System.IntPtr,System.UInt32)">
            <summary>
            Wraps the InsightProcess_SetCreationFlagDebug command. 
            </summary>
            <param name="That"></param>
            <param name="NewFlags">See CreateProcessW() on MSDN for more info.</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetCreationFlagDebugOnlyThis(System.IntPtr,System.UInt32)">
            <summary>
            Wraps the InsightProcess_SetCreationFlagDebugOnlyThis command. 
            </summary>
            <param name="That"></param>
            <param name="NewFlags">See CreateProcessW() on MSDN for more info.</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetCreationFlagDebugSuspended(System.IntPtr,System.UInt32)">
            <summary>
            Wraps the InsightProcess_SetCreationFlagDebugSuspended command. 
            </summary>
            <param name="That"></param>
            <param name="NewFlags">See CreateProcessW() on MSDN for more info.</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetCreationFlagDebugOnlyThisSuspended(System.IntPtr,System.UInt32)">
            <summary>
            Wraps the InsightProcess_SetCreationFlags command. 
            </summary>
            <param name="That"></param>
            <param name="NewFlags">See CreateProcessW() on MSDN for more info.</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_GetCreationFlags(System.IntPtr)">
            <summary>
            Wrap InsightProcess_GetCreationFlags
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetWorkingDirectory(System.IntPtr,System.String)">
            <summary>
            Wrap the InsightProcess_SetProcessArgument routine
            </summary>
            <param name="that"></param>
            <param name="NewName"></param>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.PsProcessInformation_GetWorkingDirectory(System.IntPtr)">
            <summary>
            Wrap the InsightProcess_GetProcessArgument
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.InsightProcessInternal.InsightProcess_SetInheritDefaultEnviroment(System.IntPtr,System.Boolean)">
            <summary>
            Specific if processes spawned with the context class want to inherit the parent's environment or not.
            </summary>
            <param name="That"></param>
            <param name="WantDefaultAlso"></param>
        </member>
        <member name="T:InsightSheath.NativeImports.DebugHelpApiVersionStructInternal">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct"/>
            </summary>
        </member>
        <member name="T:InsightSheath.NativeImports.InternalInsightHunter">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Debugging.SymbolEngine.InsightHunter"/> class
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalInsightHunter.Insight_GetImageHelpVersionData(System.IntPtr)">
            <summary>
            IntPtr is an API_VERSION struct that's part of the InsightHunter class itself.
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.NativeImports.SymbolInfoInternal">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Debugging.SymbolEngine.SymbolInfo"/> class
            </summary>
        </member>
        <member name="T:InsightSheath.NativeImports.ThreadConext_Arguments">
            <summary>
            Values to indicate to the native routine if we're passing a handle or a thread it to use.
            </summary>
        </member>
        <member name="T:InsightSheath.NativeImports.ThreadContextInternal">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Debugging.Thread.ThreadContext"/> class
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_SetTheadDescriptionW(System.IntPtr,System.String)">
            <summary>
            Import for the C level wrapper that calls ThreadContext's SetThreadDescriptionW
            </summary>
            <param name="That">The C++ this pointer</param>
            <param name="NewDescription">New Description for the thread</param>
            <returns>True if it worked and false if it did not.</returns>
            <remarks>Use of this or <see cref="!:ThreadContext_GetTheadDescriptionW(IntPtr, string)"/> will trigger LoadLibrary (MSDN) calls on the first use</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_GetThreadDescriptionW(System.IntPtr)">
            <summary>
            Gets the Current Thread Description (if defined and system supported).
            </summary>
            <param name="that">Pointer to the native instance of <see cref="T:InsightSheath.Debugging.Thread.ThreadContext"/> </param>
            <returns>Returns a string if defined or null if unsupported/not defined. </returns>
            <remarks>Use of this or <see cref="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_SetTheadDescriptionW(System.IntPtr,System.String)"/> will trigger LoadLibrary (MSDN) calls on the first use</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_CreateInstance(System.UInt64,System.UInt32)">
            <summary>
            Create a new instance of the  native side <see cref="T:InsightSheath.Debugging.Thread.ThreadContext"/> class. Returns a Native pointer that can be passed to <see cref="M:InsightSheath.Debugging.Thread.ThreadContext.#ctor(System.IntPtr)"/> to get a managed wrapper for that class
            </summary>
            <param name="HandleOrThreadId">4 byte value that can be a thread id or a handle</param>
            <param name="Flags">0 = HandleOrThreadId is a Handle to the thread. It's unneeded afterwards. Non-zero means argument is a thread id. </param>
            <returns>Returns a pointer to a C++ native side that implements this class on OK. and <see cref="F:System.IntPtr.Zero"/> on error. </returns>
            <remarks>If a Thread ID, the SECURITY_DESCRIPTOR must allow these access rights (THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION)</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_KillInstance(System.IntPtr)">
            <summary>
            Dispose of the C++ side of <see cref="T:InsightSheath.Debugging.Thread.ThreadContext"/> class. Any pointer to this class is worthless after calling this. 
            </summary>
            <param name="That">Use the <see cref="!:NativeStaticContainer.NativePointer"/></param> belonging to a ThreadClass
            <returns>Returns true if it worked and false if not. </returns>
            <remarks>Passing <see cref="F:System.IntPtr.Zero"/> is simply dropped</remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_GetPriority(System.IntPtr)">
            <summary>
            Call the Native Side's routine to get the Priority of the thread. 
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.ThreadContextInternal.ThreadContext_GetTargetThreadId(System.IntPtr)">
            <summary>
            C Level wrapper to call the C++ class part of ThreadContext to get the thread if this is paired with.
            </summary>
            <param name="That"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.GetModuleNameViaHandleInternal(System.IntPtr,System.IntPtr)">
            <summary>
            Retrieve a potentially null pointer containing a Unicode string containing the name of the hmodule that belongs to process handle. You will need to free it by using <see cref="M:InsightSheath.NativeImports.NativeMethods.FreeModuleNameViaHandleInternal(System.IntPtr)"/>
            </summary>
            <param name="ProcessHandle">Win32 Process Handle to use. It must have at least PROCESS_QUERY_INFROMATION or PROCESS_QUERY_LIMITED_INFORMATION access right.</param>
            <param name="ModuleHandle">HMODULe in question</param>
            <returns>returns an Unicode string containing the name of the module if the call worked and IntPtr.Zero if it failed</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.FreeModuleNameViaHandleInternal(System.IntPtr)">
            <summary>
            Free a memory pointer returned by <see cref="M:InsightSheath.NativeImports.NativeMethods.GetModuleNameViaHandleInternal(System.IntPtr,System.IntPtr)"/>
            </summary>
            <param name="NativeStringPtr">pointer in question. null is ignored.</param>
            <returns>Returns true if the call worked and false if it failed.</returns>
            <remarks>This imports UtilFreeModuleNameViaHandle() which itself points to a routine called RemoteRead_SimpleFree() which itself is a wrapper to free().  You are free to directly just call RemoteRead_SimpleFree() but if the implemention changes, UtilFreeModuleNameViaHandle may not always be a forwarder to RemoteRead_SimpleFree  </remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.GetFileNameViaHandle(System.IntPtr)">
            <summary>
            Get a Unicode string containing the name of the file/device pointed to by FileHandle. Caller will need to free it.
            </summary>
            <param name="FileHandle">Win32 Handle in question</param>
            <returns>Returns IntPtr containing a null terminated Unicode string or null if it failed.</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.FreeFileNameViaHandleInternal(System.IntPtr)">
            <summary>
            Free a memory pointer returned by <see cref="M:InsightSheath.NativeImports.NativeMethods.GetFileNameViaHandle(System.IntPtr)"/>
            </summary>
            <param name="NativeStringPtr">pointer in question. null is ignored.</param>
            <returns>Returns true if the call worked and false if it failed.</returns>
            <remarks>This imports UtilFreeFileNameViaHandle() which itself points to a routine called RemoteRead_SimpleFree() which itself is a wrapper to free().  You are free to directly just call RemoteRead_SimpleFree() but if the implemention changes, UtilFreeFileNameViaHandle may not always be a forwarder to RemoteRead_SimpleFree  </remarks>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.DuplicateHandleIntoTarget(System.IntPtr,System.UInt32,System.Boolean,System.IntPtr,System.Boolean)">
            <summary>
            Duplicate the handle into the passed process. Handle is assumed to be from the current process. Will still need a way to get to remote process.
            </summary>
            <param name="CurrentHandle"></param>
            <param name="Access"></param>
            <param name="CopyAccess"></param>
            <param name="TargetProcess"></param>
            <param name="Inherit"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.OpenProcessForMemoryAccess(System.UInt32)">
            <summary>
            Short hand for asking for a native process handle that PROCESS_VM_READ | PROCESS_VM_WRITE access
            </summary>
            <param name="ProcessID">id of the target process to open.  You can get this with <see cref="!:InsightSheath.Wrappers.DebugEventCreateProcessInfo"/> event handling among other things</param>
            <returns>Returns Native handle with PROCESS_VM_READ + PROCESS_VM_WRITE access or null if you can't open it.</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.OpenProcessNow(System.UInt32)">
            <summary>
            Open Process ALL_ACCESS. Not intended for Release builds and always will return 0 if using an InsightApi build in a release configuration
            </summary>
            <param name="ProcessID"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.OpenProcessForDuplicatingHandle(System.UInt32)">
            <summary>
            Shorthand for asking for a native process handle that has PROCESS_DUP_HANDLE AND VM_PROCESS_WRITE (for WriteProcessMemory)
            </summary>
            <param name="ProcessID"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.SimpleFree(System.IntPtr)">
            <summary>
            Free a memory chuck that was allocated by the native DLL with a single call. It is recommended to NOT call this unless you know the underlying
            block or structure was allocated via C's malloc(). If multiple allocations happen, you'll be leaking memory by calling this.
            </summary>
            <param name="NativeStringPtr"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.NativeMethods.CloseHandle(System.IntPtr)">
            <summary>
            Wrapper for Kernel32.DLL's CloseHandle for user convenience 
            </summary>
            <param name="Handle"></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.NativeImports.InternalDetourBinary">
            <summary>
            This class imports the various native routines (usualy from InsightAPI.dll) that DetourBinary and StaticBinary require
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.InternalDetourBinary.DetourBinaryWrite(System.IntPtr,System.IntPtr)">
            <summary>
            Write the changes made with this DetourBinary resource to the target. See also <see href="https://github.com/Microsoft/Detours/wiki/DetourBinaryWrite"/>
            </summary>
            <param name="DetourHandle">From a previously sucessfully call to <see cref="M:InsightSheath.NativeImports.InternalDetourBinary.DetourBinaryOpen(System.IntPtr)"/></param>
            <param name="FileHandle">Native file handle to write the changes too.</param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.NativeImports.InternalReasourceWalker">
            <summary>
            Imports the 
            </summary>
        </member>
        <member name="T:InsightSheath.NativeImports.MemoryNativeInternal">
            <summary>
            Internal Class.  Imports the Poke/Peek routines for both remote and local
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.MemoryNativeInternal.Peek4(System.IntPtr)">
            <summary>
            return a 4 DWORD value from a local unmanaged memory location
            </summary>
            <param name="NativePtr">Pointer to read from</param>
            <returns>contents of that location OR 0 if you pass <see cref="F:System.IntPtr.Zero"/> as the <see cref="!:NativePtr"/> value</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.MemoryNativeInternal.Poke4(System.IntPtr,System.UInt32)">
            <summary>
            Write a 4 byte DWORD value to an unmanaged local memory location
            </summary>
            <param name="NativePtr">Pointer to write to</param>
            <param name="NewValue">4 byte value to write</param>
            <returns>true if the value was set and false if it was not (or if <see cref="!:NativePtr"/> equals 0)</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.MemoryNativeInternal.Peek8(System.IntPtr)">
            <summary>
            return an 8 byte QWORD value from a local unmanaged memory location
            </summary>
            <param name="NativePtr">Pointer to read from</param>
            <returns>contents of that location OR 0 if you pass <see cref="F:System.IntPtr.Zero"/> as the <see cref="!:NativePtr"/> value</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.MemoryNativeInternal.Poke8(System.IntPtr,System.UInt64)">
            <summary>
            write a 8 byte QWORD value to a local unmanaged memory location 
            </summary>
            <param name="NativePtr">Pointer to write to</param>
            <returns>true if the value was set and false if it was not (or if <see cref="!:NativePtr"/> equals 0)</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.MemoryNativeInternal.RemotePoke8(System.IntPtr,System.UInt64,System.IntPtr)">
            <summary>
            Write an 8 byte value to a process you specify
            </summary>
            <param name="ProcessHandle">Handle to the target</param>
            <param name="value">value to write</param>
            <param name="remote_location">local in virtual memory of the target to write too</param>
            <returns>true if it worked and false if it did not</returns>
        </member>
        <member name="M:InsightSheath.NativeImports.MemoryNativeInternal.RemotePoke4(System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            Write a 4 byte value to a process you specify
            </summary>
            <param name="ProcessHandle">Handle to the target</param>
            <param name="value">value to write</param>
            <param name="remote_location">local in virtual memory of the target to write too</param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.NativeImports.RemoteStructureInternal">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Win32Struct.Remote.RemoteStructure"/> class exports
            </summary>
        </member>
        <member name="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteReadUnicodeString(System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            Take case as the back end will promote x86 Unicode string to x64 bit to make sure we don't accidentally cut off a pointer.
            </summary>
            <param name="ProcessHandle">Process to read from</param>
            <param name="RemoteLocation">Location in the target to read from/</param>
            <param name="TargetIs32Bit">Indicate if we're reading from a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/></param>
            <returns>Return local allocated Memory containing an <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteFreeUnicodeString(System.IntPtr,System.Boolean)">
            <summary>
            We uses too care if the pointer was a unicode32-bit or unicode
            </summary>
            <param name="RemoteLocation"></param>
            <param name="TargetIs32Bit"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteFreeUnicodeString(System.IntPtr)">
            <summary>
            Calling <see cref="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteFreeUnicodeString(System.IntPtr,System.Boolean)"/> with the correct parameter.
            </summary>
            <param name="RemoteLocation"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteReadStringInternal(System.IntPtr,System.IntPtr,System.UInt64)">
            <summary>
            Read a string from a remote process
            </summary>
            <param name="ProcessHandle">Handle for the remote process. It should be open for at least PROCESS_VM_READ rights.</param>
            <param name="RemoteLocation">virtual memory in the remote process to read from</param>
            <param name="char_count">how many chars in the string to read? </param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteReadDebugStringInternal(System.IntPtr,System.IntPtr)">
            <summary>
            WWraps RemoteReadDebugString.  Return value is a string that needs to be freed afterwares.
            </summary>
            <param name="ProcessHandle">Handle to the remote process. It should be open for at lead PROCESS_VM_READ rights</param>
            <param name="DebugEventPtr"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteFreeDebugStringInternal(System.IntPtr)" -->
        <member name="M:InsightSheath.NativeImports.RemoteStructureInternal.RemoteReadPointer(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            Read a pointer (4 or 8 bytes) from the target process's virtual memory location/
            </summary>
            <param name="TargetProcess">0 = self.  </param>
            <param name="TargetLocation">Virtual memory to read from</param>
            <param name="PointerSize">must be 4 or 8 otherwise call will be rejected.</param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.NativeImports.InternalStartupInfoExW">
            <summary>
            Internal Class. This imports the routines used in <see cref="T:InsightSheath.Win32Struct.StartupInfoExW"/> class.
            </summary>
        </member>
        <member name="T:InsightSheath.Resource.ResourceWalker">
            <summary>
            Primarily intended to be what <see cref="T:InsightSheath.Resource.ResourceWalker"/> gives to let the user load a specific resource into NativeLand.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.ReturnValue">
            <summary>
            Get a pointer to what's going to be returned from this call to CheckRemoteDebuggerPresent
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.Process">
            <summary>
            Get the Handle to the process that the debugged app is asking about.
            </summary>
        </member>
        <member name="P:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.OutputBool">
            <summary>
            Get a pointer to the bool that will contain the results. Same as <see cref="!:ForceHandlePtr"/>
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.AntiDebuggerReaderExtensions">
            <summary>
            This class includes code to read exceptions generated via the AntiDebugger telemetry.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AntiDebuggerReaderExtensions.FixedExceptionCode">
            <summary>
            Fixed exception codes should be synched between the Telemetry C/c++ source and there respective reader. The value matters not. This is AntiDebugger Telmetry Reader
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.AntiDebuggerReaderExtentionCheckers">
            <summary>
            This class includes extentions to check if the exception in the <see cref="T:InsightSheath.Debugging.DebugEvent"/> is the correct type
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.GeneralTelemetry">
            <summary>
            holds some common defines between the included telemetry projects.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemetry.ExceptionSubType">
            <summary>
            The exception that the telemetry generated should use the first arg to indicate what routine it has packeged for the debugger
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemetry.LastError_Ptr">
            <summary>
            The exception that the telemetry generated should also place a DWORD* int this location to let the debugger overwrite the last error (or for certrain nt functions, the return value)
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.GeneralTelemtryHelperStruct">
            <summary>
            General common values/code between the telemetry reader code.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.Type">
            <summary>
            Depends on what <see cref="!:DebugEvent.IsProcess32Bit"/> returns. Intended for determining pointer size only. If that's true, Value is <see cref="F:InsightSheath.MachineType.MachineI386"/> otherwise value is <see cref="F:InsightSheath.MachineType.MachineAmd64"/>  i386 pointer sizes are 4 bytes long and Amd64 pointer sizes are 8 bytes.    This may not actually be the exact machine type as stored in the debugged process's physical PE/EXE file.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.ProcessId">
            <summary>
            Process that the exception originated from.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.ThreadId">
            <summary>
            Thread that the exception originated from.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.ForceHandlePtr">
            <summary>
            Pointer to the handle that is returned back to the target process after handling the exception.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.LastErrorPtr">
            <summary>
            Depending on Context of target detoured routine, may be an NTSTATUS return value or an actual last error pointer.
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle(System.IntPtr)">
            <summary>
            Duplicate the handle you provide into the process the exception was generated from and write it to the memory location specified by <see cref="!:ForceHandle"/> 
            </summary>
            <param name="ReplacementHandle"></param>
        </member>
        <member name="M:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle">
            <summary>
            Set the handle to the appropriate invalid handle value based on the <see cref="F:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.Type"/> value in this struct.
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle(System.UInt64)">
            <summary>
            Set the 64-bit handle value to something other than an <see cref="T:System.IntPtr"/> - for example <see cref="!:InvalidHandleValue64"/>
            </summary>
            <param name="HandleValue"></param>
        </member>
        <member name="M:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle(System.UInt32)">
            <summary>
            Set the 32-bit handle value to something other than an <see cref="T:System.IntPtr"/> - for example <see cref="!:InvalidHandleValue32"/>
            </summary>
            <param name="HandleValue"></param>
        </member>
        <member name="M:InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetLastErrorValue(System.UInt32)">
            <summary>
            Set the last error value that will be set by the detouring routine when returning control to the debugged process.
            </summary>
            <param name="NewValue"></param>
        </member>
        <member name="T:InsightSheath.Telemetry.LARGE_INTEGER">
            <summary>
            Large structure for getting LARGE_INTEGER structs into .Net Hands
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues.InvalidHandleValue32">
            <summary>
            If you desire to make the call from the x86 process to CreateFileA/W file fail, call <see cref="!:SetForceHandle"/> with this has a value
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues.InvalidHandleValue64">
            <summary>
            If you desire to make the call from the x64 process to CreateFileA/W file fail, call <see cref="!:SetForceHandle"/> with this has a value
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.NtCreationDisposition">
            <summary>
            From once again winnt.h for values.   <see href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.NtCreationDisposition.Supersede">
            <summary>
            IF File exists already, replace with this new file. If nonexistent, create it.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.NtCreationDisposition.Open">
            <summary>
            If file exists, open it. If it does not exist, fail the request.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.NtCreationDisposition.Create">
            <summary>
            If the file exists, fail request. If it does not exist, create the file.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.NtCreationDisposition.OpenIf">
            <summary>
            If the file exists open it. Otherwise create it.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.NtCreationDisposition.Overwrite">
            <summary>
            If the file exists, open and truncate it. Otherwise fail request.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.NtCreationDisposition.OverwriteIf">
            <summary>
            If the file exists, open and truncate it. If it does not exist, create it.
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.CreationDisposition">
            <summary>
            Action to be taken by CreateFileA/W
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CreationDisposition.CreateNew">
            <summary>
            Makes a new file if said target does not already exists
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CreationDisposition.CreateAlways">
            <summary>
            Creates fil and truncates if file exists already, createfilea/w sets last error if truncating
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CreationDisposition.OpenExisting">
            <summary>
            open an existing file / device and fail if not found
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CreationDisposition.OpenAlways">
            <summary>
            open existing file / - attempts to create if not found
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.CreationDisposition.TruncateExisting">
            <summary>
            Open a file and truncate it to zero bytes long
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.AccessMasks">
            <summary>
            from <see href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/262970b7-cd4a-41f4-8c4d-5a27f0092aaa"/>, 
            Windows SDK winnt.h and
            <see href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile"/>,
            these are the accessible flags 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.NoAccess">
            <summary>
            MSDN CreateFileA/W suggests meta data can be queried with opening for no access, hence the pair of these.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.MetaData">
            <summary>
            MSDN CreateFileA/W suggests meta data can be queried with opening for no access, hence the pair of these.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.Delete">
            <summary>
            NtOpenFile/NtCreateFile DELETE Value from "winnt.h"
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.ReadControl">
            <summary>
            NtOpenFile/NtCreateFile READ_CONTROL value from "winnt.h"
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileReadData">
            <summary>
            Windows NtOpen/NtCreateFile Sourced from winnt.h 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileListDirectory">
            <summary>
            Same as <see cref="F:InsightSheath.Telemetry.AccessMasks.FileReadData"/> in winnt.h
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileReadAttributes">
            <summary>
            Windows NtOpen/NtCreateFile.  Sourced from winnt.h.  FileAttribute flags, can be set/read.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileReadEa">
            <summary>
            Windows NtOpen/NtCreateFile Sourced from winnt.h 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileWriteData">
            <summary>
            Windows NtOpen/NtCreateFile Sourced from winnt.h 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileWriteAttributes">
            <summary>
            Windows NtOpen/NtCreateFile Sourced from winnt.h 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileWriteEa">
            <summary>
            Windows NtOpen/NtCreateFile Sourced from winnt.h 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileAppendData">
            <summary>
            Windows NtOpen/NtCreate file. From winnt.h. 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.WriteDac">
            <summary>
            Windows NtOpen/NtCreate file. From winnt.h. 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.WriteOwner">
            <summary>
            Windows NtOpen/NtCreate file. From winnt.h. 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.Synchronize">
            <summary>
            Windows NtOpen/NtCreate file. From winnt.h. 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileExecute">
            <summary>
            Windows NtOpen/NtCreate file. From winnt.h. 
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.FileTraverse">
            <summary>
            Same as FileExceute in winnt.h
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.GenericRead">
            <summary>
            GENERIC_READ / for read access
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.GenericWrite">
            <summary>
            GENERIC_WRITE / for write access
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.GenericExecute">
            <summary>
            GENERIC_EXECUTE / for execute access
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.AccessMasks.GenericAll">
            <summary>
            Generic all / for all possible access
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.ShareMasks">
            <summary>
            Share mode for CreateFileA/W
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.ShareMasks.NoShare">
            <summary>
            Don't wanna share
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.ShareMasks.ShareDelete">
            <summary>
            Share for delete requests only
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.ShareMasks.ShareRead">
            <summary>
            Share for read access only
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.ShareMasks.ShareWrite">
            <summary>
            Share for write access only
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryExceptionExtensionsCheckers.IsIoDeviceTelemetryException(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            Extension to <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/>, Returns if the contained exception <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/> is one generated via IoDeviceTelemetry DLL
            </summary>
            <param name="that">the this parameter or class to test</param>
            <returns> Returns if the contained exception <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/> is one generated via IoDeviceTelemetry DLL</returns>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryExceptionExtensionsCheckers.IsIoDeviceTelemetryException(InsightSheath.Debugging.DebugEvent)">
            <summary>
            Extension to <see cref="T:InsightSheath.Debugging.DebugEvent"/>, Returns if the contained exception <see cref="T:InsightSheath.Debugging.DebugEvent"/> is one generated via IoDeviceTelemetry DLL
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.FileOutHandle">
            <summary>
            Pointer to the first argument in NtCreateFile. That will indicate the out handle. For x64 bit processes this will be a 64-bit pointer. For x32 bit processes, this will be a 32-bit pointer.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.DesiredAccess">
            <summary>
            Will contain the passed Access Request flags for NtCreateFile.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.ObjectAttributes">
            <summary>
            May be null. If not null, this will be the Object Attributes read from that file.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.IoStatusBlock">
            <summary>
            for x64 debugged processes. This is a 64-bit pointer.  For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.AllocationSize">
            <summary>
            a LARGE_INTEGER struct.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.FileAttributes">
            <summary>
            The .NET file attributes for how the IO thing is being opened.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.ShareAccess">
            <summary>
            The .NET shared mode.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.CreationOptions">
            <summary>
            <see href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile"/> for specifics. TODO: Include enum containing those values.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.CreateDisposition">
            <summary>
            NtCreateFile specific flags.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.EaBuffer">
            <summary>
            for x64 debugged processes. This is a 64-bit pointer.  For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.EaSize">
            <summary>
            How many bytes is the EaBufffer.
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.SetReturnValue(System.UInt32)">
            <summary>
            NtCreateFile does not appear to set last error based on documentation. Here Last Error is the return value given back to the debugged process.
            </summary>
            <param name="ReturnValue"></param>
        </member>
        <member name="T:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile">
            <summary>
            This structure contains data from an exception generated via CreateFileA/W.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.FileName">
            <summary>
            Name of the file the debugged process is trying to open
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.DesiredAccess">
            <summary>
            Desired access for the target file
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.SharedMode">
            <summary>
            Will the debugged process try to open for sharing?
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.SecurityAttrib">
            <summary>
            Debugged process 's requested security attributes (IMPORTANT! this points to virtual memory in **THAT** process, not yours.)
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.CreateDisposition">
            <summary>
            Creation disposition
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.FlagsAndAttributes">
            <summary>
            Flags and attributes
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.TemplateFile">
            <summary>
            Template file that's usually (but NOT always) null.
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions">
            <summary>
            An Exception from the debug event struct that was generated via the IoException Telemetry DLL. This class should contain code to read exceptions generated from telemetry dll IoDeviceTelemetry
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.FixedExceptionCode">
            <summary>
            This class in question will deal with exceptions of this value from Debugged apps that have had IoDeviceTelemetry loaded into to them.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.CreateFile">
            <summary>
            Exception is from either a CreateFileA or CreateFileW call. Use the <see cref="M:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.GetCreateFileSettings(InsightSheath.Debugging.DebugEventExceptionInfo)"/> routine to retrieve formatted specifics
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.CreateFileTransacted">
            <summary>
            Exception is either from a CreateFIleTransactedA or CreateFIleTransactedW call.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.CloseHandle">
            <summary>
            Exception from a CloseHandle call. (Other than the one generated by the routine itself when debugging and closing invalid handle)
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.NtCreateFile">
            <summary>
            NTCreateFile sits below CreateFileA/W.  You'll likely see exceptions generated for both on the same target if debugged target is not calling the routine directly.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.NtOpenFile">
            <summary>
            TODO:: A Lower Level NtOpen file call.
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.GetIoDeviceExceptionType(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            Return the type of Alert this exception is raised from.  
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.GetNtCreateFileSettings(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            This retrieves data generated from an exception that matches the IoDevice exception type and was triggered from <see cref="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.NtCreateFile"/>
            </summary>
            <param name="that">A <see cref="T:InsightSheath.Debugging.DebugEvent"/> or <see cref="T:InsightSheath.Debugging.DebugEventExceptionInfo"/> that contains an exception generated from the telemetry dll for NtCreateFile</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.GetCreateFileSettings(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            Only valid if <see cref="M:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.GetIoDeviceExceptionType(InsightSheath.Debugging.DebugEventExceptionInfo)"/> returns an instead of <see cref="F:InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions.NotificationType.CreateFile"/> containing the arguments passed to CreateFileA or W.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.FileOutHandle">
            <summary>
            Pointer to the first argument in NtCreateFile. That will indicate the out handle. For x64 bit processes this will be a 64-bit pointer. For x32 bit processes, this will be a 32-bit pointer.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.DesiredAccess">
            <summary>
            Will contain the passed Access Request flags for NtCreateFile.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.ObjectAttributes">
            <summary>
            May be null. If not null, this will be the Object Attributes read from that file.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.IoStatusBlock">
            <summary>
            for x64 debugged processes. This is a 64-bit pointer.  For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.AllocationSize">
            <summary>
            a LARGE_INTEGER struct.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.FileAttributes">
            <summary>
            The .NET file attributes for how the IO thing is being opened.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.ShareAccess">
            <summary>
            The .NET shared mode.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.CreationOptions">
            <summary>
            <see href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile"/> for specifics. TODO: Include enum containing those values.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.CreateDisposition">
            <summary>
            NtCreateFile specific flags.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.EaBuffer">
            <summary>
            for x64 debugged processes. This is a 64-bit pointer.  For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.EaSize">
            <summary>
            How many bytes is the EaBufffer.
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile2.SetReturnValue(System.UInt32)">
            <summary>
            NtCreateFile does not appear to set last error based on documentation. Here Last Error is the return value given back to the debugged process.
            </summary>
            <param name="ReturnValue"></param>
        </member>
        <member name="T:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2">
            <summary>
            This structure contains data from an exception generated via CreateFileA/W.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.FileName">
            <summary>
            Name of the file the debugged process is trying to open
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.DesiredAccess">
            <summary>
            Desired access for the target file
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.SharedMode">
            <summary>
            Will the debugged process try to open for sharing?
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.SecurityAttrib">
            <summary>
            Debugged process 's requested security attributes (IMPORTANT! this points to virtual memory in **THAT** process, not yours.)
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.CreateDisposition">
            <summary>
            Creation disposition
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.FlagsAndAttributes">
            <summary>
            Flags and attributes
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile2.TemplateFile">
            <summary>
            Template file that's usually (but NOT always) null.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.TelemetryIoDeviceTracking.ExceptionCode">
            <summary>
            This static class registeres with <see cref="T:InsightSheath.Telemetry.Telemetry"/> to handle exceptions of this value.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.TelemetryIoDeviceTracking.SupportedNotificationType.CreateFile">
            <summary>
            Exception is from either a CreateFileA or CreateFileW call. Use the <see cref="!:GetCreateFileSettings"/> routine to retrieve formatted specifics
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.TelemetryIoDeviceTracking.SupportedNotificationType.CreateFileTransacted">
            <summary>
            Exception is either from a CreateFIleTransactedA or CreateFIleTransactedW call.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.TelemetryIoDeviceTracking.SupportedNotificationType.CloseHandle">
            <summary>
            Exception from a CloseHandle call. (Other than the one generated by the routine itself when debugging and closing invalid handle)
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.TelemetryIoDeviceTracking.SupportedNotificationType.NtCreateFile">
            <summary>
            NTCreateFile sits below CreateFileA/W.  You'll likely see exceptions generated for both on the same target if debugged target is not calling the routine directly.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.TelemetryIoDeviceTracking.SupportedNotificationType.NtOpenFile">
            <summary>
            TODO:: A Lower Level NtOpen file call.
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.TelemetryIoDeviceTracking.Touch">
            <summary>
            Trigger the static constructor
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.TelemetryIoDeviceTracking.Builder(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            examine the exception code, its arguments and return an instance of an approproate handler we support it. 
            </summary>
            <param name="Info"></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Telemetry.SpecializedExceptionHandler">
            <summary>
            Handle an Exception 
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.Telemetry">
            <summary>
            The built in Telemetry Dlls register routines here.
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.Telemetry.TelemetryEntery">
            <summary>
            this class is used to pair a handler factory with an exception code.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.Telemetry.InvalidHandleValue32">
            <summary>
            For Wow64/x86,  this is the INVALID_HANDLE_VALUE.
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.Telemetry.InvalidHandleValue64">
            <summary>
            For x64 Windows, this is the invalid handle value. 
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.Telemetry.HandlerFactoryCallback">
            <summary>
            if your delegate understands the exception, return a handler to handle it. Return null othersize
            </summary>
            <param name="Info"></param>
            <returns>Your routine should return null if it does not regonize the code. Otherwise it should return an instance to handler the code</returns>
        </member>
        <member name="M:InsightSheath.Telemetry.Telemetry.ClearHandler">
            <summary>
            Clear the *entire* container
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.Telemetry.ClearHandler(System.UInt32)">
            <summary>
            Remove the handler for this code 
            </summary>
            <param name="ExceptionCode"></param>
        </member>
        <member name="M:InsightSheath.Telemetry.Telemetry.GetHandlerFactory(System.UInt32)">
            <summary>
            return the delegate that makes an object to handle this code
            </summary>
            <param name="ExceptionCode"></param>
            <returns>null if there's no handler, otherwise a delegate </returns>
        </member>
        <member name="M:InsightSheath.Telemetry.Telemetry.ExceptionHasHandler(System.UInt32)">
            <summary>
            you might as well as just test for null on <see cref="M:InsightSheath.Telemetry.Telemetry.GetHandlerFactory(System.UInt32)"/>
            </summary>
            <param name="ExceptionCode"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Telemetry.Telemetry.MakeInstance(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            If a value exception event and there's a handler for it, call the handler that makes the object to handle it.
            </summary>
            <param name="Info"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Telemetry.Telemetry.AddHandler(System.UInt32,InsightSheath.Telemetry.Telemetry.HandlerFactoryCallback)">
            <summary>
            Register a new handler. The built in telemetries both do their own code.  If the ExceptionCode has a factory already, it's replace with this one.
            </summary>
            <param name="ExceptionCode"></param>
            <param name=""></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Telemetry.General.BuiltInTelemetryType">
            <summary>
            Enums for the various default telemetries
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.General.BuiltInTelemetryType.IoDeviceTracking">
            <summary>
            This one defaults with CreateFileA/W, NtCreateFileA/W
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.General.BuiltInTelemetryType.AntiDebugCounter">
            <summary>
            Deals with attempting to hide the debugger from the target
            </summary>
        </member>
        <member name="F:InsightSheath.Telemetry.General.BuiltInTelemetryType.ProcessLoader">
            <summary>
            Defauls with process and module loading done by the target.
            </summary>
        </member>
        <member name="T:InsightSheath.Telemetry.General.TelemetryLibraryUnmanagedRoutineHandler">
            <summary>
            Handle a single specific exception from a telemetry dll 
            </summary>
        </member>
        <member name="M:InsightSheath.Telemetry.General.TelemetryLibraryDispatchBase.IsSupported(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            Return true if your routine supports this exception or not/.
            </summary>
            <param name="Info"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Telemetry.General.TelemetryLibraryDispatchBase.GetHandler(InsightSheath.Debugging.DebugEventExceptionInfo)">
            <summary>
            If your class supports the exception, return an instance that handles it.
            </summary>
            <param name="Info"></param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.MachineType">
            <summary>
            Machine Type values extractable 
            </summary>
        </member>
        <member name="F:InsightSheath.MachineType.MachineInvalid">
            <summary>
            Returned on error with <see cref="M:InsightSheath.HelperRoutines.GetPEMachineType(System.String)"/> 
            </summary>
        </member>
        <member name="F:InsightSheath.MachineType.MachineI386">
            <summary>
            x86 based 
            </summary>
        </member>
        <member name="F:InsightSheath.MachineType.MachineIA64">
            <summary>
            Intel Itanium based
            </summary>
        </member>
        <member name="F:InsightSheath.MachineType.MachineAmd64">
            <summary>
            x64 based
            </summary>
        </member>
        <member name="T:InsightSheath.HelperRoutines">
            <summary>
            Class contains various miscellaneous routines that while not tied directly to the library's purpose, they are used throughout the Sheath and wrappers.
            </summary>
        </member>
        <member name="M:InsightSheath.HelperRoutines.GetPEMachineType(System.String)">
            <summary>
            Maps the passed DLL/EXE file into our memory and fetches the IMAGE_NT_HEADER->FileHeader.Machine value before finishing. Recommended to call once and save results.
            </summary>
            <param name="Target">Unicode String pointing to the file to check.</param>
            <returns>Returns the Machine entry for the struct as told at https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header. If you get something other than those or get zero, something went wrong.  </returns>
            <remarks>This does involve calling the ImageNtHeader DebugHelp() without taking care to sync calls. TODO: Add that. </remarks>
        </member>
        <member name="M:InsightSheath.HelperRoutines.DuplicateHandleToRemote(System.IntPtr,System.UInt32,System.Boolean,System.IntPtr,System.Boolean)">
            <summary>
            Duplicate a handle from the current process into the target process.
            </summary>
            <param name="CurrentHandle">handle located in current process</param>
            <param name="Access">Choose your access parameters</param>
            <param name="CopyAccess">set to true to ignore <see cref="!:Access"/> and take the current permissions from the handle for the new one too</param>
            <param name="TargetProcess">Target remote process to pick from</param>
            <param name="AllowInherit">Allow spawned processes to inherit</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.GetProcessNameViaHandle(System.IntPtr)">
            <summary>
            Get a Process's name via its handle.Handle needs PROCESSS_QUERY_INFOMRATION and VM_READ rights.
            </summary>
            <param name="ProcessHandle"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.GetModuleNameViaHandle(System.IntPtr)">
            <summary>
            Same as <see cref="M:InsightSheath.HelperRoutines.GetProcessNameViaHandle(System.IntPtr)"/>
            </summary>
            <param name="ProcessHandle">Process Handle to retrieve name from</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.GetModuleNameViaHandle(System.IntPtr,System.IntPtr)">
            <summary>
            Get the module name (or the process name) of the process whose handle you have
            </summary>
            <param name="ProcessHandle">Process Handle to source data from</param>
            <param name="HModule">if IntPTr.zero then <see cref="M:InsightSheath.HelperRoutines.GetProcessNameViaHandle(System.IntPtr)"/> otherwise retrieved the name for specified hmodule</param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.GetFileNameViaHandle(System.IntPtr)">
            <summary>
            Get a file name via a Native Handle. 
            </summary>
            <param name="FileHandle">Win32 Handle in question</param>
            <returns>returns either null or a string containing the name of fie file/IO device</returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.OpenProcessForVirtualMemory(System.UInt32)">
            <summary>
            Open a process for Virtual Memory reading and writing
            </summary>
            <param name="ProcessId"></param>
            <returns>Returns a handle with PROCESS_VM_READ | PROCESS_VM_RIGHT access to the passed process (or 0)</returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.OpenProcessForQueryInformation(System.UInt32)">
            <summary>
            Open a process for Querying Some information about it (requests  PROCESS_QUERY_INFORMATION )
            </summary>
            <param name="ProcessId"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.OpenProcessForHandleDuplicating(System.UInt32)">
            <summary>
            Open a process for duplicating and inserting handles of resources you open into a process (PROCESS_DUP_HANDLE | PROCESS_VM_WRITE | PROCESS_VM_OPERATION) 
            </summary>
            <param name="ProcessID"></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.HelperRoutines.CloseHandle(System.IntPtr)">
            <summary>
            Some of the routines here return Native Handles. This wraps <see href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"/> aka CloseHandle() 
             from kernel32 for convenience  
            </summary>
            <param name="Handle">Handle to close.</param>
            <returns>True if it worked and false if it did not.</returns>
            <remarks>When running under an attached debugger, an exception can trigger if the debugged process tries closing an invalid handle. <see cref="F:InsightSheath.Debugging.DebugExceptionTypes.InvalidHandleCloseException"/></remarks>
            <exception cref="F:InsightSheath.Debugging.DebugExceptionTypes.InvalidHandleCloseException"> This may trigger CloseHandle is asked to close an invalid handle in software attached to a debugger</exception>
        </member>
        <member name="T:InsightSheath.Win32Struct.ObjectAttributes64">
            <summary>
            This is the Object Attributes struct for a 64-bit process  Specs from <see href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes"/> 
            </summary>
            <remarks> <summary>
            IMPORTANT! Pointer values and handle are 8 bytes long for x64 bit processes instead of 4 bytes. This is why we need to define two structs. Other struct is <see cref="T:InsightSheath.Win32Struct.ObjectAttributes32"/>
            </summary></remarks>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes64.Length">
            <summary>
            Length of this struct. For x64 bit code, a proper one is 48.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes64.RootDirectory">
            <summary>
            8 byte potentially 0 Handle value indicated the root that <see cref="F:InsightSheath.Win32Struct.ObjectAttributes64.ObjectName"/> specifies.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes64.ObjectName">
            <summary>
            a 8 byte pointer to a <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> struct. This is the name of the item this struct points too
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes64.Attributes">
            <summary>
            4 byte value indicating object attributes.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes64.SecurityDescriptor">
            <summary>
            8 byte pointer to the defined security descriptor. May be (null/0) if default is fine.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes64.SecurityQoS">
            <summary>
            8 byte pointer to the defined security quality of service. May be (null/0) if default is fine.
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.ObjectAttributes32">
            <summary>
            This is the Object Attributes struct for a Wow / x86 bit process.  Specs from <see href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes"/> 
            </summary>
            <remarks>For x86 (32-bit) processes, handles, pointers, uints are all 4 bytes long. This is not true for x64 processes and that's why <see cref="T:InsightSheath.Win32Struct.ObjectAttributes64"/> exists</remarks>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes32.Length">
            <summary>
            Length of the struct. For x86, a proper value is 24.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes32.RootDirectory">
            <summary>
            4 byte potentially 0 Handle value indicated the root that <see cref="F:InsightSheath.Win32Struct.ObjectAttributes32.ObjectName"/> specifies.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes32.ObjectName">
            <summary>
            a 4 byte pointer to a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> struct. This is the name of the item this struct points too
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes32.Attributes">
            <summary>
            4 byte value indicating object attributes.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes32.SecurityDescriptor">
            <summary>
            4 byte pointer to the defined security descriptor. May be (null/0) if default is fine.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.ObjectAttributes32.SecurityQoS">
            <summary>
            4 byte pointer to the defined security quality of service. May be (null/0) if default is fine.
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.ObjectAttributes32.Promotion">
            <summary>
            Return a 64-bit version with the 32-bit values promoted to 64-bit.
            </summary>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Win32Struct.Remote.RemoteStructure">
            <summary>
            Imports the RemoteRead and RemoteWrite structures for dealing with extracting data from the target process during various events.
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadPointer(System.IntPtr,System.IntPtr,InsightSheath.Win32Struct.Remote.RemoteStructure.PointerSize)">
            <summary>
            Read either a 4 byte or 8 byte pointer from the passed process handle.
            </summary>
            <param name="ProcessHandle">0= self</param>
            <param name="Location">virtual memory location</param>
            <param name="Size">either Size4 or Size8 from <seealso cref="T:InsightSheath.Win32Struct.Remote.RemoteStructure.PointerSize"/></param>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(System.IntPtr,System.IntPtr,System.Boolean,System.Boolean)">
            <summary>
            Read either a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> from the location. Note: This does assume the NativeExport from InsightAPI.DLL will always return a 64-bit version of the struct and quietly promotes the 32-bit version when extracting from the target to an x64 bit version
            </summary>
            <param name="ProcessHandle">Handle to Read From</param>
            <param name="Location">location to read from</param>
            <param name="IsTarget32Bit">determines which type of struct we're reading from</param>
            <param name="FreeOnCleanup">argument terminates if we trigger GC </param>
            <returns>Returns a unique instance of a <see cref="T:InsightSheath.Win32Struct.WindowsUnicodeString"/> ready for use.</returns>
        </member>
        <member name="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadString(System.IntPtr,System.IntPtr,System.UInt64)">
            <summary>
            Extract an Unicode string from the remote process. You will need to know how long the string is.
            </summary>
            <param name="ProcessHandle">Process should be open for VM_READ rights at least</param>
            <param name="StringLocation">virtual memory location in the remote process</param>
            <param name="CharCount">how many chars in the string (Unicode)</param>
            <returns>Returns a .NET managed string on OK and null on a problem.</returns>
        </member>
        <member name="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadDebugString(System.IntPtr,System.IntPtr)">
            <summary>
            Extract a DebugString from an OUTPUT_DEBUG_EVENT <see cref="T:InsightSheath.Debugging.DebugEvent"/> and <see cref="T:InsightSheath.Debugging.DebugEventStringInfo"/> for other ways.   
            </summary>
            <param name="ProcessHandle">Handle to the process</param>
            <param name="DebugEventStruct">Pointer to a DebugEvent native structure</param>
            <returns></returns>
        </member>
        <member name="T:InsightSheath.Win32Struct.StartupInfoExW_Flags">
            <summary>
            See <seealso href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow"/>  entry for dwFlags for the meaning of these values.
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.StartupInfoExW_ShowWindow">
            <summary>
            Lifted from <see href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow"/> these let  you specify how  starting window will do
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.StartupInfoExW_ShowWindow.ShowDefault">
            <summary>
            Not supported for startup info. For ShowWindow MSDN it means use the startupinfo to specify how to display the Window
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.StartupInfoExW">
            <summary>
            Wrapper for the StartupInfoExW struct handler exported in InsightApi.dll.
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.StartupInfoExW.MakeInstance">
            <summary>
            Call the routine on the native side to make an instance and return a pointer to the wrapper class already pointed to that.
            </summary>
            <returns></returns>
        </member>
        <member name="M:InsightSheath.Win32Struct.StartupInfoExW.#ctor(System.IntPtr)">
            <summary>
            Make an instance of the wrapper class for this unamanged non-null native pointer.
            </summary>
            <param name="Native">Non null native poionter</param>
        </member>
        <member name="M:InsightSheath.Win32Struct.StartupInfoExW.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Make an instance of the wrapper class for this unamanged non-null native pointer.
            </summary>
            <param name="Native">Non null native poionter</param>
            <param name="FreeonCleanup">Indicate if we're calling the unmanaged routine to delete this or non on GC collection</param>
        </member>
        <member name="M:InsightSheath.Win32Struct.StartupInfoExW.Dispose(System.Boolean)">
            <summary>
            Call the appropriate unamanged routine to clean up this class.
            </summary>
            <param name="disposing">true if disposing of managed resources also.</param>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.Desktop">
            <summary>
            Get or set the desktop the process will be started on. Leave null to try inheriting the desktop the spawning process is running on.
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.Title">
            <summary>
            Get or Set the name of the Console Window Title. No Extra Flags Needed. MSDN Documentation recommends this be NULL for Console processes that don't need a window or GUI processes that don't create a window
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.X">
            <summary>
            Get or set the X position of the starting window (in pixels), use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UsePosition"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.Y">
            <summary>
            Get or set the Y position of the starting window (in pixels), use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UsePosition"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.XSize">
            <summary>
            Get or Set the Width of the Window (in pixels),  use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseSize"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.YSize">
            <summary>
            Get or Set the Height of the Window (in pixels),  use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseSize"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.XCountChars">
            <summary>
            Get or set the starting width of the Console (if created and is in char rows),  use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseCountChars"/>) in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.YCountChars">
            <summary>
            Get or set the starting height of the Console (if created and is in char rows),  use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseCountChars"/>) in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.FillAtribute">
            <summary>
            Get or set how the Console window colors will be starting out (ignored if no console), use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseFillAttribute"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to set
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.Flags">
            <summary>
            Get or set the flags that indicate which part of startup info is valid. Remember to set otherwise the system will ignore it. Look at <see cref="T:InsightSheath.Win32Struct.StartupInfoExW_Flags"/> or go to the source at <see href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.ShowWindow">
            <summary>
            Specify how to show the initial window. Use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseShowWindow"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to indicate use.
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.StandardInput">
            <summary>
            Get or set what's passed along to the hStdInput member, use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseHotKey"/>.  or <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseStdHandles"/> to indicate how this will be interpreted in the <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> setting
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.StandardOutput">
            <summary>
            Get or set what's passed to the hStdOutput member, use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseStdHandles"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to indicate how to use.
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.StandardError">
            <summary>
            Get or set what's passed to the hStdError member, use <see cref="F:InsightSheath.Win32Struct.StartupInfoExW_Flags.Startf_UseStdHandles"/> in <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> to indicate how to use.
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.StartupInfoExW.FlagSetterHelper">
            <summary>
            Manged side only.  Set to true to enable setting the <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.Flags"/> value on setting the members in this class EXCEPT for <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.StandardInput"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.StartupInfoExW.FlagSetterContainer">
            <summary>
            Protected variable that <see cref="P:InsightSheath.Win32Struct.StartupInfoExW.FlagSetterHelper"/> accesses.
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.UserProcessParameters64">
            <summary>
            contains the x64 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10. <see href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-rtl_user_process_parameters"/>
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.UserProcessParameters32">
            <summary>
            contains the x86 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10. <see href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-rtl_user_process_parameters"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UserProcessParameters32.Reserved1">
            <summary>
            MSDN marks these as reversed. 
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UserProcessParameters32.Reserved2">
            <summary>
            MSDN marks this a PVOID (going to be 4 bytes/uint for x86 code and 8 bytes/ulong for x64 code)
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UserProcessParameters32.ImagePathName">
            <summary>
            Location to where the image is spawned from in an x86 process.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UserProcessParameters32.CommandLine">
            <summary>
            Location to the command line to be passed to the x86 process.
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.WindowsObjectAttributes">
            <summary>
            made from specs here <see href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsObjectAttributes.Dispose(System.Boolean)">
            <summary>
            <see cref="T:InsightSheath.Win32Struct.WindowsObjectAttributes"/> cleanup.  We need to call the current native routine to cleanup and clear the cleanup flag so we don't delete mememory already deleted
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsObjectAttributes.Apply">
            <summary>
            Not currently implemented
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsObjectAttributes.Length">
            <summary>
            Retrieve the length value of the structure on the native size. <see cref="!:StructTypeContainer"/> must be set to something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown"/>
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsObjectAttributes.RootDirectory">
            <summary>
            Retrieve the handle value of the structure on the native size. 4 byte values are already promoted to 8 bytes long when returned. 
            </summary>
            <remarks><see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> must be set to something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown"/></remarks>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsObjectAttributes.ObjectName">
            <summary>
            Retrieve (and set the current <see cref="T:InsightSheath.Win32Struct.StructModeType"/> for the current UnicodeString structure pointed to.  Can return null if that's not set
            </summary>
            <remarks>The returned object is pointing to the same native object as this class. If you want a unique one, duplicate it. <see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> must be set to something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown"/></remarks>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsObjectAttributes.Attributes">
            <summary>
            Return the object attributes of the native struct.
            </summary>
            <remarks><see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> must be set to something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown"/></remarks>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsObjectAttributes.SecurityDescriptor">
            <summary>
            Return a pointer to the security descriptor (may be not be relative to Your process. <see href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory"/> to read the data. 
            </summary>
            <remarks><see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> 
            must be set to something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown"/>.
            This can be 0 if the default one is OK. 4 byte pointers are promoted to 8 bytes long. 
            The <see cref="!:Remote.RemoteStructure.xxx"/> routine does not read this into your process 
            currently.</remarks>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsObjectAttributes.SecurityQualityOfService">
            <summary>
            Return a pointer to the security quality of service struct (may be not be relative to Your process. <see href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory"/> to read the data. 
            </summary>
            <remarks><see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> 
            must be set to something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown"/>.
            This can be 0 if the default one is OK. 4 byte pointers are promoted to 8 bytes long. 
            The <see cref="!:Remote.RemoteStructure.xxx"/> routine does not read this into your process 
            currently.</remarks>
        </member>
        <member name="F:InsightSheath.Win32Struct.WindowsObjectAttributes.Ret32">
            <summary>
            if <see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> is set to <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/>, <see cref="M:InsightSheath.Win32Struct.WindowsObjectAttributes.Blit"/> marshals to this structure.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.WindowsObjectAttributes.Ret64">
            <summary>
            if <see cref="F:InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer"/> is set to <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/>, <see cref="M:InsightSheath.Win32Struct.WindowsObjectAttributes.Blit"/> marshals to this structure.
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.StructModeType">
            <summary>
            Enum used by certain classes that encapsulate Native Structs that contain pointers whose size may not match *our* pointer size.  One will need to set the <see cref="P:InsightSheath.Abstract.PlatformDependantNativeStruct.StructType"/> in a child class to flag which version to use
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.StructModeType.MachineUnknown">
            <summary>
            Not defined.  Attempting to access properties in this class will trigger <see cref="T:System.InvalidOperationException"/> asking programming to pick either <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/> or <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.StructModeType.Machinex86">
            <summary>
            Class encapsulates a 32 bit version of the native struct. For Example <see cref="T:InsightSheath.Win32Struct.WindowsUnicodeString"/> and <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/>
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.StructModeType.Machinex64">
            <summary>
            Class encapsulates a 64- bit version of the native struct. For Example <see cref="T:InsightSheath.Win32Struct.WindowsUnicodeString"/> and  <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> struct
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.UnicodeString32">
            <summary>
            For processes that are 32-bit / Wow64. This is what the UNICODE_STRING Windows struct looks like. Once your grab a dot net version of what ever you're reading from, you'll need to know if the <see cref="F:InsightSheath.Win32Struct.UnicodeString32.Buffer"/> is in your process memory space or an external process.
            </summary>
            <remarks> Use <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)"/>  and pass <see cref="F:InsightSheath.Win32Struct.UnicodeString32.Buffer"/> for a local memory pointer and <see cref="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadString(System.IntPtr,System.IntPtr,System.UInt64)"/> for a pointer relevent to a different process </remarks>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString32.Length">
            <summary>
            Current Length of the string pointed to in Buffer. Note if dealing with <see cref="!:InsertHere"/>, the memory block pointed to by bufffer currently will be set right after the native location of struct plus its size
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString32.MaxLength">
            <summary>
            How big possibly is if the buffer. Note <see cref="!:InsertHere"/> dealing this is here for completeness sake. Your buffer (if remote) was allocated to be big enough to hold that containing string, that's all
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString32.Buffer">
            <summary>
            4 byte pointer to where the Unicode String is allocated. 
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.UnicodeString64">
            <summary>
            For processes that are 64-bit, this is what the UNICODE_STRING Windows struct looks like when read from. Suitable for Marshaling from a source. Take care with the string pointer to know if it's local memory or extern/remote/not your process's memory. .if your pointer to the native structure <see cref="F:InsightSheath.Win32Struct.UnicodeString32.Buffer"/> points to a remote/ non local memory buffer or not. 
            </summary>
            <remarks> Use <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)"/>  and pass <see cref="F:InsightSheath.Win32Struct.UnicodeString64.Buffer"/> for a local memory pointer and <see cref="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadString(System.IntPtr,System.IntPtr,System.UInt64)"/> for a pointer relevent to a different process </remarks>
            <summary>
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString64.Length">
            <summary>
            Current Length of the string pointed to in Buffer. 
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString64.MaxLength">
            <summary>
            How big possibly is if the buffer. 
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString64.Padding">
            <summary>
            Padding to ensure <see cref="F:InsightSheath.Win32Struct.UnicodeString64.Buffer"/> is at the right spot. Otherwise unused. 
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.UnicodeString64.Buffer">
            <summary>
            8 byte pointer to where the Unicode String is allocated. 
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.WindowsUnicodeString">
            <summary>
            Encapsulates both a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> and lets one indicate which one to use based on <see cref="!:WindowsUnicodeString.StructType"/> You can use <see cref="M:InsightSheath.HelperRoutines.GetPEMachineType(System.String)"/> on the process your dealing with to find what value was set as the machine type
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.#ctor(System.IntPtr)">
            <summary>
            After creating an instance, call <see cref="!:PlatformDependantNativeStruct.SetStructType(ModeType)"/> and specify which version of an Unicode string, this class contrains
            </summary>
            <param name="Native"></param>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            After creating an instance, call <see cref="!:SetStructType(ModeType)"/> and specify which version of an Unicode string, this class contrains
            </summary>
            <param name="Native">Native pointer to either a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> to the structure this class will reference</param>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.#ctor(System.IntPtr,System.Boolean,InsightSheath.Win32Struct.StructModeType)">
            <summary>
            Create an instance of <see cref="T:InsightSheath.Win32Struct.WindowsUnicodeString"/> and specify the native pointer, if the class will be subject to unmanaged cleanup and which Native Struct the pointer points too
            </summary>
            <param name="Native">Native pointer to either a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> to the structure this class will reference</param>
            <param name="FreeOnCleanup">if true then the structure is freed via RemoteRead_SimpleFree() which itself is a call to C/C++'s free() . Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated</param>
            <param name="StructType">Use <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/> to mark structure as a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> pointer and <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/> to mark struct as a <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> pointer</param>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.#ctor(System.IntPtr,InsightSheath.Win32Struct.StructModeType)">
            <summary>
            Create an instance of <see cref="T:InsightSheath.Win32Struct.WindowsUnicodeString"/> and specify the native pointer and which Native Struct the pointer points too
            </summary>
            <param name="Native">Native pointer to either a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> to the structure this class will reference</param>
            <param name="StructType">Use <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/> to mark structure as a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> pointer and <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/> to mark struct as a <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> pointer</param>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.Finalize">
            <summary>
            Finalized that calls <see cref="M:InsightSheath.Win32Struct.WindowsUnicodeString.Dispose(System.Boolean)"/> with the value of false
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.Blit">
            <summary>
            Marshals into a private <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> struct depending on the value of <see cref="!:PlatformDependantNativeStruct.WasBlit"/> being false.  Sets to true afterwords. Will throw an <see cref="T:System.InvalidOperationException"/> if <see cref="P:InsightSheath.Abstract.PlatformDependantNativeStruct.StructType"/>  is something other than <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/> or <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/>
            </summary>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.Dispose(System.Boolean)">
            <summary>
            The native memory is either a <see cref="T:InsightSheath.Win32Struct.UnicodeString32"/> or <see cref="T:InsightSheath.Win32Struct.UnicodeString64"/> struct Dependant on <see cref="!:StructType"/>.  Pointer is a separate allocated string. 
            This means <see cref="M:InsightSheath.NativeImports.NativeMethods.SimpleFree(System.IntPtr)"/> is incorrect in this scenario. We'll need to call <see cref="!:NativeImports.NativeMethods.RemoteFreeUnicodeString(IntPtr, bool)"/> pointer here. Also <see cref="!:FreeOnCleanup"/> should be false if this structure is part of a larger struct directly and NOT A POINTER.
            </summary>
            <param name="disposing"></param>
            <remarks>Native side always returns a UnicodeString64 bit.  We simply calculate and discard value</remarks>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsUnicodeString.Length">
            <summary>
            Reads the current length of the string in <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr"/> based on the current <see cref="!:StructType"/> setting
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsUnicodeString.MaxLength">
            <summary>
            Reads the max length (in bytes) of the string in <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr"/> based on the current <see cref="P:InsightSheath.Abstract.PlatformDependantNativeStruct.StructType"/> setting in this class
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr">
            <summary>
            Return the buffer containing the string in the contained structure based on the current <see cref="!:StructType"/> setting.  x86 (4 byte sized) pointers are promoted to a x64 (8 byte sized) return value
            </summary>
        </member>
        <member name="P:InsightSheath.Win32Struct.WindowsUnicodeString.Buffer">
            <summary>
            Retrieve a .NET managed string containing the String that <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr"/> points to. 
            </summary>
            <remarks>IMPORTANT!!!!!  Use <see cref="M:InsightSheath.Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(System.IntPtr,System.IntPtr,System.Boolean,System.Boolean)"/> if dealing with a <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr"/> that is valid in the context of another process and not yours. This routine will take case or dealing with that. You'll either get incorrect results or generate an exception if you don't. </remarks>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.ToString">
            <summary>
            Equivalent to grabbing the <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.Buffer"/> property if <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr"/> is non zero
            </summary>
            <returns>If <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr"/> is 0, return null. Otherwise returns <see cref="P:InsightSheath.Win32Struct.WindowsUnicodeString.Buffer"/></returns>
            <exception cref="T:System.InvalidOperationException">Can be triggered if one forgets to set <see cref="!:StructType"/></exception>
        </member>
        <member name="M:InsightSheath.Win32Struct.WindowsUnicodeString.Apply">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.WindowsUnicodeString.Machine64">
            <summary>
            If <see cref="!:StructType"/> is set to <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex64"/>, this is the structure that is used.
            </summary>
        </member>
        <member name="F:InsightSheath.Win32Struct.WindowsUnicodeString.Machine32">
            <summary>
            If <see cref="!:StructType"/> is set to <see cref="F:InsightSheath.Win32Struct.StructModeType.Machinex86"/>, this is the structure that is used.
            </summary>
        </member>
        <member name="T:InsightSheath.Win32Struct.WindowsUserProcessParameter">
            <summary>
            TODO:
            </summary>
        </member>
        <member name="T:InsightSheath.Wrappers.Detours">
            <summary>
            Intended for wrapps
            </summary>
        </member>
        <member name="M:InsightSheath.Wrappers.Detours.DetourEnumerateModulesEx(System.IntPtr,System.IntPtr)">
            <summary>
            Like DetourEnumerateModules() but one can specific a target process.
            TODO: NOT FUNCTIONAL
            </summary>
            <param name="hProcess"></param>
            <param name="hModule"></param>
            <returns></returns>
        </member>
    </members>
</doc>
