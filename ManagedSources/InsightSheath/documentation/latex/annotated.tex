\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_a_p_i___v_e_r_s_i_o_n}{Insight\+Sheath.\+Debugging.\+Symbol\+Engine.\+API\+\_\+\+VERSION}} \\*\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_a_p_i___v_e_r_s_i_o_n}{API\+\_\+\+VERSION}} struct for Debug\+Help symbol library. }{\pageref{struct_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_a_p_i___v_e_r_s_i_o_n}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_telemetry_1_1_check_remote_debugger_present_settings}{Insight\+Sheath.\+Telemetry.\+Check\+Remote\+Debugger\+Present\+Settings}} }{\pageref{class_insight_sheath_1_1_telemetry_1_1_check_remote_debugger_present_settings}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event}{Insight\+Sheath.\+Debugging.\+Debug\+Event}} \\*This encapsulates the Native \mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event}{Debug\+Event}} structure via calling exported C routines in Insight\+API.\+dll. }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_create_process_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Create\+Process\+Info}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_create_process_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_create_thread_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Create\+Thread\+Info}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_create_thread_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_exception_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Exception\+Info}} \\*Class Wrapper dealing with extracting Exception information from a \mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event}{Debug\+Event}}. }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_exception_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_exit_process_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Exit\+Process\+Info}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_exit_process_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_exit_thread_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Exit\+Thread\+Info}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_exit_thread_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_load_dll_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Load\+Dll\+Info}} \\*Provides access to a \mbox{\hyperlink{namespace_insight_sheath_1_1_debugging_a7ca0bf717735083281409a01b7af9fd8afca498d4710b5539f369a6de68e749ab}{Debug\+Event\+Type.\+Load\+Dll\+Event}} in a \mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event}{Debug\+Event}} struct }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_load_dll_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_rip_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Rip\+Info}} \\*Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere. }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_rip_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_static_container}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Static\+Container}} \\*Implements the basis of disposal the other \mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event}{Debug\+Event}} classes use. Also exposes routines to read the Process\+ID and Thread\+ID that triggered the event }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_static_container}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_string_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+String\+Info}} \\*Providers a wrapper to process specific \mbox{\hyperlink{namespace_insight_sheath_1_1_debugging_a7ca0bf717735083281409a01b7af9fd8a117b38a6e59c745c9c605870e6e2f4de}{Debug\+Event\+Type.\+Output\+Debug\+String}} components. }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_string_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_debug_event_unload_dll_info}{Insight\+Sheath.\+Debugging.\+Debug\+Event\+Unload\+Dll\+Info}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_debug_event_unload_dll_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_debug_help___api_version_struct}{Insight\+Sheath.\+Debugging.\+Symbol\+Engine.\+Debug\+Help\+\_\+\+Api\+Version\+Struct}} \\*\mbox{\hyperlink{namespace_insight_sheath_1_1_wrappers}{Wrappers}} for Api Version struture. Note\+: Impementation in Insight has the struct as part of it, you DON\textquotesingle{}T want to free any pointer to it you get from insite. }{\pageref{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_debug_help___api_version_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_misc_1_1_event_debug_assist}{Insight\+Sheath.\+Misc.\+Event\+Debug\+Assist}} \\*Implements an event debugger system for processing events. You will need to link a way to call \mbox{\hyperlink{class_insight_sheath_1_1_misc_1_1_event_debug_assist_a860345a3690b1616048e365ee1a81f3f}{Event\+Debug\+Assist.\+Fire\+Events(\+Debug\+Event)}} in order to actually make to the thing work }{\pageref{class_insight_sheath_1_1_misc_1_1_event_debug_assist}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_telemetry_1_1_general_telemtry_helper_struct}{Insight\+Sheath.\+Telemetry.\+General\+Telemtry\+Helper\+Struct}} \\*General common values/code between the telemetry reader code. }{\pageref{class_insight_sheath_1_1_telemetry_1_1_general_telemtry_helper_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_telemetry_1_1_generic_telemetry_exception}{Insight\+Sheath.\+Telemetry.\+Generic\+Telemetry\+Exception}} }{\pageref{class_insight_sheath_1_1_telemetry_1_1_generic_telemetry_exception}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_insight_hunter}{Insight\+Sheath.\+Debugging.\+Symbol\+Engine.\+Insight\+Hunter}} \\*A part of the symbol engine exported in Insight\+API in the Native DLL. This class is VERY VERY VERY tightly coupled with the Insight\+Process class but distinct enough to warrent its own class/wrapper wrappers. If you need not have symbol processing, disabling Insight\+Process.\+Enable\+Symbol\+Engine is set to false if fine. That turns off the code that updates the native \mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_insight_hunter}{Insight\+Hunter}} class when the worker thread receives a debug event NOTE\+: You\textquotesingle{}ll need to spawn at least one process with Insight\+Process to get much use out of this. }{\pageref{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_insight_hunter}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_process_1_1_insight_memory}{Insight\+Sheath.\+Debugging.\+Process.\+Insight\+Memory}} \\*Get memory data about an arbitrary process of your choice }{\pageref{class_insight_sheath_1_1_debugging_1_1_process_1_1_insight_memory}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_process_1_1_insight_process}{Insight\+Sheath.\+Debugging.\+Process.\+Insight\+Process}} \\*choose an environment and spawn a process. This class is a wrapper for the C++ Class named \char`\"{}\+Insight\+Process\char`\"{} implemented as a native DLL in the source PS\+\_\+\+Process\+Information.\+cpp and said class is the functionally the heart of the DLL. }{\pageref{class_insight_sheath_1_1_debugging_1_1_process_1_1_insight_process}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_telemetry_1_1_io_device_telememtry_exception_common_values}{Insight\+Sheath.\+Telemetry.\+Io\+Device\+Telememtry\+Exception\+Common\+Values}} }{\pageref{class_insight_sheath_1_1_telemetry_1_1_io_device_telememtry_exception_common_values}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_telemetry_1_1_io_device_telemetry_nt_create_file}{Insight\+Sheath.\+Telemetry.\+Io\+Device\+Telemetry\+Nt\+Create\+File}} }{\pageref{class_insight_sheath_1_1_telemetry_1_1_io_device_telemetry_nt_create_file}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_telemetry_1_1_io_device_telemety_create_file}{Insight\+Sheath.\+Telemetry.\+Io\+Device\+Telemety\+Create\+File}} \\*This structure contains data from an exception generated via Create\+File\+A/W. }{\pageref{class_insight_sheath_1_1_telemetry_1_1_io_device_telemety_create_file}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_telemetry_1_1_l_a_r_g_e___i_n_t_e_g_e_r}{Insight\+Sheath.\+Telemetry.\+LARGE\+\_\+\+INTEGER}} \\*Large structure for getting \mbox{\hyperlink{struct_insight_sheath_1_1_telemetry_1_1_l_a_r_g_e___i_n_t_e_g_e_r}{LARGE\+\_\+\+INTEGER}} structs into .Net Hands }{\pageref{struct_insight_sheath_1_1_telemetry_1_1_l_a_r_g_e___i_n_t_e_g_e_r}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_native_static_container}{Insight\+Sheath.\+Abstract.\+Native\+Static\+Container}} \\*Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/\+C++\textquotesingle{}s free(). If said Native class needs special free requirements, overwrite \mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_native_static_container_aab47d778e6f074d10e4d0511471e8727}{Dispose(bool)}} with a a call to a routine to properly free it. If your wrapper is handing out multiple natiove pointers to the same object, you\textquotesingle{}ll need something like \mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container}{Reference\+Counter\+Native\+Static\+Container}} }{\pageref{class_insight_sheath_1_1_abstract_1_1_native_static_container}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_object_attributes32}{Insight\+Sheath.\+Win32\+Struct.\+Object\+Attributes32}} \\*This is the Object Attributes struct for a Wow / x86 bit process. Specs from  }{\pageref{struct_insight_sheath_1_1_win32_struct_1_1_object_attributes32}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_object_attributes64}{Insight\+Sheath.\+Win32\+Struct.\+Object\+Attributes64}} \\*This is the Object Attributes struct for a 64-\/bit process Specs from  }{\pageref{struct_insight_sheath_1_1_win32_struct_1_1_object_attributes64}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_on_demand_marshal_native_struct}{Insight\+Sheath.\+Abstract.\+On\+Demand\+Marshal\+Native\+Struct}} \\*Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct. }{\pageref{class_insight_sheath_1_1_abstract_1_1_on_demand_marshal_native_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_platform_dependant_native_struct}{Insight\+Sheath.\+Abstract.\+Platform\+Dependant\+Native\+Struct}} \\*This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target. }{\pageref{class_insight_sheath_1_1_abstract_1_1_platform_dependant_native_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_process_1_1_process_memory_count32}{Insight\+Sheath.\+Debugging.\+Process.\+Process\+Memory\+Count32}} \\*\mbox{\hyperlink{namespace_insight_sheath_1_1_debugging_1_1_process}{Process}} Memory count for 32-\/bit process }{\pageref{struct_insight_sheath_1_1_debugging_1_1_process_1_1_process_memory_count32}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_process_1_1_process_memory_count64}{Insight\+Sheath.\+Debugging.\+Process.\+Process\+Memory\+Count64}} \\*\mbox{\hyperlink{namespace_insight_sheath_1_1_debugging_1_1_process}{Process}} Memory count for 64-\/bit process }{\pageref{struct_insight_sheath_1_1_debugging_1_1_process_1_1_process_memory_count64}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_process_1_1_p_s_a_p_i___w_o_r_k_i_n_g___s_e_t___e_x___b_l_o_c_k}{Insight\+Sheath.\+Debugging.\+Process.\+PSAPI\+\_\+\+WORKING\+\_\+\+SET\+\_\+\+EX\+\_\+\+BLOCK}} \\*\href{https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block}{\texttt{ https\+://docs.\+microsoft.\+com/en-\/us/windows/win32/api/psapi/ns-\/psapi-\/psapi\+\_\+working\+\_\+set\+\_\+ex\+\_\+block}} }{\pageref{struct_insight_sheath_1_1_debugging_1_1_process_1_1_p_s_a_p_i___w_o_r_k_i_n_g___s_e_t___e_x___b_l_o_c_k}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_process_1_1_p_s_a_p_i___w_o_r_k_i_n_g___s_e_t___e_x___i_n_f_o_r_m_a_t_i_o_n}{Insight\+Sheath.\+Debugging.\+Process.\+PSAPI\+\_\+\+WORKING\+\_\+\+SET\+\_\+\+EX\+\_\+\+INFORMATION}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_process_1_1_p_s_a_p_i___w_o_r_k_i_n_g___s_e_t___e_x___i_n_f_o_r_m_a_t_i_o_n}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_process_1_1_query_working_structs}{Insight\+Sheath.\+Debugging.\+Process.\+Query\+Working\+Structs}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_process_1_1_query_working_structs}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_misc_1_1_reference_counter}{Insight\+Sheath.\+Misc.\+Reference\+Counter}} \\*USed by the Reference\+Counter\+Native\+Static\+Container to track and change a reference. This is primary used by the Debug\+Event class collection as we\textquotesingle{}re handing out Multiple REferences to the same Native Pointer like candy and need to take steps to prevent users of the library from prematuring freeing the same sheath }{\pageref{class_insight_sheath_1_1_misc_1_1_reference_counter}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container}{Insight\+Sheath.\+Abstract.\+Reference\+Counter\+Native\+Static\+Container}} \\*This class contains an \mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container_a129a0deb3f221ac2779a5cf00f9e97e3}{Add\+Ref()}}/ \mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container_a72cd0f0d7bf610d0553f5f9024702377}{Release()}} component for child classes. Destructors(), Call \mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container_a72cd0f0d7bf610d0553f5f9024702377}{Release()}} and if that returns 0, free as appropriate. Not needed if the class itself is a 1 to 1 ie Sheath class pointer that contains one pointer, this can skip. Sheath, Debug\+Event classes have this in the change, because they give out multiple references to a native class like candy. Each multiple class in the sheath points to a single native class. when the sheath class is freed(), }{\pageref{class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_source_file}{Insight\+Sheath.\+Debugging.\+Symbol\+Engine.\+Source\+File}} }{\pageref{struct_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_source_file}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_win32_struct_1_1_startup_info_ex_w}{Insight\+Sheath.\+Win32\+Struct.\+Startup\+Info\+ExW}} \\*Wrapper for the \mbox{\hyperlink{class_insight_sheath_1_1_win32_struct_1_1_startup_info_ex_w}{Startup\+Info\+ExW}} struct handler exported in Insight\+Api.\+dll. }{\pageref{class_insight_sheath_1_1_win32_struct_1_1_startup_info_ex_w}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_symbol_info}{Insight\+Sheath.\+Debugging.\+Symbol\+Engine.\+Symbol\+Info}} \\*\mbox{\hyperlink{namespace_insight_sheath_1_1_wrappers}{Wrappers}} imported for dealing with Symbol\+InfoW Native structures. }{\pageref{class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_symbol_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_thread_1_1_thread_context}{Insight\+Sheath.\+Debugging.\+Thread.\+Thread\+Context}} \\*\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_thread_1_1_thread_context}{Thread\+Context}} is a class indented for reading/writing information about threads receives in the main Insight\+Process structure We duplicate some of the functionality of the Process\+Thread class for C\# user familiarity. }{\pageref{class_insight_sheath_1_1_debugging_1_1_thread_1_1_thread_context}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string32}{Insight\+Sheath.\+Win32\+Struct.\+Unicode\+String32}} \\*For processed that are Wow/32-\/ bit this is what our UNICODE\+\_\+\+STRING struct looks like when read from. Suitable for Marshaling from either a local native pointer or remote/other process. Take care that you handle if your pointer to the native structure \mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string32_a1e1ce136f83201c56a69ee03b56e8564}{Unicode\+String32.\+Buffer}} points to a remote/ non local memory buffer or not. }{\pageref{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string32}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string64}{Insight\+Sheath.\+Win32\+Struct.\+Unicode\+String64}} \\*For processes that are 64-\/bit, this is our UNICODE\+\_\+\+STRING struct looks like when read from. Suitable for Marshaling from a source. Take care that you handle if your pointer to the native structure \mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string32_a1e1ce136f83201c56a69ee03b56e8564}{Unicode\+String32.\+Buffer}} points to a remote/ non local memory buffer or not. }{\pageref{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string64}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_user_process_parameters32}{Insight\+Sheath.\+Win32\+Struct.\+User\+Process\+Parameters32}} \\*contains the x86 version of the Native struct RTL\+\_\+\+USER\+\_\+\+PROCESS\+\_\+\+PARAMETERS as documented here and comparing offsets between the struct in the Offset\+Attrib sample project for Windows 10.  }{\pageref{struct_insight_sheath_1_1_win32_struct_1_1_user_process_parameters32}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_user_process_parameters64}{Insight\+Sheath.\+Win32\+Struct.\+User\+Process\+Parameters64}} \\*contains the x64 version of the Native struct RTL\+\_\+\+USER\+\_\+\+PROCESS\+\_\+\+PARAMETERS as documented here and comparing offsets between the struct in the Offset\+Attrib sample project for Windows 10.  }{\pageref{struct_insight_sheath_1_1_win32_struct_1_1_user_process_parameters64}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_win32_struct_1_1_windows_object_attributes}{Insight\+Sheath.\+Win32\+Struct.\+Windows\+Object\+Attributes}} \\*made from specs here  }{\pageref{class_insight_sheath_1_1_win32_struct_1_1_windows_object_attributes}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_win32_struct_1_1_windows_unicode_string}{Insight\+Sheath.\+Win32\+Struct.\+Windows\+Unicode\+String}} \\*Encapsulates both a \mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string32}{Unicode\+String32}} or \mbox{\hyperlink{struct_insight_sheath_1_1_win32_struct_1_1_unicode_string64}{Unicode\+String64}} and lets one indicate which one to use based on \mbox{\hyperlink{class_insight_sheath_1_1_abstract_1_1_platform_dependant_native_struct_a9b56ba82d073acce64844a2011e97508}{Windows\+Unicode\+String.\+Struct\+Type}} You can use Helper\+Routines.\+Get\+PEMachine\+Type(string) on the process your dealing with to find what value was set as the machine type }{\pageref{class_insight_sheath_1_1_win32_struct_1_1_windows_unicode_string}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_win32_struct_1_1_windows_user_process_parameter}{Insight\+Sheath.\+Win32\+Struct.\+Windows\+User\+Process\+Parameter}} }{\pageref{class_insight_sheath_1_1_win32_struct_1_1_windows_user_process_parameter}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_context}{Insight\+Sheath.\+Debugging.\+Thread.\+Wow64\+Context}} }{\pageref{class_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_context}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_context_layout}{Insight\+Sheath.\+Debugging.\+Thread.\+Wow64\+Context\+Layout}} \\*Handler for reading from / writing to a Wow64\+Context\+String }{\pageref{struct_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_context_layout}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_floating_point_save_area}{Insight\+Sheath.\+Debugging.\+Thread.\+Wow64\+Floating\+Point\+Save\+Area}} }{\pageref{struct_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_floating_point_save_area}}{}
\end{DoxyCompactList}
