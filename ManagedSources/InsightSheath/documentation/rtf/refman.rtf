{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment InsightSheath }InsightSheath}
{\comment Generated by doxygen 1.9.4.}
{\creatim \yr2022\mo6\dy9\hr19\min16\sec40}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt InsightSheath}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Thu Jun 9 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b InsightSheath} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Abstract} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.SymbolEngine} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Thread} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Misc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.NativeImports} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.Remote} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Wrappers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Debugging.SymbolEngine.API_VERSION\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Misc.EventDebugAssist\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Telemetry.GeneralTelemtryHelperStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
InsightSheath.Telemetry.GenericTelemetryException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
IDisposable
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Abstract.NativeStaticContainer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Abstract.OnDemandMarshalNativeStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Abstract.PlatformDependantNativeStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Win32Struct.WindowsObjectAttributes\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.WindowsUnicodeString\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
InsightSheath.Debugging.Thread.Wow64Context\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Debugging.DebugEventStaticContainer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
InsightSheath.Debugging.DebugEvent\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventCreateProcessInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventCreateThreadInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventExceptionInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventExitProcessInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventExitThreadInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventLoadDllInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventRipInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventStringInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.DebugEventUnloadDllInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
InsightSheath.Debugging.Process.InsightMemory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Process.InsightProcess\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.SymbolEngine.InsightHunter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.SymbolEngine.SymbolInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Thread.ThreadContext\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.StartupInfoExW\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
InsightSheath.Telemetry.LARGE_INTEGER\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.ObjectAttributes32\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.ObjectAttributes64\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Process.ProcessMemoryCount32\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Process.ProcessMemoryCount64\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_INFORMATION\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Process.QueryWorkingStructs\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Misc.ReferenceCounter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.SymbolEngine.SourceFile\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.UnicodeString32\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.UnicodeString64\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.UserProcessParameters32\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.UserProcessParameters64\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Win32Struct.WindowsUserProcessParameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Thread.Wow64ContextLayout\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b InsightSheath.Debugging.SymbolEngine.API_VERSION} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b API_VERSION} struct for DebugHelp symbol library. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEvent} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This encapsulates the Native {\b DebugEvent} structure via calling exported C routines in InsightAPI.dll. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventCreateProcessInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventCreateThreadInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventExceptionInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class Wrapper dealing with extracting Exception information from a {\b DebugEvent}. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventExitProcessInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventExitThreadInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventLoadDllInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to a {\b DebugEventType.LoadDllEvent} in a {\b DebugEvent} struct })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventRipInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventStaticContainer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the basis of disposal the other {\b DebugEvent} classes use. Also exposes routines to read the ProcessID and ThreadID that triggered the event })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventStringInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to process specific {\b DebugEventType.OutputDebugString} components. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.DebugEventUnloadDllInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} for Api Version struture. Note: Impementation in Insight has the struct as part of it, you DON'T want to free any pointer to it you get from insite. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Misc.EventDebugAssist} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements an event debugger system for processing events. You will need to link a way to call {\b EventDebugAssist.FireEvents(DebugEvent)} in order to actually make to the thing work })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.GeneralTelemtryHelperStruct} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General common values/code between the telemetry reader code. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.GenericTelemetryException} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.SymbolEngine.InsightHunter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A part of the symbol engine exported in InsightAPI in the Native DLL. This class is VERY VERY VERY tightly coupled with the InsightProcess class but distinct enough to warrent its own class/wrapper wrappers. If you need not have symbol processing, disabling InsightProcess.EnableSymbolEngine is set to false if fine. That turns off the code that updates the native {\b InsightHunter} class when the worker thread receives a debug event NOTE: You'll need to spawn at least one process with InsightProcess to get much use out of this. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.InsightMemory} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory data about an arbitrary process of your choice })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.InsightProcess} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
choose an environment and spawn a process. This class is a wrapper for the C++ Class named "InsightProcess" implemented as a native DLL in the source PS_ProcessInformation.cpp and said class is the functionally the heart of the DLL. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.IoDeviceTelemetyCreateFile} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This structure contains data from an exception generated via CreateFileA/W. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Telemetry.LARGE_INTEGER} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Large structure for getting {\b LARGE_INTEGER} structs into .Net Hands })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Abstract.NativeStaticContainer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/C++'s free(). If said Native class needs special free requirements, overwrite {\b Dispose(bool)} with a a call to a routine to properly free it. If your wrapper is handing out multiple natiove pointers to the same object, you'll need something like {\b ReferenceCounterNativeStaticContainer} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.ObjectAttributes32} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a Wow / x86 bit process. Specs from  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.ObjectAttributes64} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a 64-bit process Specs from  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Abstract.PlatformDependantNativeStruct} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.ProcessMemoryCount32} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 32-bit process })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.ProcessMemoryCount64} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 64-bit process })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_INFORMATION} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Process.QueryWorkingStructs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Misc.ReferenceCounter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
USed by the ReferenceCounterNativeStaticContainer to track and change a reference. This is primary used by the DebugEvent class collection as we're handing out Multiple REferences to the same Native Pointer like candy and need to take steps to prevent users of the library from prematuring freeing the same sheath })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Abstract.ReferenceCounterNativeStaticContainer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class contains an {\b AddRef()}/ {\b Release()} component for child classes. Destructors(), Call {\b Release()} and if that returns 0, free as appropriate. Not needed if the class itself is a 1 to 1 ie Sheath class pointer that contains one pointer, this can skip. Sheath, DebugEvent classes have this in the change, because they give out multiple references to a native class like candy. Each multiple class in the sheath points to a single native class. when the sheath class is freed(), })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.SymbolEngine.SourceFile} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.StartupInfoExW} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for the {\b StartupInfoExW} struct handler exported in InsightApi.dll. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.SymbolEngine.SymbolInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} imported for dealing with SymbolInfoW Native structures. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Thread.ThreadContext} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ThreadContext} is a class indented for reading/writing information about threads receives in the main InsightProcess structure We duplicate some of the functionality of the ProcessThread class for C# user familiarity. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.UnicodeString32} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processed that are Wow/32- bit this is what our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from either a local native pointer or remote/other process. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.UnicodeString64} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processes that are 64-bit, this is our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from a source. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.UserProcessParameters32} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x86 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.UserProcessParameters64} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x64 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.WindowsObjectAttributes} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
made from specs here  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.WindowsUnicodeString} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates both a {\b UnicodeString32} or {\b UnicodeString64} and lets one indicate which one to use based on {\b WindowsUnicodeString.StructType} You can use HelperRoutines.GetPEMachineType(string) on the process your dealing with to find what value was set as the machine type })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Win32Struct.WindowsUserProcessParameter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Thread.Wow64Context} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Thread.Wow64ContextLayout} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handler for reading from / writing to a Wow64ContextString })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b MemoryNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Utility.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Abstracts/{\b NativeStaticContainer.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Abstracts/{\b OnDemandMarshalNativeStruct.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Abstracts/{\b PlatformDependantNativeStruct.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Abstracts/{\b ReferenceCounterNativeStaticContainer.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/{\b DebugEvent.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/{\b DebugEventWorkerThreadSupport.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Process/{\b InsightMemory.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Process/{\b InsightProcess.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Process/{\b ProcessMemoryCount_x64.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Process/{\b ProcessMemoryCount_x86.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Process/{\b PSAPI_WORKING_SET_INFORMATION.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Process/{\b QueryWorkingStructs.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/SymbolEngine/{\b DebugHelp_ApiVersionStruct.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/SymbolEngine/{\b InsightHunter.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/SymbolEngine/{\b PSourceFileStruct.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/SymbolEngine/{\b SymbolInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Thread/{\b ThreadContext.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Debugging/Thread/{\b Wow64Context.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Misc/{\b EventDebug.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Misc/{\b ReferenceCounter.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/{\b DetoursNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/{\b ImageHlpNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/{\b MemoryNativeInternal.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/{\b UtilityNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/{\b DebugEventNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/Process/{\b InsightMemoryNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/Process/{\b InsightProcessNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/SymbolEngine/{\b ApiVersionStructNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/SymbolEngine/{\b InsightHunterNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/SymbolEngine/{\b SymbolInfoNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Debugging/Thread/{\b ThreadContextNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Win32Struct/{\b StartupInfoExWNative.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b NativeImports/Win32Struct/Remote/{\b RemoteStructureNatives.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debug/net5.0/{\b .NETCoreApp,Version=v5.0.AssemblyAttributes.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debug/net5.0/{\b FileSandBoxSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debug/net5.0/{\b InsightSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debug64/net5.0/{\b .NETCoreApp,Version=v5.0.AssemblyAttributes.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debug64/net5.0/{\b InsightSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debugx64/net5.0/{\b .NETCoreApp,Version=v5.0.AssemblyAttributes.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Debugx64/net5.0/{\b InsightSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Release/net5.0/{\b .NETCoreApp,Version=v5.0.AssemblyAttributes.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Release/net5.0/{\b FileSandBoxSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Release/net5.0/{\b InsightSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Release64/net5.0/{\b .NETCoreApp,Version=v5.0.AssemblyAttributes.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b obj/Release64/net5.0/{\b InsightSheath.AssemblyInfo.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Telemetry/{\b AntiDebuggerReader.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Telemetry/{\b GeneralTelemetry.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Telemetry/{\b GenericTelemetryException.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Telemetry/{\b IoDeviceTelemetryReader.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b ObjectAttributes_x64.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b ObjectAttributes_x86.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b StartupInfoExW.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b UserProcessParameters_x64.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b UserProcessParameters_x86.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b WindowsObjectAttributes.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b WindowsUnicodeString.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/{\b WindowsUserProcessParameter.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Win32Struct/Remote/{\b RemoteStructure.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Wrappers/{\b Detours.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath}
{\xe \v InsightSheath}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Abstract}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Misc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NativeImports}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Telemetry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Win32Struct}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Wrappers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HelperRoutines}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class contains various miscellaneous routines that while not tied directly to the library's purpose, they are used throughout the Sheath and wrappers. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemoryNative}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read and write to native memory via Peek and Poke routines. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MachineType} \{ {\b MachineInvalid} = 0
, {\b MachineI386} = 0x014c
, {\b MachineIA64} = 0x0200
, {\b MachineAmd64} = 0x8664
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Machine Type values extractable }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v MachineType\:InsightSheath}
{\xe \v InsightSheath\:MachineType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.MachineType}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Machine Type values extractable }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MachineInvalid\:InsightSheath}
{\xe \v InsightSheath\:MachineInvalid}
{\qr MachineInvalid{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returned on error with HelperRoutines.GetPEMachineType(string) \par
}\cell }{\row }
{\xe \v MachineI386\:InsightSheath}
{\xe \v InsightSheath\:MachineI386}
{\qr MachineI386{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
x86 based \par
}\cell }{\row }
{\xe \v MachineIA64\:InsightSheath}
{\xe \v InsightSheath\:MachineIA64}
{\qr MachineIA64{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intel Itanium based \par
}\cell }{\row }
{\xe \v MachineAmd64\:InsightSheath}
{\xe \v InsightSheath\:MachineAmd64}
{\qr MachineAmd64{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
x64 based \par
}\cell }{\row }
}
{
Definition at line {\b 15} of file {\b Utility.cs}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Abstract Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Abstract}
{\xe \v InsightSheath.Abstract}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NativeStaticContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/C++'s free(). If said Native class needs special free requirements, overwrite {\b Dispose(bool)} with a a call to a routine to properly free it. If your wrapper is handing out multiple natiove pointers to the same object, you'll need something like {\b ReferenceCounterNativeStaticContainer} }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b OnDemandMarshalNativeStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PlatformDependantNativeStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ReferenceCounterNativeStaticContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class contains an {\b AddRef()}/ {\b Release()} component for child classes. Destructors(), Call {\b Release()} and if that returns 0, free as appropriate. Not needed if the class itself is a 1 to 1 ie Sheath class pointer that contains one pointer, this can skip. Sheath, DebugEvent classes have this in the change, because they give out multiple references to a native class like candy. Each multiple class in the sheath points to a single native class. when the sheath class is freed(), }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging}
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Process}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b SymbolEngine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Thread}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This encapsulates the Native {\b DebugEvent} structure via calling exported C routines in InsightAPI.dll. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventCreateProcessInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventCreateThreadInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventExceptionInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class Wrapper dealing with extracting Exception information from a {\b DebugEvent}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventExitProcessInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventExitThreadInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventLoadDllInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to a {\b DebugEventType.LoadDllEvent} in a {\b DebugEvent} struct }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventRipInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventStaticContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the basis of disposal the other {\b DebugEvent} classes use. Also exposes routines to read the ProcessID and ThreadID that triggered the event }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventStringInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to process specific {\b DebugEventType.OutputDebugString} components. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventUnloadDllInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventWorkerThreadSupport}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you are wanting to control your debug message pump on the .NET side rather than native (why?), then these routines will help you glue everything together. This class exists only in the sheath and is not duplicated in Native. Some routines here may be echoed in other classes in the sheath Some of the routines here exist as extensions to {\b DebugEvent} }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DebugExceptionInPage_Type} \{ {\b ReadException} = 0
, {\b WriteException} = 1
, {\b DepException} = 8
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of In Page exception flags. You can check if the exception is that at DebugEventExceptionInfo.ExceptionCode }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DebugExceptionTypes} : uint \{ {\b AccessViolation} = 0xC0000005
, {\b ArrayBoundsExceeded} = 0xC000008C
, {\b Breakpoint} = 0x80000003
, {\b Datatyp_Misalighment} = 0x80000002
, {\b FloatPoint_Denormal_Operand} = 0xC000008D
, {\b Float_DivideByZero} = 0xC000008E
, {\b Float_InexactResult} = 0xC000008F
, {\b Float_Overflow} = 0xC0000091
, {\b Float_StackCheck} = 0xC0000092
, {\b Float_Underflow} = 0xC0000093
, {\b IllegalInstrution} = 0xC000001D
, {\b InPageError} = 0xC0000006
, {\b Int_DivideByZero} = 0xC0000094
, {\b Int_Overflow} = 0xC0000095
, {\b InvalidDisposition} = 0xC0000026
, {\b NonContinuableException} = 0xC0000025
, {\b PrivInstruction} = 0xC0000096
, {\b StackOverflow} = 0xC00000FD
, {\b DebugConsoleControlC} = 0xC000013A
, {\b InvalidHandleCloseException} = 0xC0000008
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum for the exceptions specifies within the MSDN documentation. NOT EXHAUSTIVE. Sourced from minwinbase.h in Visual studio }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DebugEventType} \{ {\b ExceptionEvent} = 1
, {\b CreateTheadEvent} = 2
, {\b CreateProcessEvent} = 3
, {\b ExitThreadEvent} = 4
, {\b ExitProcessEvent} = 5
, {\b LoadDllEvent} = 6
, {\b UnloadDllEvent} = 7
, {\b OutputDebugString} = 8
, {\b RipEvent} = 9
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helpful enum for the various debug event types. Also specifies which C# class will assist in reading the event's data. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b RipErrorType} \{ {\b SleNoType} = 0
, {\b SleError} = 0x00000001
, {\b SleMinorError} = 0x00000002
, {\b SleWarning} = 0x00000003
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of error that is contained DebugEventRipInfo.ErrorType }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v DebugEventType\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:DebugEventType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.DebugEventType}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helpful enum for the various debug event types. Also specifies which C# class will assist in reading the event's data. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ExceptionEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:ExceptionEvent}
{\qr ExceptionEvent{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is an exception. {\b DebugEventExceptionInfo} \par
}\cell }{\row }
{\xe \v CreateTheadEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:CreateTheadEvent}
{\qr CreateTheadEvent{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is a create thread. {\b DebugEventCreateThreadInfo} \par
}\cell }{\row }
{\xe \v CreateProcessEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:CreateProcessEvent}
{\qr CreateProcessEvent{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is a create process event. {\b DebugEventCreateProcessInfo} \par
}\cell }{\row }
{\xe \v ExitThreadEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:ExitThreadEvent}
{\qr ExitThreadEvent{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is an exit thread event. {\b DebugEventExitThreadInfo} \par
}\cell }{\row }
{\xe \v ExitProcessEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:ExitProcessEvent}
{\qr ExitProcessEvent{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is a exit process event. {\b DebugEventExitProcessInfo} \par
}\cell }{\row }
{\xe \v LoadDllEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:LoadDllEvent}
{\qr LoadDllEvent{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is a load DLL event. {\b DebugEventLoadDllInfo} \par
}\cell }{\row }
{\xe \v UnloadDllEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:UnloadDllEvent}
{\qr UnloadDllEvent{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is unload DLL event. {\b DebugEventUnloadDllInfo} \par
}\cell }{\row }
{\xe \v OutputDebugString\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:OutputDebugString}
{\qr OutputDebugString{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is output debug string (can use RemoteStructure.RemoteReadDebugString(IntPtr, IntPtr) OR {\b DebugEventStringInfo} which does this for you \par
}\cell }{\row }
{\xe \v RipEvent\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:RipEvent}
{\qr RipEvent{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Event is System RIP Debug Event {\b DebugEventRipInfo} \par
}\cell }{\row }
}
{
Definition at line {\b 141} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugExceptionInPage_Type\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:DebugExceptionInPage_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.DebugExceptionInPage_Type}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of In Page exception flags. You can check if the exception is that at {\b DebugEventExceptionInfo.ExceptionCode} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file provides a wrapper between c# and the InsightApi.Dll that deals with the debug event structure. The base class {\b DebugEventStaticContainer} is the root for the other classes in this file. It handles holding an IntPtr that represents the unmanaged DEBUG_EVENT structure. This pointer gets passes to various routines in the InsightApi.Dll DLL which then return data bases on that pointer - usually about the DEBUG_EVENT struct. Each DEBUG_EVENT in the MSDN documentation has its own C# class {\b DebugEventType} About Exceptions The MSDN documentation has certain exceptions listed. Those have been added to the {\b DebugExceptionTypes} enum. That's not actually exhaustive. winbase.h lists MANY MANY MANY more. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ReadException\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:ReadException}
{\qr ReadException{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Target process thread with the {\b DebugExceptionTypes.InPageError} tried reading something it's not allowed too \par
}\cell }{\row }
{\xe \v WriteException\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:WriteException}
{\qr WriteException{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Target process thread with the {\b DebugExceptionTypes.InPageError} tried writing to something it's not allowed too \par
}\cell }{\row }
{\xe \v DepException\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:DepException}
{\qr DepException{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Target process thread had a user mode DEP violation. \par
}\cell }{\row }
}
{
Definition at line {\b 31} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugExceptionTypes\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:DebugExceptionTypes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.DebugExceptionTypes} : uint}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum for the exceptions specifies within the MSDN documentation. NOT EXHAUSTIVE. Sourced from minwinbase.h in Visual studio }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AccessViolation\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:AccessViolation}
{\qr AccessViolation{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Target tried reading/ writing to virtual memory it is not allowed too. \par
}\cell }{\row }
{\xe \v ArrayBoundsExceeded\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:ArrayBoundsExceeded}
{\qr ArrayBoundsExceeded{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Target tried accessing an array element that's out of bounds (hardware supported bounds checking? according to MSDN documentation) \par
}\cell }{\row }
{\xe \v Breakpoint\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Breakpoint}
{\qr Breakpoint{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hit a breakpoint in the target. Important! Windows will generate a breakpoint once its finished loading the process before sending your first debugger message to you. \par
}\cell }{\row }
{\xe \v Datatyp_Misalighment\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Datatyp_Misalighment}
{\qr Datatyp_Misalighment{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tread in the target attempting to read misaligned data \par
}\cell }{\row }
{\xe \v FloatPoint_Denormal_Operand\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:FloatPoint_Denormal_Operand}
{\qr FloatPoint_Denormal_Operand{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSDN: float point operation resulted in a value to small to be represented. \par
}\cell }{\row }
{\xe \v Float_DivideByZero\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Float_DivideByZero}
{\qr Float_DivideByZero{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Float division by zero \par
}\cell }{\row }
{\xe \v Float_InexactResult\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Float_InexactResult}
{\qr Float_InexactResult{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSDN Can't represent a float as a decimal fraction precisely \par
}\cell }{\row }
{\xe \v Float_Overflow\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Float_Overflow}
{\qr Float_Overflow{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
float's exponent is too big \par
}\cell }{\row }
{\xe \v Float_StackCheck\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Float_StackCheck}
{\qr Float_StackCheck{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Float point value over or underflowed after an operation \par
}\cell }{\row }
{\xe \v Float_Underflow\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Float_Underflow}
{\qr Float_Underflow{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Float point is less that the magnitude allowed \par
}\cell }{\row }
{\xe \v IllegalInstrution\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:IllegalInstrution}
{\qr IllegalInstrution{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalid instruction attempted \par
}\cell }{\row }
{\xe \v InPageError\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:InPageError}
{\qr InPageError{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSDN: {\b Thread} tried to access a page that's not present and system couldn't load page \par
}\cell }{\row }
{\xe \v Int_DivideByZero\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Int_DivideByZero}
{\qr Int_DivideByZero{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Int divide by zero \par
}\cell }{\row }
{\xe \v Int_Overflow\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:Int_Overflow}
{\qr Int_Overflow{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inter overflowed the most significant bit \par
}\cell }{\row }
{\xe \v InvalidDisposition\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:InvalidDisposition}
{\qr InvalidDisposition{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception handled returned invalid disposition \par
}\cell }{\row }
{\xe \v NonContinuableException\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:NonContinuableException}
{\qr NonContinuableException{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception triggered when attempting to continue an exception that says that's not possible \par
}\cell }{\row }
{\xe \v PrivInstruction\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:PrivInstruction}
{\qr PrivInstruction{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempt to execute instructions that aren't allowed in the current machine mode \par
}\cell }{\row }
{\xe \v StackOverflow\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:StackOverflow}
{\qr StackOverflow{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
target used up its stack \par
}\cell }{\row }
{\xe \v DebugConsoleControlC\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:DebugConsoleControlC}
{\qr DebugConsoleControlC{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Console Window/Application: CTRL-C pressed the debugged application \par
}\cell }{\row }
{\xe \v InvalidHandleCloseException\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:InvalidHandleCloseException}
{\qr InvalidHandleCloseException{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is generated by Kernel32's CloseHandle() when an invalid handle is attempting to be closed in the process being debuggefd. \par
 IMPORTANT. How you handle this depends if you're debugging / learning about a target. If it's debug resistant (for example malware), your debugger is NOT going to want to mark that exception as being handled as then it likely will have just revealed itself. \par
}\cell }{\row }
}
{
Definition at line {\b 50} of file {\b DebugEvent.cs}.}\par
}
{\xe \v RipErrorType\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:RipErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.RipErrorType}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of error that is contained {\b DebugEventRipInfo.ErrorType} }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v SleNoType\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:SleNoType}
{\qr SleNoType{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only Error value was set \par
}\cell }{\row }
{\xe \v SleError\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:SleError}
{\qr SleError{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalid data passed to function what caused debugged application to fail \par
}\cell }{\row }
{\xe \v SleMinorError\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:SleMinorError}
{\qr SleMinorError{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalid data passed to a function maybe won't cause the application to fail \par
}\cell }{\row }
{\xe \v SleWarning\:InsightSheath.Debugging}
{\xe \v InsightSheath.Debugging\:SleWarning}
{\qr SleWarning{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Potentially Invalid data passed to a function but function finished any. \par
}\cell }{\row }
}
{
Definition at line {\b 185} of file {\b DebugEvent.cs}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process}
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightMemory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory data about an arbitrary process of your choice }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightProcess}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
choose an environment and spawn a process. This class is a wrapper for the C++ Class named "InsightProcess" implemented as a native DLL in the source PS_ProcessInformation.cpp and said class is the functionally the heart of the DLL. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ProcessMemoryCount32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 32-bit process }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ProcessMemoryCount64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 64-bit process }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b PSAPI_WORKING_SET_EX_BLOCK}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block} }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PSAPI_WORKING_SET_EX_INFORMATION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QueryWorkingStructs}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DebugContState} : uint \{ {\b DebugContinueState} = 0x00010002
, {\b DebugExceptionNotHandled} = 0x80010001
, {\b DebugExceptionReplyLater} = 0x40010001
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum to control how to return control of a debugged process your debugger is respending too back to Windows. Used in several spots. InsightProcess, DebugEventWorkerThreadSupport }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DebugModeType} \{ {\b NoWorkerThread} = 0
, {\b WorkerThread} = 1
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags to indicate to InsightProcess if you want the worker thread or not. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v DebugContState\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:DebugContState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.Process.DebugContState} : uint}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum to control how to return control of a debugged process your debugger is respending too back to Windows. Used in several spots. {\b InsightProcess}, DebugEventWorkerThreadSupport }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DebugContinueState\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:DebugContinueState}
{\qr DebugContinueState{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The event was processed OK and program execution can continue safely (Use to continue all events and if an Exception Was Handled \par
}\cell }{\row }
{\xe \v DebugExceptionNotHandled\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:DebugExceptionNotHandled}
{\qr DebugExceptionNotHandled{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Exception Was not handled at all by the your debugger, pass it back to the debugged program \par
}\cell }{\row }
{\xe \v DebugExceptionReplyLater\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:DebugExceptionReplyLater}
{\qr DebugExceptionReplyLater{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I'm sorry, I'm not in right now to deal with this exception. Tells Windows to reply the event later. \par
}\cell }{\row }
}
{
Definition at line {\b 18} of file {\b InsightProcess.cs}.}\par
}
{\xe \v DebugModeType\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:DebugModeType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.Process.DebugModeType}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags to indicate to {\b InsightProcess} if you want the worker thread or not. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NoWorkerThread\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:NoWorkerThread}
{\qr NoWorkerThread{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells Insight's native DLL to Not Spawn any worker threads for debug handling. If you don't implement a debug loop, you will never see your process show up. Irrelevant if the process is not being debugged. You're going to want the WorkerThread as development features in this thread are not exported yet for use without the worker thread. \par
}\cell }{\row }
{\xe \v WorkerThread\:InsightSheath.Debugging.Process}
{\xe \v InsightSheath.Debugging.Process\:WorkerThread}
{\qr WorkerThread{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When Spawning a process for debugger, InsightApi.DLL implements a debug loop and offloads the loop to a worker thread. Put a call to {\b InsightProcess.PulseDebugEventThead} to continue after handling your debug event on a regular basis. Skipping that means, your debugged process won't continue after the first event. \par
}\cell }{\row }
}
{
Definition at line {\b 38} of file {\b InsightProcess.cs}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.SymbolEngine Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine}
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b API_VERSION}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b API_VERSION} struct for DebugHelp symbol library. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugHelp_ApiVersionStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} for Api Version struture. Note: Impementation in Insight has the struct as part of it, you DON'T want to free any pointer to it you get from insite. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightHunter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A part of the symbol engine exported in InsightAPI in the Native DLL. This class is VERY VERY VERY tightly coupled with the InsightProcess class but distinct enough to warrent its own class/wrapper wrappers. If you need not have symbol processing, disabling InsightProcess.EnableSymbolEngine is set to false if fine. That turns off the code that updates the native {\b InsightHunter} class when the worker thread receives a debug event NOTE: You'll need to spawn at least one process with InsightProcess to get much use out of this. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SourceFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SymbolInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} imported for dealing with SymbolInfoW Native structures. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SymbolTagType} : uint \{ {\b Null} = 0
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Should be from the SymTagEnum at MSDN {\f2 https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/bkedss5f(v=vs.100)} }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SymbolFlags} : uint \{ {\b ClrToken} = 0x00040000
, {\b Constant} = 0x00000100
, {\b Export} = 0x00000200
, {\b Forwarder} = 0x00000400
, {\b FrameRel} = 0x00000020
, {\b Function} = 0x00000800
, {\b IrlRel} = 0x00010000
, {\b Local} =0x00000080
, {\b Metadata} = 0x00020000
, {\b Parameter} = 0x00000040
, {\b Register} = 0x00000008
, {\b Regrel} = 0x00000010
, {\b Slot} = 0x00008000
, {\b Thunk} = 0x00002000
, {\b TlsRel} = 0x00004000
, {\b ValuePresent} = 0x00000001
, {\b Virtual} = 0x00001000
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate bool {\b InsightHunter_SymbolSearchCallBackRoutine} (IntPtr {\b SymbolInfo})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the callback for {\b InsightHunter.EnumerateSymbols(string, InsightHunter_SymbolSearchCallBackRoutine)}. The passed pointer to your routine is a native pointer to a struct {\b SymbolInfo}'s that exists for while your routine is active. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate bool {\b InsightHunter_SymbolSourceCallbackRoutine} (IntPtr SourceInfo)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback for Enumerating source files. Return true to continue and false to quit. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v SymbolFlags\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:SymbolFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.SymbolEngine.SymbolFlags} : uint}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ClrToken\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:ClrToken}
{\qr ClrToken{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a CLR token. \par
}\cell }{\row }
{\xe \v Constant\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Constant}
{\qr Constant{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a constant. \par
}\cell }{\row }
{\xe \v Export\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Export}
{\qr Export{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is from the export table. \par
}\cell }{\row }
{\xe \v Forwarder\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Forwarder}
{\qr Forwarder{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a forwarder. \par
}\cell }{\row }
{\xe \v FrameRel\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:FrameRel}
{\qr FrameRel{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Offsets are frame relative. \par
}\cell }{\row }
{\xe \v Function\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Function}
{\qr Function{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a known function. \par
}\cell }{\row }
{\xe \v IrlRel\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:IrlRel}
{\qr IrlRel{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol address is an offset relative to the beginning of the intermediate language block. This applies to managed code only. \par
}\cell }{\row }
{\xe \v Local\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Local}
{\qr Local{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a local variable. \par
}\cell }{\row }
{\xe \v Metadata\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Metadata}
{\qr Metadata{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is managed meta data. \par
}\cell }{\row }
{\xe \v Parameter\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Parameter}
{\qr Parameter{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a parameter. \par
}\cell }{\row }
{\xe \v Register\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Register}
{\qr Register{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a register. The Register member is used. \par
}\cell }{\row }
{\xe \v Regrel\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Regrel}
{\qr Regrel{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Offsets are register relative. \par
}\cell }{\row }
{\xe \v Slot\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Slot}
{\qr Slot{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a managed code slot. \par
}\cell }{\row }
{\xe \v Thunk\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Thunk}
{\qr Thunk{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a thunk. \par
}\cell }{\row }
{\xe \v TlsRel\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:TlsRel}
{\qr TlsRel{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is an offset into the TLS data area. \par
}\cell }{\row }
{\xe \v ValuePresent\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:ValuePresent}
{\qr ValuePresent{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Value member is used. \par
}\cell }{\row }
{\xe \v Virtual\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Virtual}
{\qr Virtual{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbol is a virtual symbol created by the SymAddSymbol function. \par
 \par
}\cell }{\row }
}
{
Definition at line {\b 20} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolTagType\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:SymbolTagType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.SymbolEngine.SymbolTagType} : uint}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Should be from the SymTagEnum at MSDN {\f2 https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/bkedss5f(v=vs.100)} }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Null\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:Null}
{\qr Null{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 15} of file {\b SymbolInfo.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InsightHunter_SymbolSearchCallBackRoutine\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:InsightHunter_SymbolSearchCallBackRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate bool InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSearchCallBackRoutine (IntPtr  {\i SymbolInfo})}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the callback for {\b InsightHunter.EnumerateSymbols(string, InsightHunter_SymbolSearchCallBackRoutine)}. The passed pointer to your routine is a native pointer to a struct {\b SymbolInfo}'s that exists for while your routine is active. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Your Routine should return TRUE to keep going and FALSE to quit\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}The exact routine pointer that this is based off is typedef BOOL (WINAPI* SymbolSearchCallback)(SYMBOL_INFOW); MSDC documentation for the callback being invoked here:  and the API being called is  \par
}}
{\xe \v InsightHunter_SymbolSourceCallbackRoutine\:InsightSheath.Debugging.SymbolEngine}
{\xe \v InsightSheath.Debugging.SymbolEngine\:InsightHunter_SymbolSourceCallbackRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate bool InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSourceCallbackRoutine (IntPtr  {\i SourceInfo})}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback for Enumerating source files. Return true to continue and false to quit. }}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Thread Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Thread}
{\xe \v InsightSheath.Debugging.Thread}
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadContext}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ThreadContext} is a class indented for reading/writing information about threads receives in the main InsightProcess structure We duplicate some of the functionality of the ProcessThread class for C# user familiarity. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Wow64Context}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Wow64ContextLayout}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handler for reading from / writing to a Wow64ContextString }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Wow64FloatingPointSaveArea}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Misc Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Misc}
{\xe \v InsightSheath.Misc}
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EventDebugAssist}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements an event debugger system for processing events. You will need to link a way to call {\b EventDebugAssist.FireEvents(DebugEvent)} in order to actually make to the thing work }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ReferenceCounter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
USed by the ReferenceCounterNativeStaticContainer to track and change a reference. This is primary used by the DebugEvent class collection as we're handing out Multiple REferences to the same Native Pointer like candy and need to take steps to prevent users of the library from prematuring freeing the same sheath. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.NativeImports Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.NativeImports}
{\xe \v InsightSheath.NativeImports}
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugEventNative}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in DebugEvent class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DebugHelpApiVersionStructInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in DebugHelp_ApiVersionStruct }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightHunterInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in InsightHunter class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightProcessInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. Contains the routines imported from InsightAPI.DLL for use in the InsightProcess class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InternalInsightMemory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. Contains the routines imported from InsightAPI.DLL for use in the InsightMemory class. Not really planned to be accessible outside of this project. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemoryNativeInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. Imports the Poke/Peek routines for both remote and local }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NativeMethods}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RemoteStructureInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in RemoteStructure class exports }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StartupInfoExWInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in StartupInfoExW class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SymbolInfoInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in SymbolInfo class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadContextInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in ThreadContext class }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry}
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AntiDebuggerReaderExtensions}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class includes code to read exceptions generated via the AntiDebugger telemetry. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AntiDebuggerReaderExtentionCheckers}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class includes extentions to check if the exception in the DebugEvent is the correct type }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CheckRemoteDebuggerPresentSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GeneralTelemetry}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
holds some common defines between the included telemetry projects. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GeneralTelemtryHelperStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General common values/code between the telemetry reader code. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GenericTelemetryException}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IoDeviceTelememtryExceptionCommonValues}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IoDeviceTelemetryExceptionExtensionsCheckers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IoDeviceTelemetryNtCreateFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IoDeviceTelemetryReaderExtensions}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Exception from the debug event struct that was generated via the IoException {\b Telemetry} DLL. This class should contain code to read exceptions generated from telemetry dll IoDeviceTelemetry }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IoDeviceTelemetyCreateFile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This structure contains data from an exception generated via CreateFileA/W. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LARGE_INTEGER}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Large structure for getting {\b LARGE_INTEGER} structs into .Net Hands }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b NtCreationDisposition} : uint \{ {\b Supersede} = 0x00000000
, {\b Open} = 0x00000001
, {\b Create} = 0x00000002
, {\b OpenIf} = 0x00000003
, {\b Overwrite} = 0x00000004
, {\b OverwriteIf} = 0x00000005
, {\b MaxDisposition} = 0x00000005
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From once again winnt.h for values.  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CreationDisposition} : uint \{ {\b CreateNew} = 1
, {\b CreateAlways} = 2
, {\b OpenExisting} = 3
, {\b OpenAlways} = 4
, {\b TruncateExisting} = 5
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Action to be taken by CreateFileA/W }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AccessMasks} : uint \{ {\b NoAccess} = 0
, {\b MetaData} = NoAccess
, {\b Delete} = 0x00010000
, {\b ReadControl} = 0x00020000
, {\b FileReadData} = 0x1
, {\b FileListDirectory} = FileReadData
, {\b FileReadAttributes} = 0x0080
, {\b FileReadEa} = 0x0008
, {\b FileWriteData} = 0x0002
, {\b FileWriteAttributes} = 0x0100
, {\b FileWriteEa} = 0x0010
, {\b FileAppendData} = 0x0004
, {\b WriteDac} = 0x00040000
, {\b WriteOwner} = 0x00080000
, {\b Synchronize} = 0x00100000
, {\b FileExecute} = 0x0020
, {\b FileTraverse} = FileExecute
, {\b GenericRead} = 0x80000000
, {\b GenericWrite} = 0x40000000
, {\b GenericExecute} = 0x20000000
, {\b GenericAll} = 0x10000000
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/262970b7-cd4a-41f4-8c4d-5a27f0092aaa, Windows SDK winnt.h and , these are the accessible flags }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ShareMasks} : uint \{ {\b NoShare} = 0
, {\b ShareDelete} = 0x00000004
, {\b ShareRead} = 0x00000001
, {\b ShareWrite} = 0x00000002
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Share mode for CreateFileA/W }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v AccessMasks\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:AccessMasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Telemetry.AccessMasks} : uint}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/262970b7-cd4a-41f4-8c4d-5a27f0092aaa, Windows SDK winnt.h and , these are the accessible flags }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NoAccess\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:NoAccess}
{\qr NoAccess{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSDN CreateFileA/W suggests meta data can be queried with opening for no access, hence the pair of these. \par
}\cell }{\row }
{\xe \v MetaData\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:MetaData}
{\qr MetaData{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSDN CreateFileA/W suggests meta data can be queried with opening for no access, hence the pair of these. \par
}\cell }{\row }
{\xe \v Delete\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:Delete}
{\qr Delete{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NtOpenFile/NtCreateFile DELETE Value from "winnt.h" \par
}\cell }{\row }
{\xe \v ReadControl\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:ReadControl}
{\qr ReadControl{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NtOpenFile/NtCreateFile READ_CONTROL value from "winnt.h" \par
}\cell }{\row }
{\xe \v FileReadData\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileReadData}
{\qr FileReadData{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreateFile Sourced from winnt.h \par
}\cell }{\row }
{\xe \v FileListDirectory\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileListDirectory}
{\qr FileListDirectory{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Same as FileReadData in winnt.h \par
}\cell }{\row }
{\xe \v FileReadAttributes\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileReadAttributes}
{\qr FileReadAttributes{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreateFile. Sourced from winnt.h. FileAttribute flags, can be set/read. \par
}\cell }{\row }
{\xe \v FileReadEa\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileReadEa}
{\qr FileReadEa{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreateFile Sourced from winnt.h \par
}\cell }{\row }
{\xe \v FileWriteData\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileWriteData}
{\qr FileWriteData{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreateFile Sourced from winnt.h \par
}\cell }{\row }
{\xe \v FileWriteAttributes\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileWriteAttributes}
{\qr FileWriteAttributes{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreateFile Sourced from winnt.h \par
}\cell }{\row }
{\xe \v FileWriteEa\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileWriteEa}
{\qr FileWriteEa{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreateFile Sourced from winnt.h \par
}\cell }{\row }
{\xe \v FileAppendData\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileAppendData}
{\qr FileAppendData{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreate file. From winnt.h. \par
}\cell }{\row }
{\xe \v WriteDac\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:WriteDac}
{\qr WriteDac{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreate file. From winnt.h. \par
}\cell }{\row }
{\xe \v WriteOwner\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:WriteOwner}
{\qr WriteOwner{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreate file. From winnt.h. \par
}\cell }{\row }
{\xe \v Synchronize\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:Synchronize}
{\qr Synchronize{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreate file. From winnt.h. \par
}\cell }{\row }
{\xe \v FileExecute\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileExecute}
{\qr FileExecute{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windows NtOpen/NtCreate file. From winnt.h. \par
}\cell }{\row }
{\xe \v FileTraverse\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:FileTraverse}
{\qr FileTraverse{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Same as FileExceute in winnt.h \par
}\cell }{\row }
{\xe \v GenericRead\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:GenericRead}
{\qr GenericRead{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GENERIC_READ / for read access \par
}\cell }{\row }
{\xe \v GenericWrite\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:GenericWrite}
{\qr GenericWrite{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GENERIC_WRITE / for write access \par
}\cell }{\row }
{\xe \v GenericExecute\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:GenericExecute}
{\qr GenericExecute{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GENERIC_EXECUTE / for execute access \par
}\cell }{\row }
{\xe \v GenericAll\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:GenericAll}
{\qr GenericAll{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic all / for all possible access \par
}\cell }{\row }
}
{
Definition at line {\b 122} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v CreationDisposition\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:CreationDisposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Telemetry.CreationDisposition} : uint}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Action to be taken by CreateFileA/W }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CreateNew\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:CreateNew}
{\qr CreateNew{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a new file if said target does not already exists \par
}\cell }{\row }
{\xe \v CreateAlways\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:CreateAlways}
{\qr CreateAlways{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates fil and truncates if file exists already, createfilea/w sets last error if truncating \par
}\cell }{\row }
{\xe \v OpenExisting\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:OpenExisting}
{\qr OpenExisting{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
open an existing file / device and fail if not found \par
}\cell }{\row }
{\xe \v OpenAlways\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:OpenAlways}
{\qr OpenAlways{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
open existing file / - attempts to create if not found \par
}\cell }{\row }
{\xe \v TruncateExisting\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:TruncateExisting}
{\qr TruncateExisting{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Open a file and truncate it to zero bytes long \par
}\cell }{\row }
}
{
Definition at line {\b 90} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v NtCreationDisposition\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:NtCreationDisposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Telemetry.NtCreationDisposition} : uint}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From once again winnt.h for values.  }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Supersede\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:Supersede}
{\qr Supersede{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IF File exists already, replace with this new file. If nonexistent, create it. \par
}\cell }{\row }
{\xe \v Open\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:Open}
{\qr Open{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If file exists, open it. If it does not exist, fail the request. \par
}\cell }{\row }
{\xe \v Create\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:Create}
{\qr Create{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the file exists, fail request. If it does not exist, create the file. \par
}\cell }{\row }
{\xe \v OpenIf\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:OpenIf}
{\qr OpenIf{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the file exists open it. Otherwise create it. \par
}\cell }{\row }
{\xe \v Overwrite\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:Overwrite}
{\qr Overwrite{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the file exists, open and truncate it. Otherwise fail request. \par
}\cell }{\row }
{\xe \v OverwriteIf\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:OverwriteIf}
{\qr OverwriteIf{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the file exists, open and truncate it. If it does not exist, create it. \par
}\cell }{\row }
{\xe \v MaxDisposition\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:MaxDisposition}
{\qr MaxDisposition{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 57} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v ShareMasks\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:ShareMasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Telemetry.ShareMasks} : uint}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Share mode for CreateFileA/W }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NoShare\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:NoShare}
{\qr NoShare{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Don't wanna share \par
}\cell }{\row }
{\xe \v ShareDelete\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:ShareDelete}
{\qr ShareDelete{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Share for delete requests only \par
}\cell }{\row }
{\xe \v ShareRead\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:ShareRead}
{\qr ShareRead{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Share for read access only \par
}\cell }{\row }
{\xe \v ShareWrite\:InsightSheath.Telemetry}
{\xe \v InsightSheath.Telemetry\:ShareWrite}
{\qr ShareWrite{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Share for write access only \par
}\cell }{\row }
}
{
Definition at line {\b 218} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct}
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Remote}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ObjectAttributes32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a Wow / x86 bit process. Specs from  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ObjectAttributes64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a 64-bit process Specs from  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StartupInfoExW}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for the {\b StartupInfoExW} struct handler exported in InsightApi.dll. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UnicodeString32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processed that are Wow/32- bit this is what our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from either a local native pointer or remote/other process. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UnicodeString64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processes that are 64-bit, this is our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from a source. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UserProcessParameters32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x86 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UserProcessParameters64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x64 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WindowsObjectAttributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
made from specs here  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WindowsUnicodeString}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates both a {\b UnicodeString32} or {\b UnicodeString64} and lets one indicate which one to use based on {\b WindowsUnicodeString.StructType} You can use HelperRoutines.GetPEMachineType(string) on the process your dealing with to find what value was set as the machine type }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WindowsUserProcessParameter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b StartupInfoExW_Flags} : uint \{ {\b Startf_ForceOnFeed} = 0x00000040
, {\b Startf_ForceOffFeedback} = 0x00000080
, {\b Startf_PreventPinning} = 0x00002000
, {\b Startf_RunFullScreen} = 0x00000020
, {\b Startf_TitleIsAppId} = 0x00001000
, {\b Startf_TitleIsLinkName} = 0x00000800
, {\b Startf_UntrustedSource} = 0x00008000
, {\b Startf_UseCountChars} = 0x00000008
, {\b Startf_UseFillAttribute} = 0x00000010
, {\b Startf_UseHotKey} = 0x00000200
, {\b Startf_UsePosition} = 0x00000004
, {\b Startf_UseShowWindow} = 0x00000001
, {\b Startf_UseSize} = 0x00000002
, {\b Startf_UseStdHandles} = 0x00000100
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See  entry for dwFlags for the meaning of these values. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b StartupInfoExW_ShowWindow} : ushort \{ {\b Hide} = 0
, {\b ShowNormal} = 1
, {\b Normal} = ShowNormal
, {\b ShowMinimized} = 2
, {\b ShowMaximized} = 3
, {\b Maximize} = ShowMaximized
, {\b ShowNoActivate} = 4
, {\b Show} = 5
, {\b Minimized} = 6
, {\b ShowMinNoActive} = 7
, {\b ShowNa} = 8
, {\b ShowRestore} = 9
, {\b ShowDefault} = 10
, {\b ForceMinimize} = 11
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lifted from  these let you specify how starting window will do }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b StructModeType} \{ {\b MachineUnknown} = 0
, {\b Machinex86} = 1
, {\b Machinex64} = 2
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum used by certain classes that encapsulate Native Structs that contain pointers whose size may not match {\i our}  pointer size. One will need to set the PlatformDependantNativeStruct.StructType in a child class to flag which version to use }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v StartupInfoExW_Flags\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:StartupInfoExW_Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Win32Struct.StartupInfoExW_Flags} : uint}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See  entry for dwFlags for the meaning of these values. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Startf_ForceOnFeed\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_ForceOnFeed}
{\qr Startf_ForceOnFeed{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
\cell }{\cell }{\row }
{\xe \v Startf_ForceOffFeedback\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_ForceOffFeedback}
{\qr Startf_ForceOffFeedback{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
\cell }{\cell }{\row }
{\xe \v Startf_PreventPinning\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_PreventPinning}
{\qr Startf_PreventPinning{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
\cell }{\cell }{\row }
{\xe \v Startf_RunFullScreen\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_RunFullScreen}
{\qr Startf_RunFullScreen{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
\cell }{\cell }{\row }
{\xe \v Startf_TitleIsAppId\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_TitleIsAppId}
{\qr Startf_TitleIsAppId{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
\cell }{\cell }{\row }
{\xe \v Startf_TitleIsLinkName\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_TitleIsLinkName}
{\qr Startf_TitleIsLinkName{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
\cell }{\cell }{\row }
{\xe \v Startf_UntrustedSource\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UntrustedSource}
{\qr Startf_UntrustedSource{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
\cell }{\cell }{\row }
{\xe \v Startf_UseCountChars\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UseCountChars}
{\qr Startf_UseCountChars{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
\cell }{\cell }{\row }
{\xe \v Startf_UseFillAttribute\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UseFillAttribute}
{\qr Startf_UseFillAttribute{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
\cell }{\cell }{\row }
{\xe \v Startf_UseHotKey\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UseHotKey}
{\qr Startf_UseHotKey{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
\cell }{\cell }{\row }
{\xe \v Startf_UsePosition\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UsePosition}
{\qr Startf_UsePosition{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
\cell }{\cell }{\row }
{\xe \v Startf_UseShowWindow\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UseShowWindow}
{\qr Startf_UseShowWindow{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
\cell }{\cell }{\row }
{\xe \v Startf_UseSize\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UseSize}
{\qr Startf_UseSize{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
\cell }{\cell }{\row }
{\xe \v Startf_UseStdHandles\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Startf_UseStdHandles}
{\qr Startf_UseStdHandles{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 17} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v StartupInfoExW_ShowWindow\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:StartupInfoExW_ShowWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Win32Struct.StartupInfoExW_ShowWindow} : ushort}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lifted from  these let you specify how starting window will do }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Hide\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Hide}
{\qr Hide{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
\cell }{\cell }{\row }
{\xe \v ShowNormal\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowNormal}
{\qr ShowNormal{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
\cell }{\cell }{\row }
{\xe \v Normal\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Normal}
{\qr Normal{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
\cell }{\cell }{\row }
{\xe \v ShowMinimized\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowMinimized}
{\qr ShowMinimized{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
\cell }{\cell }{\row }
{\xe \v ShowMaximized\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowMaximized}
{\qr ShowMaximized{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
\cell }{\cell }{\row }
{\xe \v Maximize\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Maximize}
{\qr Maximize{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
\cell }{\cell }{\row }
{\xe \v ShowNoActivate\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowNoActivate}
{\qr ShowNoActivate{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
\cell }{\cell }{\row }
{\xe \v Show\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Show}
{\qr Show{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
\cell }{\cell }{\row }
{\xe \v Minimized\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Minimized}
{\qr Minimized{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
\cell }{\cell }{\row }
{\xe \v ShowMinNoActive\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowMinNoActive}
{\qr ShowMinNoActive{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
\cell }{\cell }{\row }
{\xe \v ShowNa\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowNa}
{\qr ShowNa{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
\cell }{\cell }{\row }
{\xe \v ShowRestore\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowRestore}
{\qr ShowRestore{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
\cell }{\cell }{\row }
{\xe \v ShowDefault\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ShowDefault}
{\qr ShowDefault{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not supported for startup info. For ShowWindow MSDN it means use the startupinfo to specify how to display the Window \par
}\cell }{\row }
{\xe \v ForceMinimize\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:ForceMinimize}
{\qr ForceMinimize{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 39} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v StructModeType\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:StructModeType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Win32Struct.StructModeType}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum used by certain classes that encapsulate Native Structs that contain pointers whose size may not match {\i our}  pointer size. One will need to set the PlatformDependantNativeStruct.StructType in a child class to flag which version to use }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MachineUnknown\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:MachineUnknown}
{\qr MachineUnknown{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not defined. Attempting to access properties in this class will trigger InvalidOperationException asking programming to pick either Machinex64 or Machinex86 \par
}\cell }{\row }
{\xe \v Machinex86\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Machinex86}
{\qr Machinex86{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class encapsulates a 32 bit version of the native struct. For Example {\b WindowsUnicodeString} and {\b UnicodeString32} \par
}\cell }{\row }
{\xe \v Machinex64\:InsightSheath.Win32Struct}
{\xe \v InsightSheath.Win32Struct\:Machinex64}
{\qr Machinex64{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class encapsulates a 64- bit version of the native struct. For Example {\b WindowsUnicodeString} and {\b UnicodeString64} struct \par
}\cell }{\row }
}
{
Definition at line {\b 17} of file {\b WindowsUnicodeString.cs}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.Remote Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.Remote}
{\xe \v InsightSheath.Win32Struct.Remote}
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RemoteStructure}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Imports the RemoteRead and RemoteWrite structures for dealing with extracting data from the target process during various events. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Wrappers Namespace Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Wrappers}
{\xe \v InsightSheath.Wrappers}
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Detours}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intended for wrapps }}\par}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.SymbolEngine.API_VERSION Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.SymbolEngine.API_VERSION}
{\xe \v InsightSheath.Debugging.SymbolEngine.API_VERSION}
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b API_VERSION} struct for DebugHelp symbol library. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b MajorVersion}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Major Version of the API }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b MinorVersion}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minor Version of the API }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Revision}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Revision of the API }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Reserved}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reserved for future use }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b API_VERSION} struct for DebugHelp symbol library. \par
}{
Definition at line {\b 17} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v MajorVersion\:InsightSheath.Debugging.SymbolEngine.API_VERSION}
{\xe \v InsightSheath.Debugging.SymbolEngine.API_VERSION\:MajorVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.API_VERSION.MajorVersion}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Major Version of the API }}\par
{
Definition at line {\b 22} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\xe \v MinorVersion\:InsightSheath.Debugging.SymbolEngine.API_VERSION}
{\xe \v InsightSheath.Debugging.SymbolEngine.API_VERSION\:MinorVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.API_VERSION.MinorVersion}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minor Version of the API }}\par
{
Definition at line {\b 26} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\xe \v Reserved\:InsightSheath.Debugging.SymbolEngine.API_VERSION}
{\xe \v InsightSheath.Debugging.SymbolEngine.API_VERSION\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.API_VERSION.Reserved}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reserved for future use }}\par
{
Definition at line {\b 34} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\xe \v Revision\:InsightSheath.Debugging.SymbolEngine.API_VERSION}
{\xe \v InsightSheath.Debugging.SymbolEngine.API_VERSION\:Revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.API_VERSION.Revision}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Revision of the API }}\par
{
Definition at line {\b 30} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/SymbolEngine/{\b DebugHelp_ApiVersionStruct.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}
{\xe \v InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
Inheritance diagram for InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_telemetry_1_1_check_remote_debugger_present_settings.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CheckRemoteDebuggerPresentSettings} (uint {\b ProcessId}, uint ThreadID, IntPtr Forcehandle, IntPtr LastError, {\b MachineType} {\b Type})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b ReturnValue}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pointer to what's going to be returned from this call to CheckRemoteDebuggerPresent }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b Process}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Handle to the process that the debugged app is asking about. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b OutputBool}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pointer to the bool that will contain the results. Same as {\b ForceHandlePtr} }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 12} of file {\b AntiDebuggerReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CheckRemoteDebuggerPresentSettings\:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}
{\xe \v InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings\:CheckRemoteDebuggerPresentSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.CheckRemoteDebuggerPresentSettings (uint  {\i ProcessId}, uint  {\i ThreadID}, IntPtr  {\i Forcehandle}, IntPtr  {\i LastError}, {\b MachineType}  {\i Type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b AntiDebuggerReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Process\:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}
{\xe \v InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings\:Process}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.Process}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Handle to the process that the debugged app is asking about. }}\par
{
Definition at line {\b 23} of file {\b AntiDebuggerReader.cs}.}\par
}
{\xe \v ReturnValue\:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}
{\xe \v InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings\:ReturnValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.ReturnValue}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pointer to what's going to be returned from this call to CheckRemoteDebuggerPresent }}\par
{
Definition at line {\b 18} of file {\b AntiDebuggerReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v OutputBool\:InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}
{\xe \v InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings\:OutputBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings.OutputBool{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pointer to the bool that will contain the results. Same as {\b ForceHandlePtr} }}\par
{
Definition at line {\b 27} of file {\b AntiDebuggerReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b AntiDebuggerReader.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEvent Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This encapsulates the Native {\b DebugEvent} structure via calling exported C routines in InsightAPI.dll. }}\par
Inheritance diagram for InsightSheath.Debugging.DebugEvent:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEvent} (IntPtr NativePtr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creation. Does NOT free the underling pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEvent} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEvent} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateProcessInfo} {\b GetDebugEventCreateProcessInfo} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return an instance of the wrapper to deal with {\b DebugEventType.CreateProcessEvent} events. The class still points to the native struct and does not need to be freed(). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateThreadInfo} {\b GetDebugEventCreateThreadInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExceptionInfo} {\b GetDebugEventExceptionInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitProcessInfo} {\b GetEventExitProcessInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitThreadInfo} {\b GetEventExitThreadInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventLoadDllInfo} {\b GetDebugEventLoadDll} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStringInfo} {\b GetDebugEventStringInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventRipInfo} {\b GetDebugEventRipInfo} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get class suitable to reading DEBUG_EVENT_RIP_INFO from this class. Will throw InvalidOperationException if not the correct event }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventUnloadDllInfo} {\b GetDebugEventUnloadDllInfo} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DebugEvent} {\b CreatePrivateStruct} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You don't need to use this if the let the debugger code use the worker thread. You'll need to allocate a native block to hold the debug struct should you decide to roll your own }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This encapsulates the Native {\b DebugEvent} structure via calling exported C routines in InsightAPI.dll. \par
}{
Definition at line {\b 936} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEvent\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:DebugEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEvent.DebugEvent (IntPtr  {\i NativePtr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creation. Does NOT free the underling pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NativePtr} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 945} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEvent\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:DebugEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEvent.DebugEvent (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 951} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEvent\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:DebugEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEvent.DebugEvent (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 956} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CreatePrivateStruct\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:CreatePrivateStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b DebugEvent} InsightSheath.Debugging.DebugEvent.CreatePrivateStruct (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You don't need to use this if the let the debugger code use the worker thread. You'll need to allocate a native block to hold the debug struct should you decide to roll your own }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a new {\b DebugEvent} class instance with its own private native structure\par
}}}{
Definition at line {\b 965} of file {\b DebugEvent.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.DebugEvent.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources in addition to unmanaged.\cell }
{\row }
}
IMPORTANT! If your child class needs special needs beyond C/C++'s free(), override this and take care of them before calling base(). Should your custom class allocate multiple things for example WindowsUnicodeString's implementation for reading from remote processes Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(IntPtr, IntPtr, bool, bool), you will need to make a routine to properly free. That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory. Design checks: list type="number"> listheader> description > First, override disposal()  /listheader > item>  Nest, add a private variable in your class called isDisposed. Set this to true when your class's native pointer is cleaned up completely  /item > item> description>if {\b ReferenceCounterNativeStaticContainer} is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it. /item> item> description>if {\b ReferenceCounterNativeStaticContainer} IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null. If the reference counter is more than 0 when decreased, set native to null instead of disposing. /item> \par
}{
Reimplemented from {\b InsightSheath.Debugging.DebugEventStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 973} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventCreateProcessInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventCreateProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventCreateProcessInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventCreateProcessInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return an instance of the wrapper to deal with {\b DebugEventType.CreateProcessEvent} events. The class still points to the native struct and does not need to be freed(). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 990} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventCreateThreadInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventCreateThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventCreateThreadInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventCreateThreadInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1005} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventExceptionInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventExceptionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventExceptionInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventExceptionInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1021} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventLoadDll\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventLoadDll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventLoadDllInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventLoadDll (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1073} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventRipInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventRipInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventRipInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventRipInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get class suitable to reading DEBUG_EVENT_RIP_INFO from this class. Will throw InvalidOperationException if not the correct event }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InvalidOperationException} \cell }{Is thrown when the contained even is not a <see cref={\b DebugEventType.RipEvent}"/></exception>
<returns>If the contained event is <see cref="{\b DebugEventType.RipEvent}"/> returns a <see cref="{\b DebugEventRipInfo}"/> pointing to this event. \cell }
{\row }
}
}{
Definition at line {\b 1115} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventStringInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventStringInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventStringInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventStringInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 1093} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetDebugEventUnloadDllInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetDebugEventUnloadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventUnloadDllInfo} InsightSheath.Debugging.DebugEvent.GetDebugEventUnloadDllInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1130} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetEventExitProcessInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetEventExitProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventExitProcessInfo} InsightSheath.Debugging.DebugEvent.GetEventExitProcessInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1039} of file {\b DebugEvent.cs}.}\par
}
{\xe \v GetEventExitThreadInfo\:InsightSheath.Debugging.DebugEvent}
{\xe \v InsightSheath.Debugging.DebugEvent\:GetEventExitThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventExitThreadInfo} InsightSheath.Debugging.DebugEvent.GetEventExitThreadInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1056} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventCreateProcessInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
Inheritance diagram for InsightSheath.Debugging.DebugEventCreateProcessInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_create_process_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateProcessInfo} (IntPtr Nat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateProcessInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateProcessInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b GetFileContents} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the contents of the exefile that the debug create process game from. Will Be null if the CreateProcess Event did not include a valid hFile handle. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b NativeFileHandle}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the HANDLE out of the structure. Warning handle may be null }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ImageName}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a string for the image name of the create process event this contains. Depends on the NativeFileHandle being valid and will return null otherwise }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 727} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventCreateProcessInfo\:InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo\:DebugEventCreateProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventCreateProcessInfo.DebugEventCreateProcessInfo (IntPtr  {\i Nat}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 729} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventCreateProcessInfo\:InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo\:DebugEventCreateProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventCreateProcessInfo.DebugEventCreateProcessInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 735} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventCreateProcessInfo\:InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo\:DebugEventCreateProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventCreateProcessInfo.DebugEventCreateProcessInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 740} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetFileContents\:InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo\:GetFileContents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte[] InsightSheath.Debugging.DebugEventCreateProcessInfo.GetFileContents (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the contents of the exefile that the debug create process game from. Will Be null if the CreateProcess Event did not include a valid hFile handle. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i IOException} \cell }{IO Related exceptions can be thrown if a problem occurs in reading the main module's file contents. File.ReadAllBytes(string) to see the list\cell }
{\row }
}
}{
Definition at line {\b 772} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ImageName\:InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo\:ImageName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.DebugEventCreateProcessInfo.ImageName{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a string for the image name of the create process event this contains. Depends on the NativeFileHandle being valid and will return null otherwise }}\par
{
Definition at line {\b 760} of file {\b DebugEvent.cs}.}\par
}
{\xe \v NativeFileHandle\:InsightSheath.Debugging.DebugEventCreateProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateProcessInfo\:NativeFileHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventCreateProcessInfo.NativeFileHandle{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the HANDLE out of the structure. Warning handle may be null }}\par
{
Definition at line {\b 748} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventCreateThreadInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
Inheritance diagram for InsightSheath.Debugging.DebugEventCreateThreadInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_create_thread_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateThreadInfo} (IntPtr Nat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateThreadInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCreateThreadInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b ThreadHandle}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if NOT Null (IntPtr.zero), handle should have THREAD_GET_CONTEXT/ THREAD_SET_CONTEXT and THREAD_SUSPEND_RESUME access to the thread per MSDN documentation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b ThreadStartAddress}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the approx start address }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b ThreadLocalBase}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the thread location storage pointer here. MSDN says offset 0x2C is the ThreadLocationStorage pointer which presumably would let you track what per thread stuff your target is doing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b ThreadLocalStoragePointer}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ThreadLocalBase + 0x2C }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 601} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventCreateThreadInfo\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:DebugEventCreateThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventCreateThreadInfo.DebugEventCreateThreadInfo (IntPtr  {\i Nat}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 603} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventCreateThreadInfo\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:DebugEventCreateThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventCreateThreadInfo.DebugEventCreateThreadInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 608} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventCreateThreadInfo\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:DebugEventCreateThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventCreateThreadInfo.DebugEventCreateThreadInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 613} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ThreadHandle\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:ThreadHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadHandle{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if NOT Null (IntPtr.zero), handle should have THREAD_GET_CONTEXT/ THREAD_SET_CONTEXT and THREAD_SUSPEND_RESUME access to the thread per MSDN documentation. }}\par
{
Definition at line {\b 621} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ThreadLocalBase\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:ThreadLocalBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadLocalBase{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the thread location storage pointer here. MSDN says offset 0x2C is the ThreadLocationStorage pointer which presumably would let you track what per thread stuff your target is doing. }}\par
{
Definition at line {\b 643} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ThreadLocalStoragePointer\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:ThreadLocalStoragePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadLocalStoragePointer{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ThreadLocalBase + 0x2C }}\par
{
Definition at line {\b 654} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ThreadStartAddress\:InsightSheath.Debugging.DebugEventCreateThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventCreateThreadInfo\:ThreadStartAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventCreateThreadInfo.ThreadStartAddress{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the approx start address }}\par
{
Definition at line {\b 632} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventExceptionInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo}
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class Wrapper dealing with extracting Exception information from a {\b DebugEvent}. }}\par
Inheritance diagram for InsightSheath.Debugging.DebugEventExceptionInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_exception_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExceptionInfo} (IntPtr Nat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExceptionInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExceptionInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ExceptionParameterCount}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint[] {\b ExceptionParameter32}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the contents of the exception parameter list for a 32-bit debugged process. If retreving form a 64-bit process, your values are likely truncated and worthless }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong[] {\b ExceptionParameter64}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the contents of the exception parameter list for a 64-bit debugged process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b ExceptionAddress64}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the address where the exception happened in the 64 bit process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ExceptionAddress32}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return address where the exception happens in the 32-bit process. Truncates the address if the process is 64-bit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ExceptionFlags}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ExceptionCode_as_int}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the Exception for the exception that trigged. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugExceptionTypes} {\b ExceptionCode}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsFirstChanceException}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return if the debugger (that's you) has seen this first chance exception before. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class Wrapper dealing with extracting Exception information from a {\b DebugEvent}. \par
}{
Definition at line {\b 456} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventExceptionInfo\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:DebugEventExceptionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExceptionInfo.DebugEventExceptionInfo (IntPtr  {\i Nat}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 458} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventExceptionInfo\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:DebugEventExceptionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExceptionInfo.DebugEventExceptionInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 463} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventExceptionInfo\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:DebugEventExceptionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExceptionInfo.DebugEventExceptionInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 469} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ExceptionAddress32\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionAddress32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionAddress32{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return address where the exception happens in the 32-bit process. Truncates the address if the process is 64-bit. }}\par
{
Definition at line {\b 547} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionAddress64\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionAddress64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionAddress64{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the address where the exception happened in the 64 bit process. }}\par
{
Definition at line {\b 536} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionCode\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugExceptionTypes} InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 576} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionCode_as_int\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionCode_as_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionCode_as_int{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the Exception for the exception that trigged. }}\par
{
Definition at line {\b 568} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionFlags\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionFlags{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 556} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionParameter32\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionParameter32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint [] InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionParameter32{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the contents of the exception parameter list for a 32-bit debugged process. If retreving form a 64-bit process, your values are likely truncated and worthless }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Native implementation promotes the DWORD array into a (C# ulong)/(C++ dword64) array and returns a block of memory with values of 4 bytes long. We free the block returned\par
}{
Definition at line {\b 488} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionParameter64\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionParameter64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong [] InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionParameter64{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the contents of the exception parameter list for a 64-bit debugged process. }}\par
{
Definition at line {\b 512} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ExceptionParameterCount\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:ExceptionParameterCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventExceptionInfo.ExceptionParameterCount{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 474} of file {\b DebugEvent.cs}.}\par
}
{\xe \v IsFirstChanceException\:InsightSheath.Debugging.DebugEventExceptionInfo}
{\xe \v InsightSheath.Debugging.DebugEventExceptionInfo\:IsFirstChanceException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.DebugEventExceptionInfo.IsFirstChanceException{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return if the debugger (that's you) has seen this first chance exception before. }}\par
{
Definition at line {\b 587} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventExitProcessInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventExitProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitProcessInfo}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
Inheritance diagram for InsightSheath.Debugging.DebugEventExitProcessInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_exit_process_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitProcessInfo} (IntPtr Nat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitProcessInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitProcessInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ExitCode}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the code that the {\b Process} returned when finishing }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 697} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventExitProcessInfo\:InsightSheath.Debugging.DebugEventExitProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitProcessInfo\:DebugEventExitProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExitProcessInfo.DebugEventExitProcessInfo (IntPtr  {\i Nat}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 699} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventExitProcessInfo\:InsightSheath.Debugging.DebugEventExitProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitProcessInfo\:DebugEventExitProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExitProcessInfo.DebugEventExitProcessInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 704} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventExitProcessInfo\:InsightSheath.Debugging.DebugEventExitProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitProcessInfo\:DebugEventExitProcessInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExitProcessInfo.DebugEventExitProcessInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 709} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ExitCode\:InsightSheath.Debugging.DebugEventExitProcessInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitProcessInfo\:ExitCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventExitProcessInfo.ExitCode{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the code that the {\b Process} returned when finishing }}\par
{
Definition at line {\b 717} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventExitThreadInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventExitThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitThreadInfo}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
Inheritance diagram for InsightSheath.Debugging.DebugEventExitThreadInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_exit_thread_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitThreadInfo} (IntPtr Nat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitThreadInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventExitThreadInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ExitCode}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the code that the thread returned when finishing }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 666} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventExitThreadInfo\:InsightSheath.Debugging.DebugEventExitThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitThreadInfo\:DebugEventExitThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExitThreadInfo.DebugEventExitThreadInfo (IntPtr  {\i Nat}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 668} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventExitThreadInfo\:InsightSheath.Debugging.DebugEventExitThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitThreadInfo\:DebugEventExitThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExitThreadInfo.DebugEventExitThreadInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 673} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventExitThreadInfo\:InsightSheath.Debugging.DebugEventExitThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitThreadInfo\:DebugEventExitThreadInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventExitThreadInfo.DebugEventExitThreadInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 678} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ExitCode\:InsightSheath.Debugging.DebugEventExitThreadInfo}
{\xe \v InsightSheath.Debugging.DebugEventExitThreadInfo\:ExitCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventExitThreadInfo.ExitCode{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the code that the thread returned when finishing }}\par
{
Definition at line {\b 687} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventLoadDllInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to a {\b DebugEventType.LoadDllEvent} in a {\b DebugEvent} struct }}\par
Inheritance diagram for InsightSheath.Debugging.DebugEventLoadDllInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_load_dll_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventLoadDllInfo} (IntPtr Nat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventLoadDllInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventLoadDllInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b GetDebugInfo} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the debug info specified in the DLL as a series of bytes. MSDN documentation says this should be code view 4.0 format - whatever that is note: exists in the c# side only }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b FileHandle}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Raw handle to the file. You should probably close this if the handle is valid once you no longer need it. If it's valid, MSDN says you'll have read and write access }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b DllBaseAddress}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the base address of where the DLL was loaded in the debugged process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b DebugInfoSize}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size (in bytes?) of the DLL's debug info }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b DebugInfoOffset}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offer to where debug info is located }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsImageNameStringUnicode}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the string in the address space specified here valid? }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ImageName}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This ignores the {\b ImageName} underlying native struct member entirely as seen on MSDN LOAD_DLL_DEBUG_EVENT. We simple fetch name - assuming the native hfile member is valid. Should the system not include the file handle, null is returned instead }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to a {\b DebugEventType.LoadDllEvent} in a {\b DebugEvent} struct \par
}{
Definition at line {\b 332} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventLoadDllInfo\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:DebugEventLoadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventLoadDllInfo.DebugEventLoadDllInfo (IntPtr  {\i Nat}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventLoadDllInfo\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:DebugEventLoadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventLoadDllInfo.DebugEventLoadDllInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 339} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventLoadDllInfo\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:DebugEventLoadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventLoadDllInfo.DebugEventLoadDllInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 345} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetDebugInfo\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:GetDebugInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte[] InsightSheath.Debugging.DebugEventLoadDllInfo.GetDebugInfo (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the debug info specified in the DLL as a series of bytes. MSDN documentation says this should be code view 4.0 format - whatever that is note: exists in the c# side only }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 414} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v DebugInfoOffset\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:DebugInfoOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventLoadDllInfo.DebugInfoOffset{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offer to where debug info is located }}\par
{
Definition at line {\b 385} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugInfoSize\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:DebugInfoSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventLoadDllInfo.DebugInfoSize{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size (in bytes?) of the DLL's debug info }}\par
{
Definition at line {\b 375} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DllBaseAddress\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:DllBaseAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventLoadDllInfo.DllBaseAddress{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the base address of where the DLL was loaded in the debugged process. }}\par
{
Definition at line {\b 364} of file {\b DebugEvent.cs}.}\par
}
{\xe \v FileHandle\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:FileHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventLoadDllInfo.FileHandle{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Raw handle to the file. You should probably close this if the handle is valid once you no longer need it. If it's valid, MSDN says you'll have read and write access }}\par
{
Definition at line {\b 353} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ImageName\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:ImageName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.DebugEventLoadDllInfo.ImageName{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This ignores the {\b ImageName} underlying native struct member entirely as seen on MSDN LOAD_DLL_DEBUG_EVENT. We simple fetch name - assuming the native hfile member is valid. Should the system not include the file handle, null is returned instead }}\par
{
Definition at line {\b 440} of file {\b DebugEvent.cs}.}\par
}
{\xe \v IsImageNameStringUnicode\:InsightSheath.Debugging.DebugEventLoadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventLoadDllInfo\:IsImageNameStringUnicode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.DebugEventLoadDllInfo.IsImageNameStringUnicode{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the string in the address space specified here valid? }}\par
{
Definition at line {\b 397} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventRipInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventRipInfo}
{\xe \v InsightSheath.Debugging.DebugEventRipInfo}
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere. }}\par
Inheritance diagram for InsightSheath.Debugging.DebugEventRipInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_rip_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventRipInfo} (IntPtr NativePtr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventRipInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventRipInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Error}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Error number that caused the debugging RIP event. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RipErrorType} {\b ErrorType}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Should be one of the enum values for {\b RipErrorType}. If It's zero, MSDN documentation says only sdwError is set. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere. \par
}{
Definition at line {\b 852} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventRipInfo\:InsightSheath.Debugging.DebugEventRipInfo}
{\xe \v InsightSheath.Debugging.DebugEventRipInfo\:DebugEventRipInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventRipInfo.DebugEventRipInfo (IntPtr  {\i NativePtr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 854} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventRipInfo\:InsightSheath.Debugging.DebugEventRipInfo}
{\xe \v InsightSheath.Debugging.DebugEventRipInfo\:DebugEventRipInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventRipInfo.DebugEventRipInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 858} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventRipInfo\:InsightSheath.Debugging.DebugEventRipInfo}
{\xe \v InsightSheath.Debugging.DebugEventRipInfo\:DebugEventRipInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventRipInfo.DebugEventRipInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 863} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Error\:InsightSheath.Debugging.DebugEventRipInfo}
{\xe \v InsightSheath.Debugging.DebugEventRipInfo\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventRipInfo.Error{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Error number that caused the debugging RIP event. }}\par
{
Definition at line {\b 873} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ErrorType\:InsightSheath.Debugging.DebugEventRipInfo}
{\xe \v InsightSheath.Debugging.DebugEventRipInfo\:ErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RipErrorType} InsightSheath.Debugging.DebugEventRipInfo.ErrorType{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Should be one of the enum values for {\b RipErrorType}. If It's zero, MSDN documentation says only sdwError is set. }}\par
{
Definition at line {\b 885} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventStaticContainer Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the basis of disposal the other {\b DebugEvent} classes use. Also exposes routines to read the ProcessID and ThreadID that triggered the event }}\par
Inheritance diagram for InsightSheath.Debugging.DebugEventStaticContainer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_static_container.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStaticContainer} (IntPtr {\b Native})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the base {\b DebugEvent} abstract class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStaticContainer} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the base {\b DebugEvent} abstract class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStaticContainer} (IntPtr {\b Native}, bool {\b FreeOnCleanup}, ulong {\b ReferenceCounter})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the base {\b DebugEvent} class }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ProcessID}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the process id that this event happed too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ThreadID}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the thread of the code that this event happened too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventType} {\b EventType}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get which type of structure this debug event contains. {\b DebugEventType} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEventFrom32BitProcess}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a couple of calls to GetNativeSystemInfo() and asks IsWow64Process() if the this processID is running under WOW or not. This is NOT part of {\b DebugEvent} structure itself BUT is useful in letter the debugger know is the debugged application is 32-bit vs 64-bit }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the basis of disposal the other {\b DebugEvent} classes use. Also exposes routines to read the ProcessID and ThreadID that triggered the event \par
}{
Definition at line {\b 212} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventStaticContainer\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:DebugEventStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventStaticContainer.DebugEventStaticContainer (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the base {\b DebugEvent} abstract class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to the structure\cell }
{\row }
}
}{
Definition at line {\b 218} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventStaticContainer\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:DebugEventStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventStaticContainer.DebugEventStaticContainer (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the base {\b DebugEvent} abstract class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to the structure\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{if true then the structure is freed via RemoteRead_SimpleFree(). Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated\cell }
{\row }
}
}{
Definition at line {\b 227} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventStaticContainer\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:DebugEventStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventStaticContainer.DebugEventStaticContainer (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}, ulong  {\i ReferenceCounter}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the base {\b DebugEvent} class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to the structure\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{if true then the structure is freed via RemoteRead_SimpleFree(). Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ReferenceCounter} \cell }{Specify the starting reference count.\cell }
{\row }
}
}{
Definition at line {\b 238} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Dispose\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.DebugEventStaticContainer.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources in addition to unmanaged.\cell }
{\row }
}
IMPORTANT! If your child class needs special needs beyond C/C++'s free(), override this and take care of them before calling base(). Should your custom class allocate multiple things for example WindowsUnicodeString's implementation for reading from remote processes Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(IntPtr, IntPtr, bool, bool), you will need to make a routine to properly free. That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory. Design checks: list type="number"> listheader> description > First, override disposal()  /listheader > item>  Nest, add a private variable in your class called isDisposed. Set this to true when your class's native pointer is cleaned up completely  /item > item> description>if {\b ReferenceCounterNativeStaticContainer} is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it. /item> item> description>if {\b ReferenceCounterNativeStaticContainer} IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null. If the reference counter is more than 0 when decreased, set native to null instead of disposing. /item> \par
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b InsightSheath.Debugging.DebugEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 244} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v EventType\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:EventType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventType} InsightSheath.Debugging.DebugEventStaticContainer.EventType{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get which type of structure this debug event contains. {\b DebugEventType} }}\par
{
Definition at line {\b 306} of file {\b DebugEvent.cs}.}\par
}
{\xe \v IsEventFrom32BitProcess\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:IsEventFrom32BitProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.DebugEventStaticContainer.IsEventFrom32BitProcess{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a couple of calls to GetNativeSystemInfo() and asks IsWow64Process() if the this processID is running under WOW or not. This is NOT part of {\b DebugEvent} structure itself BUT is useful in letter the debugger know is the debugged application is 32-bit vs 64-bit }}\par
{
Definition at line {\b 318} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ProcessID\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:ProcessID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventStaticContainer.ProcessID{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the process id that this event happed too }}\par
{
Definition at line {\b 284} of file {\b DebugEvent.cs}.}\par
}
{\xe \v ThreadID\:InsightSheath.Debugging.DebugEventStaticContainer}
{\xe \v InsightSheath.Debugging.DebugEventStaticContainer\:ThreadID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.DebugEventStaticContainer.ThreadID{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the thread of the code that this event happened too }}\par
{
Definition at line {\b 295} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventStringInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventStringInfo}
{\xe \v InsightSheath.Debugging.DebugEventStringInfo}
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to process specific {\b DebugEventType.OutputDebugString} components. }}\par
Inheritance diagram for InsightSheath.Debugging.DebugEventStringInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_string_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStringInfo} (IntPtr {\b Native})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStringInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventStringInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override string {\b ToString} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b OutputString}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the string messaged contained within the debug event. ANSI output strings are converted to Unicode on the Native side before being sent to the Managed side. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to process specific {\b DebugEventType.OutputDebugString} components. \par
}{
Definition at line {\b 797} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventStringInfo\:InsightSheath.Debugging.DebugEventStringInfo}
{\xe \v InsightSheath.Debugging.DebugEventStringInfo\:DebugEventStringInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventStringInfo.DebugEventStringInfo (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 799} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventStringInfo\:InsightSheath.Debugging.DebugEventStringInfo}
{\xe \v InsightSheath.Debugging.DebugEventStringInfo\:DebugEventStringInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventStringInfo.DebugEventStringInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 804} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventStringInfo\:InsightSheath.Debugging.DebugEventStringInfo}
{\xe \v InsightSheath.Debugging.DebugEventStringInfo\:DebugEventStringInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventStringInfo.DebugEventStringInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 809} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ToString\:InsightSheath.Debugging.DebugEventStringInfo}
{\xe \v InsightSheath.Debugging.DebugEventStringInfo\:ToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override string InsightSheath.Debugging.DebugEventStringInfo.ToString (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 814} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v OutputString\:InsightSheath.Debugging.DebugEventStringInfo}
{\xe \v InsightSheath.Debugging.DebugEventStringInfo\:OutputString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.DebugEventStringInfo.OutputString{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the string messaged contained within the debug event. ANSI output strings are converted to Unicode on the Native side before being sent to the Managed side. }}\par
{
Definition at line {\b 821} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.DebugEventUnloadDllInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.DebugEventUnloadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventUnloadDllInfo}
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
Inheritance diagram for InsightSheath.Debugging.DebugEventUnloadDllInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_debug_event_unload_dll_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventUnloadDllInfo} (IntPtr NativePtr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creation. Does NOT free the underling pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventUnloadDllInfo} (IntPtr Nat, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventUnloadDllInfo} (IntPtr Nat, bool {\b FreeOnCleanup}, ulong RefCount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b BaseOfDll}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The base address of the DLL that was previously loaded. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 897} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugEventUnloadDllInfo\:InsightSheath.Debugging.DebugEventUnloadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventUnloadDllInfo\:DebugEventUnloadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventUnloadDllInfo.DebugEventUnloadDllInfo (IntPtr  {\i NativePtr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creation. Does NOT free the underling pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NativePtr} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 904} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventUnloadDllInfo\:InsightSheath.Debugging.DebugEventUnloadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventUnloadDllInfo\:DebugEventUnloadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventUnloadDllInfo.DebugEventUnloadDllInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 909} of file {\b DebugEvent.cs}.}\par
}
{\xe \v DebugEventUnloadDllInfo\:InsightSheath.Debugging.DebugEventUnloadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventUnloadDllInfo\:DebugEventUnloadDllInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.DebugEventUnloadDllInfo.DebugEventUnloadDllInfo (IntPtr  {\i Nat}, bool  {\i FreeOnCleanup}, ulong  {\i RefCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 914} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v BaseOfDll\:InsightSheath.Debugging.DebugEventUnloadDllInfo}
{\xe \v InsightSheath.Debugging.DebugEventUnloadDllInfo\:BaseOfDll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.DebugEventUnloadDllInfo.BaseOfDll{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The base address of the DLL that was previously loaded. }}\par
{
Definition at line {\b 923} of file {\b DebugEvent.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/{\b DebugEvent.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\xe \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} for Api Version struture. Note: Impementation in Insight has the struct as part of it, you DON'T want to free any pointer to it you get from insite. }}\par
Inheritance diagram for InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_debug_help___api_version_struct.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugHelp_ApiVersionStruct} (IntPtr {\b Native})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize this wrapper class to point to an unmanaged memory structure containing one API_VERISON structy }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugHelp_ApiVersionStruct} (IntPtr {\b Native}, bool FreeOnClean)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize this wrapper class to point to an unmanaged memory structure containing one API_VERISON structy. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Revision}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Revison member of the {\b API_VERSION} data struct the Native pointer points too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Major}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Major member of the {\b API_VERSION} data struct the Native pointer points too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Minor}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Minor member of the {\b API_VERSION} data struct the Native pointer points too }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} for Api Version struture. Note: Impementation in Insight has the struct as part of it, you DON'T want to free any pointer to it you get from insite. \par
}{
Definition at line {\b 40} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DebugHelp_ApiVersionStruct\:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\xe \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct\:DebugHelp_ApiVersionStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.DebugHelp_ApiVersionStruct (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize this wrapper class to point to an unmanaged memory structure containing one API_VERISON structy }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{non null native pointer\cell }
{\row }
}
}{
Definition at line {\b 46} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\xe \v DebugHelp_ApiVersionStruct\:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\xe \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct\:DebugHelp_ApiVersionStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.DebugHelp_ApiVersionStruct (IntPtr  {\i Native}, bool  {\i FreeOnClean}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize this wrapper class to point to an unmanaged memory structure containing one API_VERISON structy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{non null native pointer\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnClean} \cell }{Ignored. Always false when calling the base {\b NativeStaticContainer} contructor\cell }
{\row }
}
}{
Definition at line {\b 56} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Major\:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\xe \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct\:Major}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.Major{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Major member of the {\b API_VERSION} data struct the Native pointer points too }}\par
{
Definition at line {\b 74} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\xe \v Minor\:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\xe \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct\:Minor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.Minor{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Minor member of the {\b API_VERSION} data struct the Native pointer points too }}\par
{
Definition at line {\b 85} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\xe \v Revision\:InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}
{\xe \v InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct\:Revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct.Revision{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Revison member of the {\b API_VERSION} data struct the Native pointer points too }}\par
{
Definition at line {\b 64} of file {\b DebugHelp_ApiVersionStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/SymbolEngine/{\b DebugHelp_ApiVersionStruct.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Misc.EventDebugAssist Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist}
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements an event debugger system for processing events. You will need to link a way to call {\b EventDebugAssist.FireEvents(DebugEvent)} in order to actually make to the thing work }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b CreateProcessEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b CreateThreadEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b ExceptionDebugEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b ExitProcessDebugEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b ExitThreadDebugEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b LoadDllDebugEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b OutputDebugStringCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b RipCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b UnloadDebugEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate void {\b GeneralDebugEventCallback} ({\b DebugEvent} Ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b FireEvents} ({\b DebugEvent} Ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Your code will need to actual call this to trigger getting events. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Events\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CreateProcessEventCallback} {\b CreateProcessEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to get CreateProcess Events }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CreateThreadEventCallback} {\b CreateThreadEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subsrubte to get CreateThread }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExceptionDebugEventCallback} {\b ExceptionEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to get Exceptions }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExitProcessDebugEventCallback} {\b ExitProcessEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to get ExitProess }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExitThreadDebugEventCallback} {\b ExitThreadEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscvribe to get ExitThread }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LoadDllDebugEventCallback} {\b LoadDllEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to load Dll events }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutputDebugStringCallback} {\b OutputDebugStringEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subsvrube to get output debug strings }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RipCallback} {\b RipEvent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnloadDebugEventCallback} {\b UnloadDllEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscvribe to get RIp events }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneralDebugEventCallback} {\b GeneralEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to catch all the other invents. IMPORTANT!. This is called before the others! }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements an event debugger system for processing events. You will need to link a way to call {\b EventDebugAssist.FireEvents(DebugEvent)} in order to actually make to the thing work \par
}{
Definition at line {\b 14} of file {\b EventDebug.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CreateProcessEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:CreateProcessEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.CreateProcessEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v CreateThreadEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:CreateThreadEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.CreateThreadEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v ExceptionDebugEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:ExceptionDebugEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.ExceptionDebugEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v ExitProcessDebugEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:ExitProcessDebugEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.ExitProcessDebugEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v ExitThreadDebugEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:ExitThreadDebugEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.ExitThreadDebugEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v FireEvents\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:FireEvents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void InsightSheath.Misc.EventDebugAssist.FireEvents ({\b DebugEvent}  {\i Ptr}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Your code will need to actual call this to trigger getting events. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 113} of file {\b EventDebug.cs}.}\par
}
{\xe \v GeneralDebugEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:GeneralDebugEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.GeneralDebugEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v LoadDllDebugEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:LoadDllDebugEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.LoadDllDebugEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v OutputDebugStringCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:OutputDebugStringCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.OutputDebugStringCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v RipCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:RipCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.RipCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\xe \v UnloadDebugEventCallback\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:UnloadDebugEventCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate void InsightSheath.Misc.EventDebugAssist.UnloadDebugEventCallback ({\b DebugEvent}  {\i Ptr})}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ptr} \cell }{\cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Event Documentation\par
\pard\plain 
{\xe \v CreateProcessEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:CreateProcessEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CreateProcessEventCallback} InsightSheath.Misc.EventDebugAssist.CreateProcessEvent}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to get CreateProcess Events }}\par
{
Definition at line {\b 71} of file {\b EventDebug.cs}.}\par
}
{\xe \v CreateThreadEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:CreateThreadEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CreateThreadEventCallback} InsightSheath.Misc.EventDebugAssist.CreateThreadEvent}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subsrubte to get CreateThread }}\par
{
Definition at line {\b 75} of file {\b EventDebug.cs}.}\par
}
{\xe \v ExceptionEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:ExceptionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExceptionDebugEventCallback} InsightSheath.Misc.EventDebugAssist.ExceptionEvent}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to get Exceptions }}\par
{
Definition at line {\b 79} of file {\b EventDebug.cs}.}\par
}
{\xe \v ExitProcessEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:ExitProcessEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExitProcessDebugEventCallback} InsightSheath.Misc.EventDebugAssist.ExitProcessEvent}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to get ExitProess }}\par
{
Definition at line {\b 83} of file {\b EventDebug.cs}.}\par
}
{\xe \v ExitThreadEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:ExitThreadEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ExitThreadDebugEventCallback} InsightSheath.Misc.EventDebugAssist.ExitThreadEvent}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscvribe to get ExitThread }}\par
{
Definition at line {\b 87} of file {\b EventDebug.cs}.}\par
}
{\xe \v GeneralEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:GeneralEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GeneralDebugEventCallback} InsightSheath.Misc.EventDebugAssist.GeneralEvent}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to catch all the other invents. IMPORTANT!. This is called before the others! }}\par
{
Definition at line {\b 107} of file {\b EventDebug.cs}.}\par
}
{\xe \v LoadDllEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:LoadDllEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LoadDllDebugEventCallback} InsightSheath.Misc.EventDebugAssist.LoadDllEvent}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to load Dll events }}\par
{
Definition at line {\b 91} of file {\b EventDebug.cs}.}\par
}
{\xe \v OutputDebugStringEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:OutputDebugStringEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OutputDebugStringCallback} InsightSheath.Misc.EventDebugAssist.OutputDebugStringEvent}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subsvrube to get output debug strings }}\par
{
Definition at line {\b 95} of file {\b EventDebug.cs}.}\par
}
{\xe \v RipEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:RipEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RipCallback} InsightSheath.Misc.EventDebugAssist.RipEvent}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line {\b 99} of file {\b EventDebug.cs}.}\par
}
{\xe \v UnloadDllEvent\:InsightSheath.Misc.EventDebugAssist}
{\xe \v InsightSheath.Misc.EventDebugAssist\:UnloadDllEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnloadDebugEventCallback} InsightSheath.Misc.EventDebugAssist.UnloadDllEvent}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscvribe to get RIp events }}\par
{
Definition at line {\b 103} of file {\b EventDebug.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Misc/{\b EventDebug.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.GeneralTelemtryHelperStruct Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General common values/code between the telemetry reader code. }}\par
Inheritance diagram for InsightSheath.Telemetry.GeneralTelemtryHelperStruct:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_telemetry_1_1_general_telemtry_helper_struct.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneralTelemtryHelperStruct} (uint {\b ProcessId}, uint ThreadID, IntPtr ForceHandle, IntPtr LastError, {\b MachineType} {\b Type})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetForceHandle} (IntPtr ReplacementHandle)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Duplicate the handle you provide into the process the exception was generated from and write it to the memory location specified by ForceHandle }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetForceHandle} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the handle to the appropriate invalid handle value based on the {\b Type} value in this struct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetForceHandle} (ulong HandleValue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the 64-bit handle value to something other than an IntPtr - for example InvalidHandleValue64 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetForceHandle} (uint HandleValue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the 32-bit handle value to something other than an IntPtr - for example InvalidHandleValue32 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLastErrorValue} (uint NewValue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the last error value that will be set by the detouring routine when returning control to the debugged process. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly {\b MachineType} {\b Type}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depends on what DebugEvent.IsProcess32Bit returns. Intended for determining pointer size only. If that's true, Value is {\b MachineType.MachineI386} otherwise value is {\b MachineType.MachineAmd64} i386 pointer sizes are 4 bytes long and Amd64 pointer sizes are 8 bytes. This may not actually be the exact machine type as stored in the debugged process's physical PE/EXE file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly uint {\b ProcessId}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process that the exception originated from. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly uint {\b ThreadId}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread that the exception originated from. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly IntPtr {\b ForceHandlePtr}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the handle that is returned back to the target process after handling the exception. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly IntPtr {\b LastErrorPtr}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depending on Context of target detoured routine, may be an NTSTATUS return value or an actual last error pointer. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General common values/code between the telemetry reader code. \par
}{
Definition at line {\b 29} of file {\b GeneralTelemetry.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GeneralTelemtryHelperStruct\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:GeneralTelemtryHelperStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Telemetry.GeneralTelemtryHelperStruct.GeneralTelemtryHelperStruct (uint  {\i ProcessId}, uint  {\i ThreadID}, IntPtr  {\i ForceHandle}, IntPtr  {\i LastError}, {\b MachineType}  {\i Type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b GeneralTelemetry.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetForceHandle\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:SetForceHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the handle to the appropriate invalid handle value based on the {\b Type} value in this struct. }}\par
{
Definition at line {\b 114} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v SetForceHandle\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:SetForceHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle (IntPtr  {\i ReplacementHandle}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Duplicate the handle you provide into the process the exception was generated from and write it to the memory location specified by ForceHandle }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ReplacementHandle} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 66} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v SetForceHandle\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:SetForceHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle (uint  {\i HandleValue}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the 32-bit handle value to something other than an IntPtr - for example InvalidHandleValue32 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i HandleValue} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 159} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v SetForceHandle\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:SetForceHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetForceHandle (ulong  {\i HandleValue}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the 64-bit handle value to something other than an IntPtr - for example InvalidHandleValue64 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i HandleValue} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 129} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v SetLastErrorValue\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:SetLastErrorValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Telemetry.GeneralTelemtryHelperStruct.SetLastErrorValue (uint  {\i NewValue}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the last error value that will be set by the detouring routine when returning control to the debugged process. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NewValue} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 191} of file {\b GeneralTelemetry.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ForceHandlePtr\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:ForceHandlePtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly IntPtr InsightSheath.Telemetry.GeneralTelemtryHelperStruct.ForceHandlePtr}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the handle that is returned back to the target process after handling the exception. }}\par
{
Definition at line {\b 55} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v LastErrorPtr\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:LastErrorPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly IntPtr InsightSheath.Telemetry.GeneralTelemtryHelperStruct.LastErrorPtr}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depending on Context of target detoured routine, may be an NTSTATUS return value or an actual last error pointer. }}\par
{
Definition at line {\b 59} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v ProcessId\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:ProcessId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly uint InsightSheath.Telemetry.GeneralTelemtryHelperStruct.ProcessId}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process that the exception originated from. }}\par
{
Definition at line {\b 47} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v ThreadId\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:ThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly uint InsightSheath.Telemetry.GeneralTelemtryHelperStruct.ThreadId}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread that the exception originated from. }}\par
{
Definition at line {\b 51} of file {\b GeneralTelemetry.cs}.}\par
}
{\xe \v Type\:InsightSheath.Telemetry.GeneralTelemtryHelperStruct}
{\xe \v InsightSheath.Telemetry.GeneralTelemtryHelperStruct\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly {\b MachineType} InsightSheath.Telemetry.GeneralTelemtryHelperStruct.Type}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depends on what DebugEvent.IsProcess32Bit returns. Intended for determining pointer size only. If that's true, Value is {\b MachineType.MachineI386} otherwise value is {\b MachineType.MachineAmd64} i386 pointer sizes are 4 bytes long and Amd64 pointer sizes are 8 bytes. This may not actually be the exact machine type as stored in the debugged process's physical PE/EXE file. }}\par
{
Definition at line {\b 42} of file {\b GeneralTelemetry.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b GeneralTelemetry.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.GenericTelemetryException Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.GenericTelemetryException}
{\xe \v InsightSheath.Telemetry.GenericTelemetryException}
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b GenericTelemetryException.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b GenericTelemetryException.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.SymbolEngine.InsightHunter Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A part of the symbol engine exported in InsightAPI in the Native DLL. This class is VERY VERY VERY tightly coupled with the InsightProcess class but distinct enough to warrent its own class/wrapper wrappers. If you need not have symbol processing, disabling InsightProcess.EnableSymbolEngine is set to false if fine. That turns off the code that updates the native {\b InsightHunter} class when the worker thread receives a debug event NOTE: You'll need to spawn at least one process with InsightProcess to get much use out of this. }}\par
Inheritance diagram for InsightSheath.Debugging.SymbolEngine.InsightHunter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_insight_hunter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SymbolOptionsFlags} : uint \{ {\b AllowAbsoluteSymbols} = 0x00000800
, {\b AllowZeroAddress} = 0x01000000
, {\b AutoPublics} = 0x00010000
, {\b CaseInsentive} = 0x00000001
, {\b DebugMode} = 0x80000000
, {\b DeferredLoad} = 0x00000004
, {\b DisableSymServerAutoDetect} = 0x02000000
, {\b ExactSymbolRequired} = 0x02000000
, {\b FailCriticalErrors} = 0x00000200
, {\b FavorCompressed} = 0x00800000
, {\b FlatDirectory} = 0x00400000
, {\b IgnoreCodeViewRecord} = 0x00000080
, {\b IgnoreImageDir} = 0x00200000
, {\b IgnoreNtSymPath} = 0x00001000
, {\b Include32BitModules} = 0x00002000
, {\b LoadAnything} = 0x00000040
, {\b LoadLines} = 0x00000010
, {\b SYMOPT_NO_CPP} = 0x00000008
, {\b NoImageSearch} = 0x00020000
, {\b NoPrompts} = 0x00080000
, {\b NoPublics} = 0x00008000
, {\b NoUnqualifiedLoads} = 0x00000100
, {\b Overwrite} = 0x00100000
, {\b PublicsOnly} = 0x00004000
, {\b SecureMode} = 0x00040000
, {\b UndecorateSymbols} = 0x00000002
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specifies combinations of flags to Set for the symbol engine as seein in MSDN's SymSetOptions }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightHunter} (IntPtr That)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightHunter} (IntPtr That, bool FreeOnDispose)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b LoadExeSymbolInfo} ({\b DebugEvent} debugEvent)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in reponse to a CREATE_PROCESS_DEBUG_EVENT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b LoadExeSymbolInfo} (IntPtr {\b DebugEvent})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in reponse to a CREATE_PROCESS_DEBUG_EVENT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b LoadDllSymbolInfo} ({\b DebugEvent} {\b DebugEvent})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in resposne to a LOAD_DLL_DEBUG_EVENT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UnloadDllSymbolInfo} ({\b DebugEvent} {\b DebugEvent})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in resposne to a UNLOAD_DLL_DEBUG_EVENT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UnloadDllSymbolInfo} (IntPtr {\b DebugEvent})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SetParentWindow} (IntPtr HWND)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the parent window for the symbol engine/ debug help api }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b EnumerateSymbols} (string SearchString, {\b InsightHunter_SymbolSearchCallBackRoutine} DotNetCallback)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enumerate loaded symbols for the debugged exe }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b EnumerateSourceFiles} (string SearchString, {\b InsightHunter_SymbolSourceCallbackRoutine} DotNetCallBack)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enumerate loaded source files for symbol }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b RefreshModules} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
reload loaded modules. \par
 }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SyncAccess}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is true. This being true means the NativeClass {\b InsightHunter} synchronizes calls to the Debug Help Symbol Engine with a CRITICAL_SECTION Win32 Object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SymbolOptionsFlags} {\b SymbolOptions}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify what you want to the symbol handler to too. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugHelp_ApiVersionStruct} {\b DebugHelp_Version}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Version Data on the Debug Help API the symbol engine actuallly uses. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b API_VERSION} {\b DebugHelp_Version2}{\f2  [get, set]}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A part of the symbol engine exported in InsightAPI in the Native DLL. This class is VERY VERY VERY tightly coupled with the InsightProcess class but distinct enough to warrent its own class/wrapper wrappers. If you need not have symbol processing, disabling InsightProcess.EnableSymbolEngine is set to false if fine. That turns off the code that updates the native {\b InsightHunter} class when the worker thread receives a debug event NOTE: You'll need to spawn at least one process with InsightProcess to get much use out of this. \par
}{
Definition at line {\b 30} of file {\b InsightHunter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v SymbolOptionsFlags\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:SymbolOptionsFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptionsFlags} : uint}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specifies combinations of flags to Set for the symbol engine as seein in MSDN's SymSetOptions }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AllowAbsoluteSymbols\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:AllowAbsoluteSymbols}
{\qr AllowAbsoluteSymbols{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
\cell }{\cell }{\row }
{\xe \v AllowZeroAddress\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:AllowZeroAddress}
{\qr AllowZeroAddress{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\cell }{\cell }{\row }
{\xe \v AutoPublics\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:AutoPublics}
{\qr AutoPublics{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
\cell }{\cell }{\row }
{\xe \v CaseInsentive\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:CaseInsentive}
{\qr CaseInsentive{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
\cell }{\cell }{\row }
{\xe \v DebugMode\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:DebugMode}
{\qr DebugMode{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
\cell }{\cell }{\row }
{\xe \v DeferredLoad\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:DeferredLoad}
{\qr DeferredLoad{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
\cell }{\cell }{\row }
{\xe \v DisableSymServerAutoDetect\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:DisableSymServerAutoDetect}
{\qr DisableSymServerAutoDetect{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\cell }{\cell }{\row }
{\xe \v ExactSymbolRequired\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:ExactSymbolRequired}
{\qr ExactSymbolRequired{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\cell }{\cell }{\row }
{\xe \v FailCriticalErrors\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:FailCriticalErrors}
{\qr FailCriticalErrors{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
\cell }{\cell }{\row }
{\xe \v FavorCompressed\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:FavorCompressed}
{\qr FavorCompressed{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
\cell }{\cell }{\row }
{\xe \v FlatDirectory\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:FlatDirectory}
{\qr FlatDirectory{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
\cell }{\cell }{\row }
{\xe \v IgnoreCodeViewRecord\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:IgnoreCodeViewRecord}
{\qr IgnoreCodeViewRecord{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
\cell }{\cell }{\row }
{\xe \v IgnoreImageDir\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:IgnoreImageDir}
{\qr IgnoreImageDir{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
\cell }{\cell }{\row }
{\xe \v IgnoreNtSymPath\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:IgnoreNtSymPath}
{\qr IgnoreNtSymPath{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
\cell }{\cell }{\row }
{\xe \v Include32BitModules\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:Include32BitModules}
{\qr Include32BitModules{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
\cell }{\cell }{\row }
{\xe \v LoadAnything\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:LoadAnything}
{\qr LoadAnything{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
\cell }{\cell }{\row }
{\xe \v LoadLines\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:LoadLines}
{\qr LoadLines{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
\cell }{\cell }{\row }
{\xe \v SYMOPT_NO_CPP\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:SYMOPT_NO_CPP}
{\qr SYMOPT_NO_CPP{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
\cell }{\cell }{\row }
{\xe \v NoImageSearch\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:NoImageSearch}
{\qr NoImageSearch{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\cell }{\cell }{\row }
{\xe \v NoPrompts\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:NoPrompts}
{\qr NoPrompts{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
\cell }{\cell }{\row }
{\xe \v NoPublics\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:NoPublics}
{\qr NoPublics{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
\cell }{\cell }{\row }
{\xe \v NoUnqualifiedLoads\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:NoUnqualifiedLoads}
{\qr NoUnqualifiedLoads{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
\cell }{\cell }{\row }
{\xe \v Overwrite\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:Overwrite}
{\qr Overwrite{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
\cell }{\cell }{\row }
{\xe \v PublicsOnly\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:PublicsOnly}
{\qr PublicsOnly{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\cell }{\cell }{\row }
{\xe \v SecureMode\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:SecureMode}
{\qr SecureMode{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WARNING YOU CANNOT CLEAR this flag once set. \par
}\cell }{\row }
{\xe \v UndecorateSymbols\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:UndecorateSymbols}
{\qr UndecorateSymbols{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 36} of file {\b InsightHunter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InsightHunter\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:InsightHunter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.SymbolEngine.InsightHunter.InsightHunter (IntPtr  {\i That}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b InsightHunter.cs}.}\par
}
{\xe \v InsightHunter\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:InsightHunter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.SymbolEngine.InsightHunter.InsightHunter (IntPtr  {\i That}, bool  {\i FreeOnDispose}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b InsightHunter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v EnumerateSourceFiles\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:EnumerateSourceFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.EnumerateSourceFiles (string  {\i SearchString}, {\b InsightHunter_SymbolSourceCallbackRoutine}  {\i DotNetCallBack}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enumerate loaded source files for symbol }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i SearchString} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i DotNetCallBack} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 159} of file {\b InsightHunter.cs}.}\par
}
{\xe \v EnumerateSymbols\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:EnumerateSymbols}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.EnumerateSymbols (string  {\i SearchString}, {\b InsightHunter_SymbolSearchCallBackRoutine}  {\i DotNetCallback}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enumerate loaded symbols for the debugged exe }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i SearchString} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i DotNetCallback} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 148} of file {\b InsightHunter.cs}.}\par
}
{\xe \v LoadDllSymbolInfo\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:LoadDllSymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.LoadDllSymbolInfo ({\b DebugEvent}  {\i DebugEvent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in resposne to a LOAD_DLL_DEBUG_EVENT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b DebugEvent}} \cell }{class instance containing a {\b DebugEventType.LoadDllEvent} event\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if ok, false on failuree\par
}}}{
Definition at line {\b 107} of file {\b InsightHunter.cs}.}\par
}
{\xe \v LoadExeSymbolInfo\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:LoadExeSymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.LoadExeSymbolInfo ({\b DebugEvent}  {\i debugEvent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in reponse to a CREATE_PROCESS_DEBUG_EVENT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i debugEvent} \cell }{{\b DebugEvent} class instance containing a {\b DebugEventType.CreateProcessEvent} event\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if ok, false on failuree\par
}}}{
Definition at line {\b 85} of file {\b InsightHunter.cs}.}\par
}
{\xe \v LoadExeSymbolInfo\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:LoadExeSymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.LoadExeSymbolInfo (IntPtr  {\i DebugEvent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in reponse to a CREATE_PROCESS_DEBUG_EVENT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i debugEvent} \cell }{{\b DebugEvent} class instance containing a {\b DebugEventType.CreateProcessEvent} event\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if ok, false on failuree\par
}}}{
Definition at line {\b 95} of file {\b InsightHunter.cs}.}\par
}
{\xe \v RefreshModules\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:RefreshModules}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.RefreshModules (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
reload loaded modules. \par
 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if it worked and false otherwise\par
}}}{
Definition at line {\b 167} of file {\b InsightHunter.cs}.}\par
}
{\xe \v SetParentWindow\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:SetParentWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.SetParentWindow (IntPtr  {\i HWND}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the parent window for the symbol engine/ debug help api }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i HWND} \cell }{Handle to Win32 Window that the debug help api will assume you're outputting info too\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 136} of file {\b InsightHunter.cs}.}\par
}
{\xe \v UnloadDllSymbolInfo\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:UnloadDllSymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.UnloadDllSymbolInfo ({\b DebugEvent}  {\i DebugEvent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not normally need to be called (if using the working thread<see cref=DebugModeType.WorkerThread"/> in <see cref="InsightProcess"/>. This tells the symbol engine to load an exe's debug data in resposne to a UNLOAD_DLL_DEBUG_EVENT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b DebugEvent}} \cell }{class instance containing a {\b DebugEventType.UnloadDllEvent} event\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if it worked, false otherwise\par
}}}{
Definition at line {\b 119} of file {\b InsightHunter.cs}.}\par
}
{\xe \v UnloadDllSymbolInfo\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:UnloadDllSymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.UnloadDllSymbolInfo (IntPtr  {\i DebugEvent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b InsightHunter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v DebugHelp_Version\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:DebugHelp_Version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugHelp_ApiVersionStruct} InsightSheath.Debugging.SymbolEngine.InsightHunter.DebugHelp_Version{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Version Data on the Debug Help API the symbol engine actuallly uses. }}\par
{
Definition at line {\b 207} of file {\b InsightHunter.cs}.}\par
}
{\xe \v DebugHelp_Version2\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:DebugHelp_Version2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b API_VERSION} InsightSheath.Debugging.SymbolEngine.InsightHunter.DebugHelp_Version2{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b InsightHunter.cs}.}\par
}
{\xe \v SymbolOptions\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:SymbolOptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SymbolOptionsFlags} InsightSheath.Debugging.SymbolEngine.InsightHunter.SymbolOptions{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify what you want to the symbol handler to too. }}\par
{
Definition at line {\b 192} of file {\b InsightHunter.cs}.}\par
}
{\xe \v SyncAccess\:InsightSheath.Debugging.SymbolEngine.InsightHunter}
{\xe \v InsightSheath.Debugging.SymbolEngine.InsightHunter\:SyncAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.SymbolEngine.InsightHunter.SyncAccess{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is true. This being true means the NativeClass {\b InsightHunter} synchronizes calls to the Debug Help Symbol Engine with a CRITICAL_SECTION Win32 Object }}\par
{
Definition at line {\b 177} of file {\b InsightHunter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/SymbolEngine/{\b InsightHunter.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.InsightMemory Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory}
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory data about an arbitrary process of your choice }}\par
Inheritance diagram for InsightSheath.Debugging.Process.InsightMemory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_process_1_1_insight_memory.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightMemory} (IntPtr that)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the wrapper class and point to the native pointer for the native side of the class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightMemory} (IntPtr that, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the wrapper class and point to the native pointer for the native side of the class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SetTargetProcess} (IntPtr Handle)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Choose which process this instance of the class is going to ask about via a Win32 Handle. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SetTargetProcess} (uint ProcessId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Choose which process this instance of the class is going to ask about via a process Handle. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ManualRefreshStats} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Trigger a manual refresh of the Memory information. Note if {\b AutoUpdateMemory} is true, this routine does NOT need to be called. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b InsightMemory} {\b CreateInstance} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b InsightMemory} from the unmanaged DLL and return a pointer encapsulated in the .NET class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b InsightMemory} {\b CreateInstance} (IntPtr Handle)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Duplicate an instance of {\b InsightMemory} from the passed pointer. \par
 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b InsightMemory} {\b CreateInstance} (uint Process)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b InsightMemory} and point it to read about the passed process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b InsightMemory} {\b DuplicateInstance} ({\b InsightMemory} Other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Duplicate an instance of {\b InsightMemory} from an existing copy. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invoke the proper clean up routine for {\b InsightMemory} for unmanaged resources and also managed if dispose is true }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AutoUpdateMemory}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Control if each call to one of these values will result in another call to get an updated value. The default is true; however, that can BE A PERFORMANCE PENALTY if you're getting the value individually for each setting frequently in a loop. Recommend False if you're reading them a lot }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProcessMemoryCount32}? {\b MemoryStatsBulk32}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the x86 bit version of the underlying structure containing the memory statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProcessMemoryCount64}? {\b MemoryStatsBulk64}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the x64 bit version of the underlying structure containing the memory statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PageFaultCount}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of page faults for the targeted process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PeakWorkingSetSize}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak working set size, in bytes for the targeted process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b WorkingSetSize}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current working set size in bytes for the targeted process }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPeakPagedPoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak paged pool usage in bytes for the targeted process }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPagedPoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current paged pool usage in bytes for the targeted process }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPeakNonPagedPoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak non paged pool usage in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaNonPagedPoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current non paged pool usage in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PageFileUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Commit Charge for the targeted process in bytes. This is the total private amount of memory allocated to the targeted process by Windows. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PeakPageFileUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak value in bytes of the Commit Charge during the targeted process's lifetime. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PrivateUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Same as {\b PageFileUsage} in a post Windows 7+/Windows Server 2012+ world per MSDN documentation }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory data about an arbitrary process of your choice \par
}{
Definition at line {\b 16} of file {\b InsightMemory.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InsightMemory\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:InsightMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Process.InsightMemory.InsightMemory (IntPtr  {\i that}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the wrapper class and point to the native pointer for the native side of the class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i that} \cell }{Non-null pointer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentNullException} \cell }{Raises this if argument is null\cell }
{\row }
}
}{
Definition at line {\b 65} of file {\b InsightMemory.cs}.}\par
}
{\xe \v InsightMemory\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:InsightMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Process.InsightMemory.InsightMemory (IntPtr  {\i that}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the wrapper class and point to the native pointer for the native side of the class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i that} \cell }{Non-null pointer\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{Ignored\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentNullException} \cell }{Raises this if argument is null\cell }
{\row }
}
}{
Definition at line {\b 81} of file {\b InsightMemory.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CreateInstance\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:CreateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b InsightMemory} InsightSheath.Debugging.Process.InsightMemory.CreateInstance (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b InsightMemory} from the unmanaged DLL and return a pointer encapsulated in the .NET class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns an instance of {\b InsightMemory} already set to point to the unmanaged DLL's code\par
}}}{
Definition at line {\b 22} of file {\b InsightMemory.cs}.}\par
}
{\xe \v CreateInstance\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:CreateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b InsightMemory} InsightSheath.Debugging.Process.InsightMemory.CreateInstance (IntPtr  {\i Handle}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Duplicate an instance of {\b InsightMemory} from the passed pointer. \par
 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Handle} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns an instance of {\b InsightMemory} already set to point to the same process that the passed pointer. Each instance can separately point to other pointers\par
}}}{
Definition at line {\b 32} of file {\b InsightMemory.cs}.}\par
}
{\xe \v CreateInstance\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:CreateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b InsightMemory} InsightSheath.Debugging.Process.InsightMemory.CreateInstance (uint  {\i Process}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b InsightMemory} and point it to read about the passed process. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b Process}} \cell }{process id to read about. It must be able to be opened for PROCESS_QUERY_INFORMATION and PROECSS_VM_READ \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns an instance of {\b InsightMemory} already set to point to the unmanaged DLL's code. The class is pointed to use the passed process\par
}}}{
Definition at line {\b 44} of file {\b InsightMemory.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.Process.InsightMemory.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invoke the proper clean up routine for {\b InsightMemory} for unmanaged resources and also managed if dispose is true }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources also.\cell }
{\row }
}
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 93} of file {\b InsightMemory.cs}.}\par
}
{\xe \v DuplicateInstance\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:DuplicateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b InsightMemory} InsightSheath.Debugging.Process.InsightMemory.DuplicateInstance ({\b InsightMemory}  {\i Other}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Duplicate an instance of {\b InsightMemory} from an existing copy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Other} \cell }{separate instance of {\b InsightMemory}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns a separate instance of {\b InsightMemory} already set.\par
}}}{
Definition at line {\b 55} of file {\b InsightMemory.cs}.}\par
}
{\xe \v ManualRefreshStats\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:ManualRefreshStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightMemory.ManualRefreshStats (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Trigger a manual refresh of the Memory information. Note if {\b AutoUpdateMemory} is true, this routine does NOT need to be called. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
returns true if it worked and false if it did not\par
}}}{
Definition at line {\b 176} of file {\b InsightMemory.cs}.}\par
}
{\xe \v SetTargetProcess\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:SetTargetProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightMemory.SetTargetProcess (IntPtr  {\i Handle}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Choose which process this instance of the class is going to ask about via a Win32 Handle. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Handle} \cell }{Win32 Native Handle that should at least have PROCESS_QUERY_INFORMATION and likely PROCESS_VM_READ. Handle is duplicated to a private variable in the native side. You don't need to keep this handle open afterwards\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if we successfully switched to this handle and false otherwise.\par
}}The Native routine duplicates the handle for PROCESS_QUERY_INFORMATION and PROCES_VM_READ. You do not need the keep the handle open afterwards\par
}{
Definition at line {\b 156} of file {\b InsightMemory.cs}.}\par
}
{\xe \v SetTargetProcess\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:SetTargetProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightMemory.SetTargetProcess (uint  {\i ProcessId}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Choose which process this instance of the class is going to ask about via a process Handle. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ProcessId} \cell }{The process should be able to be opened for PROCESS_QUERY_INFOMRAITON and likely PROCES_VM_READ. Handle is kept in a private variable for the life of the class until the Native copy is deleted\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if we successfully switched to this handle and false otherwise.\par
}}The Native routine opens the process for PROCESS_QUERY_INFORMATION and PROCES_VM_READ. You do not need the keep the handle open afterwards\par
}{
Definition at line {\b 167} of file {\b InsightMemory.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v AutoUpdateMemory\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:AutoUpdateMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightMemory.AutoUpdateMemory{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Control if each call to one of these values will result in another call to get an updated value. The default is true; however, that can BE A PERFORMANCE PENALTY if you're getting the value individually for each setting frequently in a loop. Recommend False if you're reading them a lot }}\par
{
Definition at line {\b 104} of file {\b InsightMemory.cs}.}\par
}
{\xe \v MemoryStatsBulk32\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:MemoryStatsBulk32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProcessMemoryCount32}? InsightSheath.Debugging.Process.InsightMemory.MemoryStatsBulk32{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the x86 bit version of the underlying structure containing the memory statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Know if you're asking about an x86 or x64 process. While this shouldn't crash, grabbing the wrong one will produce garbage values\par
}{
Definition at line {\b 121} of file {\b InsightMemory.cs}.}\par
}
{\xe \v MemoryStatsBulk64\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:MemoryStatsBulk64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProcessMemoryCount64}? InsightSheath.Debugging.Process.InsightMemory.MemoryStatsBulk64{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the x64 bit version of the underlying structure containing the memory statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Know if you're asking about an x86 or x64 process. While this shouldn't crash, grabbing the wrong one will produce garbage values\par
}{
Definition at line {\b 138} of file {\b InsightMemory.cs}.}\par
}
{\xe \v PageFaultCount\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:PageFaultCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.PageFaultCount{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of page faults for the targeted process. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 185} of file {\b InsightMemory.cs}.}\par
}
{\xe \v PageFileUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:PageFileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.PageFileUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the Commit Charge for the targeted process in bytes. This is the total private amount of memory allocated to the targeted process by Windows. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In a preWidows 7/ Server 2012 R2 World this is always zero. Please use {\b PrivateUsage} instead. Don't forget to {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 267} of file {\b InsightMemory.cs}.}\par
}
{\xe \v PeakPageFileUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:PeakPageFileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.PeakPageFileUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak value in bytes of the Commit Charge during the targeted process's lifetime. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 278} of file {\b InsightMemory.cs}.}\par
}
{\xe \v PeakWorkingSetSize\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:PeakWorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.PeakWorkingSetSize{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak working set size, in bytes for the targeted process. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 197} of file {\b InsightMemory.cs}.}\par
}
{\xe \v PrivateUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:PrivateUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.PrivateUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Same as {\b PageFileUsage} in a post Windows 7+/Windows Server 2012+ world per MSDN documentation }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 290} of file {\b InsightMemory.cs}.}\par
}
{\xe \v QuotaNonPagedPoolUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:QuotaNonPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.QuotaNonPagedPoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current non paged pool usage in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 255} of file {\b InsightMemory.cs}.}\par
}
{\xe \v QuotaPagedPoolUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:QuotaPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.QuotaPagedPoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current paged pool usage in bytes for the targeted process }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 231} of file {\b InsightMemory.cs}.}\par
}
{\xe \v QuotaPeakNonPagedPoolUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:QuotaPeakNonPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.QuotaPeakNonPagedPoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak non paged pool usage in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 242} of file {\b InsightMemory.cs}.}\par
}
{\xe \v QuotaPeakPagedPoolUsage\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:QuotaPeakPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.QuotaPeakPagedPoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the peak paged pool usage in bytes for the targeted process }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 220} of file {\b InsightMemory.cs}.}\par
}
{\xe \v WorkingSetSize\:InsightSheath.Debugging.Process.InsightMemory}
{\xe \v InsightSheath.Debugging.Process.InsightMemory\:WorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightMemory.WorkingSetSize{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current working set size in bytes for the targeted process }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ManualRefreshStats} if {\b AutoUpdateMemory} is false get up to date values.\par
}{
Definition at line {\b 208} of file {\b InsightMemory.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b InsightMemory.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.InsightProcess Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess}
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
choose an environment and spawn a process. This class is a wrapper for the C++ Class named "InsightProcess" implemented as a native DLL in the source PS_ProcessInformation.cpp and said class is the functionally the heart of the DLL. }}\par
Inheritance diagram for InsightSheath.Debugging.Process.InsightProcess:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_process_1_1_insight_process.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ProcessRestriction} : uint \{ {\b DropFileReadRequests} = 1
, {\b PositiveDenyFileReadRequests} = 2
, {\b NegativeDenyFileReadRequest} = 3
, {\b DropFileWriteRequests} = 4
, {\b PositiveDenyFileWriteRequest} = 5
, {\b NegativeDenyFileWriteRequests} = 6
, {\b NegativeDenyProcessSpawn} = 7
, {\b CommandProcessProperate} = 8
, {\b CommadMaxValue} = 255
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: something with this. (These are constants defined is PS_ProcessInformation.h and should be kept synced) That's the only reason i've not deleted this as I'm figuring I'll forgot to add it again }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SpecialCaseFlags} \{ {\b None} = 0
, {\b DebugOnlyThis} = 1
, {\b DebugChild} = 2
, {\b CreateSuspended} = 4
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to make 'typical' flags like ResumeThread, DebugProcess and DebugOnlyThisProcess without needing to look values up. You also can just look the values up. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightProcess} (IntPtr That)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return an instance of {\b InsightProcess} with it's native pointer set to the unmanaged part of InsightAPI's {\b InsightProcess} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightProcess} (IntPtr That, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return an instance of {\b InsightProcess} with it's native pointer set to the unmanaged part of InsightAPI's {\b InsightProcess} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override int {\b GetHashCode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a hash of the native pointer used by this current {\b InsightProcess} instance }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate int {\b DebugEventCallBackRoutine} (IntPtr {\b DebugEvent}, IntPtr ContinueState, IntPtr WaitTimer, IntPtr CustomArg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This delegate is used in the native worker thread to notify your .NET code when a debug event occurs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SpawnProcess} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Spawn the process contained within the underlying class. Return Value is the spawned process's ID on OK and 0 on failure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PulseDebugEventThead} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When Spawning a process with a DEBUG option and {\b DebugMode} is set to {\b DebugModeType.WorkerThread}, the native DLL spawns a thread to handle consuming events. The thread also using an native Event object to sync giving the events back to the caller so that the caller's GUI is not interrupted. Does not actually pulse event. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsightHunter} {\b GetSymbolHandler} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get an instance of the symbol handler uses by this process context. \par
 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UpdateSymbolEngine} (IntPtr DebugEnvent)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you don't want the worker thread, you'll need to call this routine to update symbol engine with new data when you get process debug events }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetExplicitEnviromentValue} (string Name, string Value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify an explicit environmental value. Values that match the default environment will overwrite the default onces for the process }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b GetExplicitEnviromentValue} (string Name)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get an explicit environmental value from a previous call to {\b SetExplicitEnviromentValue(string, string)} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartupInfoExW} {\b GetStartupInfoClass} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve instance of the class that handles the startup info management. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddDetoursDll} (string NewDllToForceLoad)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a DLL to list of Detours DLLs to force the target process to load on spawn. DOES NOT WORK if process is running }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ResetDetoursDllList} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the detours list back to empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b HelperDll_AddLoadLibraryPath} (string NewLocation)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an entry to the list of paths that the LoadLibraryXXXX() routines will check first before assuming normal search path }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HelperDll_ClearLoadLibraryPath} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove all entries for the HelperDll's priority LoadLibrary search path }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b HelperDll_GetLoadLibraryPathCount} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return how many entries are in the helperdll's priority LoadLibrary search path }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b HelperDll_IndexLoadLibraryPath} (int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a string index pointed to the helper DLL's search path (or null) if index out of bounds }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b InsightProcess} {\b CreateInstance} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b InsightProcess} on the native side and return an instance of the wrapper class {\b InsightProcess} set to use this native pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b SetDebugEventCallbackResponse} (IntPtr contStat, {\b DebugContState} Response)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For the {\b InsightProcess.DebugEventCallBackRoutine}. Use the IntPtr passed containing the location of where to write the continue state. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool Managed)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugModeType} {\b DebugMode}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a list of process ids the class has received via CREATE_PROCESS_DEBUG_EVENT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b RequestDebugPriv}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ask for the "SeDebugPriv" if spawning things to Debug PROCESS_DEBUG and PROCESS_DEBUG_ONLY_THIS }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugEventCallBackRoutine} {\b UserDebugCallRoutine}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get (or set) the routine that the debug worker thread will be calling. null (or unassigned) means use the default one which does nothing with events and exceptions, does not handle exceptions, and continues until it gets a single exit process debug event }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string[] {\b DetourList}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return an unmodifiable list of the entries in the Current Detours List. Please use other routines to change this entry. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ProcessName}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the process that was / will be launched. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ProcessArguments}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the process arguments that will be passed to the process when it is launched. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b WorkingDirectory}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the starting directory for the process to be launched }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DetourMustSucceed}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is TRUE. Should the code be unable to detour, process is killed and failure is returned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b InheritDefaultEnviroment}{\f2  [set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is false. If false, only environment variables you explicitly define will be in the spawned process. If true, the spawned process will inherit your debugger environment variables BUT the explicit variables you define will override the inherited ones. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b EnableSymbolEngine}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable or Disable the symbol engine. Symbol engine is active once first process starts. Disabling the engine means it will no longer get updates until enabled again. {\b DebugMode} should be set to {\b DebugModeType.WorkerThread} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b CreationFlags}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify process creation flags (or get them). Look at the CreateProcessA/W  flags online for more info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpecialCaseFlags} {\b ExtraFlags}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify some specific case flags. Or you can just directly Set CreationFlags itself. Implemented only in the C# wrapper. NOT IMPLMENTING in the C++ code. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProcessMemoryCount32}? {\b GetMemoryStatsBulk}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all the memory stats in once call and return a struct containing them. May return null if it can't fetch it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PageFaultCount}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of Page Faults for the main process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PeakWorkingSet}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peaked working set size, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b WorkingSet}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Working set size, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPeakPagePoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPagePoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPeakNonPagePoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked nonpaged pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaNonPagePoolUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current non page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PageFileUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commit change value for the process in bytes. Note: MSDN Windows 7/ Server 2008 says check {\b PrivateUsage} instead }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PeakPageFileUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak value of committed change during process lifetime }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PrivateUsage}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Private memory usage. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
choose an environment and spawn a process. This class is a wrapper for the C++ Class named "InsightProcess" implemented as a native DLL in the source PS_ProcessInformation.cpp and said class is the functionally the heart of the DLL. \par
}{
Definition at line {\b 58} of file {\b InsightProcess.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ProcessRestriction\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:ProcessRestriction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.Process.InsightProcess.ProcessRestriction} : uint}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: something with this. (These are constants defined is PS_ProcessInformation.h and should be kept synced) That's the only reason i've not deleted this as I'm figuring I'll forgot to add it again }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DropFileReadRequests\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DropFileReadRequests}
{\qr DropFileReadRequests{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Strip generic read from NtOpen/ NtCreate \par
}\cell }{\row }
{\xe \v PositiveDenyFileReadRequests\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PositiveDenyFileReadRequests}
{\qr PositiveDenyFileReadRequests{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
report success BUT do not actually open the file for reading \par
}\cell }{\row }
{\xe \v NegativeDenyFileReadRequest\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:NegativeDenyFileReadRequest}
{\qr NegativeDenyFileReadRequest{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Report access denied and do not open file \par
}\cell }{\row }
{\xe \v DropFileWriteRequests\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DropFileWriteRequests}
{\qr DropFileWriteRequests{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Strip generic write from NtOpen/ NtCreate \par
}\cell }{\row }
{\xe \v PositiveDenyFileWriteRequest\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PositiveDenyFileWriteRequest}
{\qr PositiveDenyFileWriteRequest{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
report success BUT do not actually open file for writing \par
}\cell }{\row }
{\xe \v NegativeDenyFileWriteRequests\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:NegativeDenyFileWriteRequests}
{\qr NegativeDenyFileWriteRequests{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
report access denied and don't open file \par
}\cell }{\row }
{\xe \v NegativeDenyProcessSpawn\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:NegativeDenyProcessSpawn}
{\qr NegativeDenyProcessSpawn{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
report failure and do not spawn Processes \par
}\cell }{\row }
{\xe \v CommandProcessProperate\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:CommandProcessProperate}
{\qr CommandProcessProperate{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
force the process to load the helper DLL. \par
}\cell }{\row }
{\xe \v CommadMaxValue\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:CommadMaxValue}
{\qr CommadMaxValue{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A theoretical cap for the values. \par
}\cell }{\row }
}
{
Definition at line {\b 116} of file {\b InsightProcess.cs}.}\par
}
{\xe \v SpecialCaseFlags\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:SpecialCaseFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b InsightSheath.Debugging.Process.InsightProcess.SpecialCaseFlags}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to make 'typical' flags like ResumeThread, DebugProcess and DebugOnlyThisProcess without needing to look values up. You also can just look the values up. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v None\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:None}
{\qr None{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
nothing needed \par
}\cell }{\row }
{\xe \v DebugOnlyThis\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DebugOnlyThis}
{\qr DebugOnlyThis{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the "DEBUG_ONLY_THIS_PROCESS" value when spawning the process \par
}\cell }{\row }
{\xe \v DebugChild\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DebugChild}
{\qr DebugChild{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the "DEBUG_PROCESS" value when spawning the process \par
}\cell }{\row }
{\xe \v CreateSuspended\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:CreateSuspended}
{\qr CreateSuspended{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the CREATE_SUSPENDED value when spawning the process \par
}\cell }{\row }
}
{
Definition at line {\b 174} of file {\b InsightProcess.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InsightProcess\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:InsightProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Process.InsightProcess.InsightProcess (IntPtr  {\i That}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return an instance of {\b InsightProcess} with it's native pointer set to the unmanaged part of InsightAPI's {\b InsightProcess} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i That} \cell }{non null instance of the unmanaged part of {\b InsightProcess}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentNullException} \cell }{Thrown if argument is equal to null."/>\cell }
{\row }
}
}{
Definition at line {\b 71} of file {\b InsightProcess.cs}.}\par
}
{\xe \v InsightProcess\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:InsightProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Process.InsightProcess.InsightProcess (IntPtr  {\i That}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return an instance of {\b InsightProcess} with it's native pointer set to the unmanaged part of InsightAPI's {\b InsightProcess} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i That} \cell }{non null instance of the unmanaged part of {\b InsightProcess}\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{Indicate if during GC cleanup, we'll get calling an unmanaged routine to delete this. You usually will want this to bve true unless your playing with multiple wraooe classes pointing to the same unmanaged pointer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentNullException} \cell }{Thrown if argument is equal to null."/>\cell }
{\row }
}
}{
Definition at line {\b 85} of file {\b InsightProcess.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddDetoursDll\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:AddDetoursDll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Debugging.Process.InsightProcess.AddDetoursDll (string  {\i NewDllToForceLoad}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a DLL to list of Detours DLLs to force the target process to load on spawn. DOES NOT WORK if process is running }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NewDllToForceLoad} \cell }{\cell }
{\row }
}
Currently detouring from parent to child with matching bitness works; however, x64 bit code is limited currently to detouring x64 processes. x86 can do both.\par
}{
Definition at line {\b 563} of file {\b InsightProcess.cs}.}\par
}
{\xe \v CreateInstance\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:CreateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b InsightProcess} InsightSheath.Debugging.Process.InsightProcess.CreateInstance (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b InsightProcess} on the native side and return an instance of the wrapper class {\b InsightProcess} set to use this native pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
returns instance of {\b InsightProcess} already set to us the unmanaged pointer of the class\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InvalidOperationException} \cell }{Should the unmanaged constructor routine fail to make an intance (return 0), this is thrown\cell }
{\row }
}
}{
Definition at line {\b 199} of file {\b InsightProcess.cs}.}\par
}
{\xe \v DebugEventCallBackRoutine\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DebugEventCallBackRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
delegate int InsightSheath.Debugging.Process.InsightProcess.DebugEventCallBackRoutine (IntPtr  {\i DebugEvent}, IntPtr  {\i ContinueState}, IntPtr  {\i WaitTimer}, IntPtr  {\i CustomArg})}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This delegate is used in the native worker thread to notify your .NET code when a debug event occurs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b DebugEvent}} \cell }{Pointer to a DEBUG_EVENT struct. {\b DebugEvent} to make a wrapper for it. IMPORTANT: Your stub is receiving a pointer off the unmanaged heap and should make your wrapper with FreeOnCleanUp=false aka DebugEvent(IntPtr)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ContinueState} \cell }{Pointer to a 4 byte value where to write how your debugger callback responded to the routine. {\b SetDebugEventCallbackResponse(IntPtr, DebugContState)} or LocalUnmanagedMemory.SetDebugEventCallbackResponse(IntPtr, DebugContState) or {\b MemoryNative.Poke4(IntPtr, uint)}\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i WaitTimer} \cell }{Pointer to a 4 byte value where to write how long to wait until receiving the next debug event. Note: If this timer expires, the worker thread is NOT going to call your callback. LocalUnmanagedMemory.Poke4(IntPtr, uint)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CustomArg} \cell }{Reserved. Always 0. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Your delegate should return 0 to keep going and non zero to quit. Value does not matter currently.\par
}}current C/C++ callback define for this is "typedef int(WINAPI* DebugEventCallBackRoutine)(LPDEBUG_EVENT lpCurEvent, DWORD* ContinueStatus, DWORD* WaitTimer, DWORD CustomArg);" \par
}}
{\xe \v Dispose\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.Process.InsightProcess.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources in addition to unmanaged.\cell }
{\row }
}
IMPORTANT! If your child class needs special needs beyond C/C++'s free(), override this and take care of them before calling base(). Should your custom class allocate multiple things for example WindowsUnicodeString's implementation for reading from remote processes Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(IntPtr, IntPtr, bool, bool), you will need to make a routine to properly free. That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory. Design checks: list type="number"> listheader> description > First, override disposal()  /listheader > item>  Nest, add a private variable in your class called isDisposed. Set this to true when your class's native pointer is cleaned up completely  /item > item> description>if ReferenceCounterNativeStaticContainer is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it. /item> item> description>if ReferenceCounterNativeStaticContainer IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null. If the reference counter is more than 0 when decreased, set native to null instead of disposing. /item> \par
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 776} of file {\b InsightProcess.cs}.}\par
}
{\xe \v GetExplicitEnviromentValue\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:GetExplicitEnviromentValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.Process.InsightProcess.GetExplicitEnviromentValue (string  {\i Name}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get an explicit environmental value from a previous call to {\b SetExplicitEnviromentValue(string, string)} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Name} \cell }{This is the name of the environment value to define. For example "PATH"\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns a string if the value exists or null if it does NOT\par
}}}{
Definition at line {\b 538} of file {\b InsightProcess.cs}.}\par
}
{\xe \v GetHashCode\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:GetHashCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override int InsightSheath.Debugging.Process.InsightProcess.GetHashCode (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a hash of the native pointer used by this current {\b InsightProcess} instance }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns a hash of the native pointer used by this current {\b InsightProcess} instance\par
}}}{
Definition at line {\b 97} of file {\b InsightProcess.cs}.}\par
}
{\xe \v GetStartupInfoClass\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:GetStartupInfoClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StartupInfoExW} InsightSheath.Debugging.Process.InsightProcess.GetStartupInfoClass (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve instance of the class that handles the startup info management. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Should the Native size for this instance of StartupInfo change to be allocated, this routine will need to be updated to prevent a memeory leak.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This routines an instance to a StartupInfoExW class that you can use to customize startup settings. This instance is part of the underlying instance of {\b InsightProcess} and should not be freed/deleted on clean up if duplicated\par
}}}{
Definition at line {\b 548} of file {\b InsightProcess.cs}.}\par
}
{\xe \v GetSymbolHandler\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:GetSymbolHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InsightHunter} InsightSheath.Debugging.Process.InsightProcess.GetSymbolHandler (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get an instance of the symbol handler uses by this process context. \par
 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 244} of file {\b InsightProcess.cs}.}\par
}
{\xe \v HelperDll_AddLoadLibraryPath\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:HelperDll_AddLoadLibraryPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightProcess.HelperDll_AddLoadLibraryPath (string  {\i NewLocation}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an entry to the list of paths that the LoadLibraryXXXX() routines will check first before assuming normal search path }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NewLocation} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 581} of file {\b InsightProcess.cs}.}\par
}
{\xe \v HelperDll_ClearLoadLibraryPath\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:HelperDll_ClearLoadLibraryPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Debugging.Process.InsightProcess.HelperDll_ClearLoadLibraryPath (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove all entries for the HelperDll's priority LoadLibrary search path }}\par
{
Definition at line {\b 589} of file {\b InsightProcess.cs}.}\par
}
{\xe \v HelperDll_GetLoadLibraryPathCount\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:HelperDll_GetLoadLibraryPathCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.InsightProcess.HelperDll_GetLoadLibraryPathCount (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return how many entries are in the helperdll's priority LoadLibrary search path }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 599} of file {\b InsightProcess.cs}.}\par
}
{\xe \v HelperDll_IndexLoadLibraryPath\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:HelperDll_IndexLoadLibraryPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.Process.InsightProcess.HelperDll_IndexLoadLibraryPath (int  {\i index}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a string index pointed to the helper DLL's search path (or null) if index out of bounds }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 609} of file {\b InsightProcess.cs}.}\par
}
{\xe \v PulseDebugEventThead\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PulseDebugEventThead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Debugging.Process.InsightProcess.PulseDebugEventThead (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When Spawning a process with a DEBUG option and {\b DebugMode} is set to {\b DebugModeType.WorkerThread}, the native DLL spawns a thread to handle consuming events. The thread also using an native Event object to sync giving the events back to the caller so that the caller's GUI is not interrupted. Does not actually pulse event. }}\par
{
Definition at line {\b 234} of file {\b InsightProcess.cs}.}\par
}
{\xe \v ResetDetoursDllList\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:ResetDetoursDllList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Debugging.Process.InsightProcess.ResetDetoursDllList (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the detours list back to empty. }}\par
{
Definition at line {\b 571} of file {\b InsightProcess.cs}.}\par
}
{\xe \v SetDebugEventCallbackResponse\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:SetDebugEventCallbackResponse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void InsightSheath.Debugging.Process.InsightProcess.SetDebugEventCallbackResponse (IntPtr  {\i contStat}, {\b DebugContState}  {\i Response}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For the {\b InsightProcess.DebugEventCallBackRoutine}. Use the IntPtr passed containing the location of where to write the continue state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i contStat} \cell }{Pointer receiving in the {\b InsightProcess.DebugEventCallBackRoutine} to process events\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Response} \cell }{Indicate your response to Windows using {\b DebugContState}\cell }
{\row }
}
}{
Definition at line {\b 798} of file {\b InsightProcess.cs}.}\par
}
{\xe \v SetExplicitEnviromentValue\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:SetExplicitEnviromentValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Debugging.Process.InsightProcess.SetExplicitEnviromentValue (string  {\i Name}, string  {\i Value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify an explicit environmental value. Values that match the default environment will overwrite the default onces for the process }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Name} \cell }{This is the name of the environment value to define. For example "PATH"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Value} \cell }{This is the value of the environment value to define. For example "C:\\Windows;C:\\Windows\\system32;\cell }
{\row }
}
}{
Definition at line {\b 528} of file {\b InsightProcess.cs}.}\par
}
{\xe \v SpawnProcess\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:SpawnProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InsightSheath.Debugging.Process.InsightProcess.SpawnProcess (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Spawn the process contained within the underlying class. Return Value is the spawned process's ID on OK and 0 on failure. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
process id \par
}}}{
Definition at line {\b 218} of file {\b InsightProcess.cs}.}\par
}
{\xe \v UpdateSymbolEngine\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:UpdateSymbolEngine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightProcess.UpdateSymbolEngine (IntPtr  {\i DebugEnvent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you don't want the worker thread, you'll need to call this routine to update symbol engine with new data when you get process debug events }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i DebugEnvent} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 259} of file {\b InsightProcess.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v CreationFlags\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:CreationFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.InsightProcess.CreationFlags{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify process creation flags (or get them). Look at the CreateProcessA/W  flags online for more info. }}\par
{
Definition at line {\b 466} of file {\b InsightProcess.cs}.}\par
}
{\xe \v DebugMode\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DebugMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugModeType} InsightSheath.Debugging.Process.InsightProcess.DebugMode{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a list of process ids the class has received via CREATE_PROCESS_DEBUG_EVENT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}Get a list of thread ids the class has received info about (CREATE_THREAD_DEBUG_EVENT) and return it. If there are know threads, you'll get nullinstead \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ProcessID} \cell }{\cell }
{\row }
}
Specify if you want the native DLL to handling spawning the process or if you're code will. Should you make it so your code will. You'll need to include WaitForDebugEvent() and ContinueDebugEvent() calls in a debugger loop \par
}{
Definition at line {\b 293} of file {\b InsightProcess.cs}.}\par
}
{\xe \v DetourList\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DetourList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string [] InsightSheath.Debugging.Process.InsightProcess.DetourList{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return an unmodifiable list of the entries in the Current Detours List. Please use other routines to change this entry. }}\par
{
Definition at line {\b 350} of file {\b InsightProcess.cs}.}\par
}
{\xe \v DetourMustSucceed\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:DetourMustSucceed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightProcess.DetourMustSucceed{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is TRUE. Should the code be unable to detour, process is killed and failure is returned. }}\par
{
Definition at line {\b 423} of file {\b InsightProcess.cs}.}\par
}
{\xe \v EnableSymbolEngine\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:EnableSymbolEngine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightProcess.EnableSymbolEngine{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable or Disable the symbol engine. Symbol engine is active once first process starts. Disabling the engine means it will no longer get updates until enabled again. {\b DebugMode} should be set to {\b DebugModeType.WorkerThread} }}\par
{
Definition at line {\b 449} of file {\b InsightProcess.cs}.}\par
}
{\xe \v ExtraFlags\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:ExtraFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SpecialCaseFlags} InsightSheath.Debugging.Process.InsightProcess.ExtraFlags{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify some specific case flags. Or you can just directly Set CreationFlags itself. Implemented only in the C# wrapper. NOT IMPLMENTING in the C++ code. }}\par
{
Definition at line {\b 507} of file {\b InsightProcess.cs}.}\par
}
{\xe \v GetMemoryStatsBulk\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:GetMemoryStatsBulk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProcessMemoryCount32}? InsightSheath.Debugging.Process.InsightProcess.GetMemoryStatsBulk{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all the memory stats in once call and return a struct containing them. May return null if it can't fetch it. }}\par
{
Definition at line {\b 627} of file {\b InsightProcess.cs}.}\par
}
{\xe \v InheritDefaultEnviroment\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:InheritDefaultEnviroment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightProcess.InheritDefaultEnviroment{\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default is false. If false, only environment variables you explicitly define will be in the spawned process. If true, the spawned process will inherit your debugger environment variables BUT the explicit variables you define will override the inherited ones. }}\par
{
Definition at line {\b 438} of file {\b InsightProcess.cs}.}\par
}
{\xe \v PageFaultCount\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PageFaultCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.PageFaultCount{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of Page Faults for the main process. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 644} of file {\b InsightProcess.cs}.}\par
}
{\xe \v PageFileUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PageFileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.PageFileUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commit change value for the process in bytes. Note: MSDN Windows 7/ Server 2008 says check {\b PrivateUsage} instead }}\par
{
Definition at line {\b 729} of file {\b InsightProcess.cs}.}\par
}
{\xe \v PeakPageFileUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PeakPageFileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.PeakPageFileUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak value of committed change during process lifetime }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 742} of file {\b InsightProcess.cs}.}\par
}
{\xe \v PeakWorkingSet\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PeakWorkingSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.PeakWorkingSet{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peaked working set size, in bytes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 656} of file {\b InsightProcess.cs}.}\par
}
{\xe \v PrivateUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:PrivateUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.PrivateUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Private memory usage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 754} of file {\b InsightProcess.cs}.}\par
}
{\xe \v ProcessArguments\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:ProcessArguments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.Process.InsightProcess.ProcessArguments{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the process arguments that will be passed to the process when it is launched. }}\par
{
Definition at line {\b 392} of file {\b InsightProcess.cs}.}\par
}
{\xe \v ProcessName\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:ProcessName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.Process.InsightProcess.ProcessName{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the process that was / will be launched. }}\par
{
Definition at line {\b 377} of file {\b InsightProcess.cs}.}\par
}
{\xe \v QuotaNonPagePoolUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:QuotaNonPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.QuotaNonPagePoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current non page pool usage, in bytes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 718} of file {\b InsightProcess.cs}.}\par
}
{\xe \v QuotaPagePoolUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:QuotaPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.QuotaPagePoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current page pool usage, in bytes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 693} of file {\b InsightProcess.cs}.}\par
}
{\xe \v QuotaPeakNonPagePoolUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:QuotaPeakNonPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.QuotaPeakNonPagePoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked nonpaged pool usage, in bytes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 706} of file {\b InsightProcess.cs}.}\par
}
{\xe \v QuotaPeakPagePoolUsage\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:QuotaPeakPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.QuotaPeakPagePoolUsage{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked page pool usage, in bytes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 680} of file {\b InsightProcess.cs}.}\par
}
{\xe \v RequestDebugPriv\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:RequestDebugPriv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Process.InsightProcess.RequestDebugPriv{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ask for the "SeDebugPriv" if spawning things to Debug PROCESS_DEBUG and PROCESS_DEBUG_ONLY_THIS }}\par
{
Definition at line {\b 308} of file {\b InsightProcess.cs}.}\par
}
{\xe \v UserDebugCallRoutine\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:UserDebugCallRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugEventCallBackRoutine} InsightSheath.Debugging.Process.InsightProcess.UserDebugCallRoutine{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get (or set) the routine that the debug worker thread will be calling. null (or unassigned) means use the default one which does nothing with events and exceptions, does not handle exceptions, and continues until it gets a single exit process debug event }}\par
{
Definition at line {\b 330} of file {\b InsightProcess.cs}.}\par
}
{\xe \v WorkingDirectory\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:WorkingDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.Process.InsightProcess.WorkingDirectory{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the starting directory for the process to be launched }}\par
{
Definition at line {\b 407} of file {\b InsightProcess.cs}.}\par
}
{\xe \v WorkingSet\:InsightSheath.Debugging.Process.InsightProcess}
{\xe \v InsightSheath.Debugging.Process.InsightProcess\:WorkingSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.InsightProcess.WorkingSet{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Working set size, in bytes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why is this hidden in Visual Studio's debug class Visualizer? Performance reasons while viewing in visual studio's debugger visualizer and the data can be gotten with {\b GetMemoryStatsBulk}\par
}{
Definition at line {\b 668} of file {\b InsightProcess.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b InsightProcess.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues}
{\xe \v InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues}
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
Inheritance diagram for InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_telemetry_1_1_io_device_telememtry_exception_common_values.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IoDeviceTelememtryExceptionCommonValues} (uint {\b ProcessId}, uint ThreadID, IntPtr ForceHandle, IntPtr LastError, {\b MachineType} {\b Type})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static readonly uint {\b InvalidHandleValue32} = (0xffffffff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you desire to make the call from the x86 process to CreateFileA/W file fail, call {\b SetForceHandle} with this has a value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static readonly ulong {\b InvalidHandleValue64} = (0xffffffffffffffff)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you desire to make the call from the x64 process to CreateFileA/W file fail, call {\b SetForceHandle} with this has a value }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 33} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IoDeviceTelememtryExceptionCommonValues\:InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues}
{\xe \v InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues\:IoDeviceTelememtryExceptionCommonValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues.IoDeviceTelememtryExceptionCommonValues (uint  {\i ProcessId}, uint  {\i ThreadID}, IntPtr  {\i ForceHandle}, IntPtr  {\i LastError}, {\b MachineType}  {\i Type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v InvalidHandleValue32\:InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues}
{\xe \v InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues\:InvalidHandleValue32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly uint InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues.InvalidHandleValue32 = (0xffffffff){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you desire to make the call from the x86 process to CreateFileA/W file fail, call {\b SetForceHandle} with this has a value }}\par
{
Definition at line {\b 45} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v InvalidHandleValue64\:InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues}
{\xe \v InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues\:InvalidHandleValue64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly ulong InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues.InvalidHandleValue64 = (0xffffffffffffffff){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you desire to make the call from the x64 process to CreateFileA/W file fail, call {\b SetForceHandle} with this has a value }}\par
{
Definition at line {\b 49} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b IoDeviceTelemetryReader.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
Inheritance diagram for InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_telemetry_1_1_io_device_telemetry_nt_create_file.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IoDeviceTelemetryNtCreateFile} (uint {\b ProcessId}, uint ThreadID, IntPtr ForceHandle, IntPtr LastError, {\b MachineType} {\b Type})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetReturnValue} (uint ReturnValue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the handle to overwrite if the debugger wants to replace what the call was attempting to open. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly IntPtr {\b FileOutHandle}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the first argument in NtCreateFile. That will indicate the out handle. For x64 bit processes this will be a 64-bit pointer. For x32 bit processes, this will be a 32-bit pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AccessMasks} {\b DesiredAccess}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Will contain the passed Access Request flags for NtCreateFile. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsObjectAttributes} {\b ObjectAttributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
May be null. If not null, this will be the Object Attributes read from that file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly IntPtr {\b IoStatusBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LARGE_INTEGER} {\b AllocationSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a {\b LARGE_INTEGER} struct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FileAttributes {\b FileAttributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The .NET file attributes for how the IO thing is being opened. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FileShare {\b ShareAccess}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The .NET shared mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b CreationOptions}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile for specifics. TODO: Include enum containing those values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NtCreationDisposition} {\b CreateDisposition}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NtCreateFile specific flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b EaBuffer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for x64 debugged processes. This is a 64-bit pointer. For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET settings. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b EaSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How many bytes is the EaBufffer. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 272} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IoDeviceTelemetryNtCreateFile\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:IoDeviceTelemetryNtCreateFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.IoDeviceTelemetryNtCreateFile (uint  {\i ProcessId}, uint  {\i ThreadID}, IntPtr  {\i ForceHandle}, IntPtr  {\i LastError}, {\b MachineType}  {\i Type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetReturnValue\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:SetReturnValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.SetReturnValue (uint  {\i ReturnValue}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the handle to overwrite if the debugger wants to replace what the call was attempting to open. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Occupies the same spot as the last error in reading the EXCEPTION_ARGS struct. Pointer to the RETURN VALUE to return from the NtCreateFile setting. \par
NtCreateFile does not appear to set last error based on documentation. Here Last Error is the return value given back to the debugged process. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ReturnValue} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 339} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v AllocationSize\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:AllocationSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LARGE_INTEGER} InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.AllocationSize}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a {\b LARGE_INTEGER} struct. }}\par
{
Definition at line {\b 298} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v CreateDisposition\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:CreateDisposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NtCreationDisposition} InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.CreateDisposition}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NtCreateFile specific flags. }}\par
{
Definition at line {\b 314} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v CreationOptions\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:CreationOptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.CreationOptions}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile for specifics. TODO: Include enum containing those values. }}\par
{
Definition at line {\b 310} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v DesiredAccess\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:DesiredAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AccessMasks} InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.DesiredAccess}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Will contain the passed Access Request flags for NtCreateFile. }}\par
{
Definition at line {\b 286} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v EaBuffer\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:EaBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.EaBuffer}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for x64 debugged processes. This is a 64-bit pointer. For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET settings. }}\par
{
Definition at line {\b 318} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v EaSize\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:EaSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.EaSize}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How many bytes is the EaBufffer. }}\par
{
Definition at line {\b 322} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v FileAttributes\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:FileAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FileAttributes InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.FileAttributes}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The .NET file attributes for how the IO thing is being opened. }}\par
{
Definition at line {\b 302} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v FileOutHandle\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:FileOutHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly IntPtr InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.FileOutHandle}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the first argument in NtCreateFile. That will indicate the out handle. For x64 bit processes this will be a 64-bit pointer. For x32 bit processes, this will be a 32-bit pointer. }}\par
{
Definition at line {\b 282} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v IoStatusBlock\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:IoStatusBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly IntPtr InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.IoStatusBlock}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for x64 debugged processes. This is a 64-bit pointer. For x32-bit processes, this is a 32-bit pointer that may be pretended to be 64-bit depending on .NET \par
}{
Definition at line {\b 294} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v ObjectAttributes\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:ObjectAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WindowsObjectAttributes} InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.ObjectAttributes}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
May be null. If not null, this will be the Object Attributes read from that file. }}\par
{
Definition at line {\b 290} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v ShareAccess\:InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile\:ShareAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FileShare InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile.ShareAccess}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The .NET shared mode. }}\par
{
Definition at line {\b 306} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b IoDeviceTelemetryReader.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.IoDeviceTelemetyCreateFile Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This structure contains data from an exception generated via CreateFileA/W. }}\par
Inheritance diagram for InsightSheath.Telemetry.IoDeviceTelemetyCreateFile:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_telemetry_1_1_io_device_telemety_create_file.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IoDeviceTelemetyCreateFile} (uint dwProcess, uint dwThread, IntPtr HandlePtr, IntPtr ErrorPtr, {\b MachineType} {\b Type})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b FileName}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Name of the file the debugged process is trying to open/access/ect.... }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AccessMasks} {\b DesiredAccess}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desired access for the target file }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FileShare {\b SharedMode}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Will the debugged process try to open for sharing? }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b SecurityAttrib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debugged process's requested security attributes (IMPORTANT! this points to virtual memory in {\b THAT}  process, not yours.) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CreationDisposition} {\b CreateDisposition}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creation disposition }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b FlagsAndAttributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags and attributes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b TemplateFile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template file that's usually (but NOT always) null. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This structure contains data from an exception generated via CreateFileA/W. \par
}{
Definition at line {\b 350} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IoDeviceTelemetyCreateFile\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:IoDeviceTelemetyCreateFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.IoDeviceTelemetyCreateFile (uint  {\i dwProcess}, uint  {\i dwThread}, IntPtr  {\i HandlePtr}, IntPtr  {\i ErrorPtr}, {\b MachineType}  {\i Type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 352} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CreateDisposition\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:CreateDisposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CreationDisposition} InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.CreateDisposition}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creation disposition }}\par
{
Definition at line {\b 383} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v DesiredAccess\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:DesiredAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AccessMasks} InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.DesiredAccess}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desired access for the target file }}\par
{
Definition at line {\b 371} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v FileName\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:FileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.FileName}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Name of the file the debugged process is trying to open/access/ect.... }}\par
{
Definition at line {\b 367} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v FlagsAndAttributes\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:FlagsAndAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.FlagsAndAttributes}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags and attributes }}\par
{
Definition at line {\b 387} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v SecurityAttrib\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:SecurityAttrib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.SecurityAttrib}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debugged process's requested security attributes (IMPORTANT! this points to virtual memory in {\b THAT}  process, not yours.) }}\par
{
Definition at line {\b 379} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v SharedMode\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:SharedMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FileShare InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.SharedMode}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Will the debugged process try to open for sharing? }}\par
{
Definition at line {\b 375} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v TemplateFile\:InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}
{\xe \v InsightSheath.Telemetry.IoDeviceTelemetyCreateFile\:TemplateFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Telemetry.IoDeviceTelemetyCreateFile.TemplateFile}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template file that's usually (but NOT always) null. }}\par
{
Definition at line {\b 391} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b IoDeviceTelemetryReader.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Telemetry.LARGE_INTEGER Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Telemetry.LARGE_INTEGER}
{\xe \v InsightSheath.Telemetry.LARGE_INTEGER}
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Large structure for getting {\b LARGE_INTEGER} structs into .Net Hands }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
UInt32 {\b LowPart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Int32 {\b HighPart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuadPart}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Large structure for getting {\b LARGE_INTEGER} structs into .Net Hands \par
}{
Definition at line {\b 21} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v HighPart\:InsightSheath.Telemetry.LARGE_INTEGER}
{\xe \v InsightSheath.Telemetry.LARGE_INTEGER\:HighPart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Int32 InsightSheath.Telemetry.LARGE_INTEGER.HighPart}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v LowPart\:InsightSheath.Telemetry.LARGE_INTEGER}
{\xe \v InsightSheath.Telemetry.LARGE_INTEGER\:LowPart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
UInt32 InsightSheath.Telemetry.LARGE_INTEGER.LowPart}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\xe \v QuadPart\:InsightSheath.Telemetry.LARGE_INTEGER}
{\xe \v InsightSheath.Telemetry.LARGE_INTEGER\:QuadPart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Telemetry.LARGE_INTEGER.QuadPart}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b IoDeviceTelemetryReader.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Telemetry/{\b IoDeviceTelemetryReader.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Abstract.NativeStaticContainer Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/C++'s free(). If said Native class needs special free requirements, overwrite {\b Dispose(bool)} with a a call to a routine to properly free it. If your wrapper is handing out multiple natiove pointers to the same object, you'll need something like {\b ReferenceCounterNativeStaticContainer} }}\par
Inheritance diagram for InsightSheath.Abstract.NativeStaticContainer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_abstract_1_1_native_static_container.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b Equals} (object obj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NativeStaticContrain compares both {\b Native} pointers and returns true if equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override int {\b GetHashCode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grab a hash of the native pointer. Logic being if two hashes are the same, we're holding the same native struct/class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NativeStaticContainer} (IntPtr {\b Native})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NativeStaticContainer} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the class with the object to specify if we free it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Dispose} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Trigger cleanup of this {\b NativeStaticContainer} based class }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearNative} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
place in disposable and call it after calling the current unmanaged cleanup routine. \par
 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static ArgumentNullException {\b WrapperConstructorReceivedNullPointerErrorException} (string ArgumentPrefix, string AlternativeInstance, string ArgumentName)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to make the ArgumentNullException message using {\b ReceivedNullPointerOnConstructor} template }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b Native}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds a physical unmanaged pointer to a relevant structure. Child classes use this }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b FreeOnCleanupContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the free on cleanup value. Recommend only disposal() routines modify this. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b UnmanagedConstructorReturnedNull} = "The unmanaged routine \{0\} to build the unmanaged part of \{1\} returned null."\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is using in {\b NativeStaticContainer} based classes when their static builder (For example InsightProcess.CreateInstance) receive null from the unmanaged constructor routine }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b ReceivedNullPointerOnConstructor} = "\{0\} Cannot be 0. Use \{1\} to make a new instance and use this to point this managed wrapper to a native instance of the class: (\{2\}\}"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used in {\b NativeStaticContainer} based classes a template to an exception message to indicate it received null when being built }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b NativePointer}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WARNING! WARNING! WARNING! Return the underlying pointer. Should this block of memory be freed (releases/ deleted), the instance of this {\b NativeStaticContainer} will break. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b FreeOnCleanup}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Conditional free on dispose. Set this to true if you're manipulated a block of unmanaged memory dynamically located by the API. Set to false if you're working with a previously allocated structure or the struct was given as part of a callback to you or part of a larger structure }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDisposed}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Was this class disposed? }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/C++'s free(). If said Native class needs special free requirements, overwrite {\b Dispose(bool)} with a a call to a routine to properly free it. If your wrapper is handing out multiple natiove pointers to the same object, you'll need something like {\b ReferenceCounterNativeStaticContainer} \par
}{
Definition at line {\b 15} of file {\b NativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NativeStaticContainer\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:NativeStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.NativeStaticContainer.NativeStaticContainer (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{The Native pointer to keep track of.\cell }
{\row }
}
}{
Definition at line {\b 71} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v NativeStaticContainer\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:NativeStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.NativeStaticContainer.NativeStaticContainer (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the class with the object to specify if we free it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to the structure this class will reference\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{if true then the structure is freed via RemoteRead_SimpleFree() which itself is a call to C/C++'s free() . Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated\cell }
{\row }
}
FreeOnCleanup is a bit dependent on your knowledge of the native code. If the native pointer points to something dynamically allocated with malloc() / HeapAlloc(), specify true. If it's declared in the Native source directly or on the stack as a function variable, use false.\par
}{
Definition at line {\b 82} of file {\b NativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ClearNative\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:ClearNative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Abstract.NativeStaticContainer.ClearNative (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
place in disposable and call it after calling the current unmanaged cleanup routine. \par
 }}\par
{
Definition at line {\b 103} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Abstract.NativeStaticContainer.Dispose (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Trigger cleanup of this {\b NativeStaticContainer} based class }}\par
{
Definition at line {\b 192} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void InsightSheath.Abstract.NativeStaticContainer.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources in addition to unmanaged.\cell }
{\row }
}
IMPORTANT! If your child class needs special needs beyond C/C++'s free(), override this and take care of them before calling base(). Should your custom class allocate multiple things for example WindowsUnicodeString's implementation for reading from remote processes Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(IntPtr, IntPtr, bool, bool), you will need to make a routine to properly free. That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory. Design checks: list type="number"> listheader> description > First, override disposal()  /listheader > item>  Nest, add a private variable in your class called isDisposed. Set this to true when your class's native pointer is cleaned up completely  /item > item> description>if {\b ReferenceCounterNativeStaticContainer} is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it. /item> item> description>if {\b ReferenceCounterNativeStaticContainer} IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null. If the reference counter is more than 0 when decreased, set native to null instead of disposing. /item> \par
}{
Reimplemented in {\b InsightSheath.Abstract.PlatformDependantNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Debugging.DebugEventStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Debugging.DebugEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Debugging.Process.InsightMemory} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Debugging.Thread.ThreadContext} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Debugging.Thread.Wow64Context} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Win32Struct.StartupInfoExW} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Win32Struct.WindowsObjectAttributes} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Win32Struct.WindowsUnicodeString} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b InsightSheath.Debugging.Process.InsightProcess} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 158} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v Equals\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:Equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool InsightSheath.Abstract.NativeStaticContainer.Equals (object  {\i obj}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NativeStaticContrain compares both {\b Native} pointers and returns true if equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i obj} \cell }{the other one\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 45} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v GetHashCode\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:GetHashCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override int InsightSheath.Abstract.NativeStaticContainer.GetHashCode (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grab a hash of the native pointer. Logic being if two hashes are the same, we're holding the same native struct/class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 62} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v WrapperConstructorReceivedNullPointerErrorException\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:WrapperConstructorReceivedNullPointerErrorException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static ArgumentNullException InsightSheath.Abstract.NativeStaticContainer.WrapperConstructorReceivedNullPointerErrorException (string  {\i ArgumentPrefix}, string  {\i AlternativeInstance}, string  {\i ArgumentName}){\f2 [inline]}, {\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to make the ArgumentNullException message using {\b ReceivedNullPointerOnConstructor} template }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentPrefix} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i AlternativeInstance} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentName} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 35} of file {\b NativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v FreeOnCleanupContainer\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:FreeOnCleanupContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Abstract.NativeStaticContainer.FreeOnCleanupContainer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the free on cleanup value. Recommend only disposal() routines modify this. }}\par
{
Definition at line {\b 125} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v Native\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:Native}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Abstract.NativeStaticContainer.Native{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds a physical unmanaged pointer to a relevant structure. Child classes use this }}\par
{
Definition at line {\b 110} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v ReceivedNullPointerOnConstructor\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:ReceivedNullPointerOnConstructor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string InsightSheath.Abstract.NativeStaticContainer.ReceivedNullPointerOnConstructor = "\{0\} Cannot be 0. Use \{1\} to make a new instance and use this to point this managed wrapper to a native instance of the class: (\{2\}\}"{\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used in {\b NativeStaticContainer} based classes a template to an exception message to indicate it received null when being built }}\par
{
Definition at line {\b 24} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v UnmanagedConstructorReturnedNull\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:UnmanagedConstructorReturnedNull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string InsightSheath.Abstract.NativeStaticContainer.UnmanagedConstructorReturnedNull = "The unmanaged routine \{0\} to build the unmanaged part of \{1\} returned null."{\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is using in {\b NativeStaticContainer} based classes when their static builder (For example InsightProcess.CreateInstance) receive null from the unmanaged constructor routine }}\par
{
Definition at line {\b 20} of file {\b NativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v FreeOnCleanup\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:FreeOnCleanup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Abstract.NativeStaticContainer.FreeOnCleanup{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Conditional free on dispose. Set this to true if you're manipulated a block of unmanaged memory dynamically located by the API. Set to false if you're working with a previously allocated structure or the struct was given as part of a callback to you or part of a larger structure }}\par
{
Definition at line {\b 114} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v IsDisposed\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:IsDisposed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Abstract.NativeStaticContainer.IsDisposed{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Was this class disposed? }}\par
{
Definition at line {\b 134} of file {\b NativeStaticContainer.cs}.}\par
}
{\xe \v NativePointer\:InsightSheath.Abstract.NativeStaticContainer}
{\xe \v InsightSheath.Abstract.NativeStaticContainer\:NativePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Abstract.NativeStaticContainer.NativePointer{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
WARNING! WARNING! WARNING! Return the underlying pointer. Should this block of memory be freed (releases/ deleted), the instance of this {\b NativeStaticContainer} will break. }}\par
{
Definition at line {\b 92} of file {\b NativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Abstracts/{\b NativeStaticContainer.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.ObjectAttributes32 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32}
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a Wow / x86 bit process. Specs from  }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectAttributes64} {\b Promotion} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a 64-bit version with the 32-bit values promoted to 64-bit. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Length}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Length of the struct. For x86, a proper value is 24. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b RootDirectory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte potentially 0 Handle value indicated the root that {\b ObjectName} specifies. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ObjectName}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a 4 byte pointer to a {\b UnicodeString32} struct. This is the name of the item this struct points too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Attributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte value indicating object attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SecurityDescriptor}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte pointer to the defined security descriptor. May be (null/0) if default is fine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SecurityQoS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte pointer to the defined security quality of service. May be (null/0) if default is fine. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a Wow / x86 bit process. Specs from  \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For x86 (32-bit) processes, handles, pointers, uints are all 4 bytes long. This is not true for x64 processes and that's why {\b ObjectAttributes64} exists\par
}{
Definition at line {\b 17} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Promotion\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:Promotion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ObjectAttributes64} InsightSheath.Win32Struct.ObjectAttributes32.Promotion (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a 64-bit version with the 32-bit values promoted to 64-bit. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 48} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Attributes\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:Attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes32.Attributes}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte value indicating object attributes. }}\par
{
Definition at line {\b 34} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\xe \v Length\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes32.Length}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Length of the struct. For x86, a proper value is 24. }}\par
{
Definition at line {\b 22} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\xe \v ObjectName\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:ObjectName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes32.ObjectName}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a 4 byte pointer to a {\b UnicodeString32} struct. This is the name of the item this struct points too }}\par
{
Definition at line {\b 30} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\xe \v RootDirectory\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:RootDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes32.RootDirectory}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte potentially 0 Handle value indicated the root that {\b ObjectName} specifies. }}\par
{
Definition at line {\b 26} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\xe \v SecurityDescriptor\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:SecurityDescriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes32.SecurityDescriptor}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte pointer to the defined security descriptor. May be (null/0) if default is fine. }}\par
{
Definition at line {\b 38} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\xe \v SecurityQoS\:InsightSheath.Win32Struct.ObjectAttributes32}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes32\:SecurityQoS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes32.SecurityQoS}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte pointer to the defined security quality of service. May be (null/0) if default is fine. }}\par
{
Definition at line {\b 42} of file {\b ObjectAttributes_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b ObjectAttributes_x86.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.ObjectAttributes64 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64}
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a 64-bit process Specs from  }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Length}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Length of this struct. For x64 bit code, a proper one is 48. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b RootDirectory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte potentially 0 Handle value indicated the root that {\b ObjectName} specifies. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b ObjectName}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a 8 byte pointer to a {\b UnicodeString64} struct. This is the name of the item this struct points too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Attributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte value indicating object attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b SecurityDescriptor}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte pointer to the defined security descriptor. May be (null/0) if default is fine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b SecurityQoS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte pointer to the defined security quality of service. May be (null/0) if default is fine. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a 64-bit process Specs from  \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IMPORTANT! Pointer values and handle are 8 bytes long for x64 bit processes instead of 4 bytes. This is why we need to define two structs. Other struct is {\b ObjectAttributes32} \par
}{
Definition at line {\b 18} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Attributes\:InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64\:Attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes64.Attributes}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte value indicating object attributes. }}\par
{
Definition at line {\b 35} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\xe \v Length\:InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.ObjectAttributes64.Length}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Length of this struct. For x64 bit code, a proper one is 48. }}\par
{
Definition at line {\b 23} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\xe \v ObjectName\:InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64\:ObjectName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.ObjectAttributes64.ObjectName}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a 8 byte pointer to a {\b UnicodeString64} struct. This is the name of the item this struct points too }}\par
{
Definition at line {\b 31} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\xe \v RootDirectory\:InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64\:RootDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.ObjectAttributes64.RootDirectory}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte potentially 0 Handle value indicated the root that {\b ObjectName} specifies. }}\par
{
Definition at line {\b 27} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\xe \v SecurityDescriptor\:InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64\:SecurityDescriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.ObjectAttributes64.SecurityDescriptor}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte pointer to the defined security descriptor. May be (null/0) if default is fine. }}\par
{
Definition at line {\b 39} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\xe \v SecurityQoS\:InsightSheath.Win32Struct.ObjectAttributes64}
{\xe \v InsightSheath.Win32Struct.ObjectAttributes64\:SecurityQoS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.ObjectAttributes64.SecurityQoS}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte pointer to the defined security quality of service. May be (null/0) if default is fine. }}\par
{
Definition at line {\b 43} of file {\b ObjectAttributes_x64.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b ObjectAttributes_x64.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Abstract.OnDemandMarshalNativeStruct Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct. }}\par
Inheritance diagram for InsightSheath.Abstract.OnDemandMarshalNativeStruct:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_abstract_1_1_on_demand_marshal_native_struct.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OnDemandMarshalNativeStruct} (IntPtr {\b Native})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OnDemandMarshalNativeStruct} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MarshalToNative} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
public access to protects routine to send changes to the managed struct copy back to native land. If the class does not implement or that's not a valid option for the class, an exception may occure }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b Blit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should marshal the relevant struct from the native pointer if {\b WasBlit} is not set and set afterwards. Accessors should call this each time they are called to retrieve values. Additionally, if the .NET struct will need to make changes to the land, you're going to need to call {\b Apply} BEFORE reading the managed struct. Not doing this will revert your changes on the managed side to the equivalent native values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b Apply} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should convert the relevant struct in .NET land and place it in the {\b Native} if the protected value {\b StaleManagedStruct} was set to true Unmanaged land. It should throw a InvalidOperationException if it's not a valid thing (native pointer is known to be read only memory/ exist for a callback function for example) NotImplementedException exception if not done yet ecct... }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b WasBlit}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Blit} should set this to true after last reading successful marshaling was done in {\b Blit}from the native side. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b StaleManagedStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When an accessory sets property in the managed struct that needs to be updated in native land, set this. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct. \par
}{
Definition at line {\b 13} of file {\b OnDemandMarshalNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v OnDemandMarshalNativeStruct\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:OnDemandMarshalNativeStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.OnDemandMarshalNativeStruct.OnDemandMarshalNativeStruct (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b OnDemandMarshalNativeStruct.cs}.}\par
}
{\xe \v OnDemandMarshalNativeStruct\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:OnDemandMarshalNativeStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.OnDemandMarshalNativeStruct.OnDemandMarshalNativeStruct (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b OnDemandMarshalNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Apply\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:Apply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void InsightSheath.Abstract.OnDemandMarshalNativeStruct.Apply (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should convert the relevant struct in .NET land and place it in the {\b Native} if the protected value {\b StaleManagedStruct} was set to true Unmanaged land. It should throw a InvalidOperationException if it's not a valid thing (native pointer is known to be read only memory/ exist for a callback function for example) NotImplementedException exception if not done yet ecct... }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InvalidOperationException} \cell }{Throw this when writing back to the unmanaged struct is not valid (for example read only memory or a local variable in a callback routine allocated on Unamanged heap)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NotSupportedException} \cell }{Throw this when writing back to the unmanaged struct is not valid (for example read only memory or a local variable in a callback routine allocated on Unamanged heap)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NotImplementedException} \cell }{The routine was added but not implemented yet.\cell }
{\row }
}
}{
Implemented in {\b InsightSheath.Debugging.Thread.Wow64Context} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Win32Struct.WindowsObjectAttributes} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b InsightSheath.Win32Struct.WindowsUnicodeString} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v Blit\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:Blit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void InsightSheath.Abstract.OnDemandMarshalNativeStruct.Blit (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should marshal the relevant struct from the native pointer if {\b WasBlit} is not set and set afterwards. Accessors should call this each time they are called to retrieve values. Additionally, if the .NET struct will need to make changes to the land, you're going to need to call {\b Apply} BEFORE reading the managed struct. Not doing this will revert your changes on the managed side to the equivalent native values. }}\par
{
Implemented in {\b InsightSheath.Debugging.Thread.Wow64Context} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b InsightSheath.Win32Struct.WindowsObjectAttributes} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b InsightSheath.Win32Struct.WindowsUnicodeString} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v MarshalToNative\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:MarshalToNative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InsightSheath.Abstract.OnDemandMarshalNativeStruct.MarshalToNative (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
public access to protects routine to send changes to the managed struct copy back to native land. If the class does not implement or that's not a valid option for the class, an exception may occure }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InvalidOperationException} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NotSupportedException} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NotImplementedException} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 48} of file {\b OnDemandMarshalNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v StaleManagedStruct\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:StaleManagedStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Abstract.OnDemandMarshalNativeStruct.StaleManagedStruct{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When an accessory sets property in the managed struct that needs to be updated in native land, set this. }}\par
{
Definition at line {\b 60} of file {\b OnDemandMarshalNativeStruct.cs}.}\par
}
{\xe \v WasBlit\:InsightSheath.Abstract.OnDemandMarshalNativeStruct}
{\xe \v InsightSheath.Abstract.OnDemandMarshalNativeStruct\:WasBlit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Abstract.OnDemandMarshalNativeStruct.WasBlit{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Blit} should set this to true after last reading successful marshaling was done in {\b Blit}from the native side. }}\par
{
Definition at line {\b 55} of file {\b OnDemandMarshalNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Abstracts/{\b OnDemandMarshalNativeStruct.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Abstract.PlatformDependantNativeStruct Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct}
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target. }}\par
Inheritance diagram for InsightSheath.Abstract.PlatformDependantNativeStruct:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_abstract_1_1_platform_dependant_native_struct.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlatformDependantNativeStruct} (IntPtr {\b Native})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlatformDependantNativeStruct} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the class with the object to specify if we free it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlatformDependantNativeStruct} (IntPtr {\b Native}, bool {\b FreeOnCleanup}, {\b StructModeType} {\b StructType})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlatformDependantNativeStruct} (IntPtr {\b Native}, {\b StructModeType} {\b StructType})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make an instance of this class with the {\b StructType} specified. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Platform Dependant native structure does not allocate anything and does nothing other than hold the specifics for the child class. Specifically struct }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static string {\b MachineTypeUnspecifiedErrorMakeMessage} (string Type0, string Type1, string classname)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static InvalidOperationException {\b ThrowNewInvalidOpMessage} (string classname)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This throws a message wither everything except class name prefilled by calling {\b MachineTypeUnspecifiedErrorMakeMessage(string, string, string)} }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StructModeType} {\b StructTypeContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
protected container for {\b StructType} }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b MachineTypeUnspecifiedError} = "Pick which version of the struct to use. Set {\b StructType} to either \{0\} or \{1\} then attempt to access. Class name: \{2\}"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
canned error message for when user does not specify a machine. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StructModeType} {\b StructType}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the type of structure that's correct for this class to use. Also resets a flag to trigger Marshalling from that native side when set. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target. \par
}{
Definition at line {\b 14} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PlatformDependantNativeStruct\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:PlatformDependantNativeStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.PlatformDependantNativeStruct.PlatformDependantNativeStruct (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\xe \v PlatformDependantNativeStruct\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:PlatformDependantNativeStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.PlatformDependantNativeStruct.PlatformDependantNativeStruct (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of the class with the object to specify if we free it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to the structure this class will reference\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{if true then the structure is freed via RemoteRead_SimpleFree() which itself is a call to C/C++'s free() . Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated\cell }
{\row }
}
FreeOnCleanup is a bit dependent on your knowledge of the native code. If the native pointer points to something dynamically allocated with malloc() / HeapAlloc(), specify true. If it's declared in the Native source directly or on the stack as a function variable, use false\par
}{
Definition at line {\b 27} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\xe \v PlatformDependantNativeStruct\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:PlatformDependantNativeStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.PlatformDependantNativeStruct.PlatformDependantNativeStruct (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}, {\b StructModeType}  {\i StructType}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\xe \v PlatformDependantNativeStruct\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:PlatformDependantNativeStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.PlatformDependantNativeStruct.PlatformDependantNativeStruct (IntPtr  {\i Native}, {\b StructModeType}  {\i StructType}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make an instance of this class with the {\b StructType} specified. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Pointer to an unmanaged memory block this class is dealing with.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i StructType} \cell }{Structures with points are different sizes depending on if they're lifting from x86 or x64 code. Indicate if this is a StructModeType.Machinex86 (for 4 byte pointers) or a StructModeType.Machinex64 for 8 byte pointers\cell }
{\row }
}
}{
Definition at line {\b 42} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Dispose\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Abstract.PlatformDependantNativeStruct.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Platform Dependant native structure does not allocate anything and does nothing other than hold the specifics for the child class. Specifically struct }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{\cell }
{\row }
}
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b InsightSheath.Win32Struct.WindowsObjectAttributes} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b InsightSheath.Win32Struct.WindowsUnicodeString} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 51} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\xe \v MachineTypeUnspecifiedErrorMakeMessage\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:MachineTypeUnspecifiedErrorMakeMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static string InsightSheath.Abstract.PlatformDependantNativeStruct.MachineTypeUnspecifiedErrorMakeMessage (string  {\i Type0}, string  {\i Type1}, string  {\i classname}){\f2 [inline]}, {\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\xe \v ThrowNewInvalidOpMessage\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:ThrowNewInvalidOpMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static InvalidOperationException InsightSheath.Abstract.PlatformDependantNativeStruct.ThrowNewInvalidOpMessage (string  {\i classname}){\f2 [inline]}, {\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This throws a message wither everything except class name prefilled by calling {\b MachineTypeUnspecifiedErrorMakeMessage(string, string, string)} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i classname} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 89} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v MachineTypeUnspecifiedError\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:MachineTypeUnspecifiedError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string InsightSheath.Abstract.PlatformDependantNativeStruct.MachineTypeUnspecifiedError = "Pick which version of the struct to use. Set {\b StructType} to either \{0\} or \{1\} then attempt to access. Class name: \{2\}"{\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
canned error message for when user does not specify a machine. }}\par
{
Definition at line {\b 79} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\xe \v StructTypeContainer\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:StructTypeContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StructModeType} InsightSheath.Abstract.PlatformDependantNativeStruct.StructTypeContainer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
protected container for {\b StructType} }}\par
{
Definition at line {\b 73} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v StructType\:InsightSheath.Abstract.PlatformDependantNativeStruct}
{\xe \v InsightSheath.Abstract.PlatformDependantNativeStruct\:StructType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StructModeType} InsightSheath.Abstract.PlatformDependantNativeStruct.StructType{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the type of structure that's correct for this class to use. Also resets a flag to trigger Marshalling from that native side when set. }}\par
{
Definition at line {\b 59} of file {\b PlatformDependantNativeStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Abstracts/{\b PlatformDependantNativeStruct.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.ProcessMemoryCount32 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 32-bit process }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b cb}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of this structure in unmanaged land. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b PageFaultCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of Page Faults for a given process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b PeakWorkingSetSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peaked working set size, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b WorkingSetSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Working set size, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b QuotaPeakedPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b QuotaPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b QuotaPeakedNonPagePoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked non paged pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b QuotaNonPagePoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current non page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b PageFileUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commit change value for the process in bytes. Note: MSDN Windows 7/ Server 2008 says check {\b PrivateUsage} instead }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b PeakPageFileUsaged}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak value of committed change during process lifetime }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b PrivateUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
same as {\b PageFileUsage}, Current Commit Charge value in butes for this process. This is the amount that the memory manage as allocated for this process. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 32-bit process \par
}{
Definition at line {\b 14} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.cb}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of this structure in unmanaged land. }}\par
{
Definition at line {\b 19} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v PageFaultCount\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:PageFaultCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.PageFaultCount}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of Page Faults for a given process. }}\par
{
Definition at line {\b 23} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v PageFileUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:PageFileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.PageFileUsage}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commit change value for the process in bytes. Note: MSDN Windows 7/ Server 2008 says check {\b PrivateUsage} instead }}\par
{
Definition at line {\b 51} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v PeakPageFileUsaged\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:PeakPageFileUsaged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.PeakPageFileUsaged}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak value of committed change during process lifetime }}\par
{
Definition at line {\b 55} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v PeakWorkingSetSize\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:PeakWorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.PeakWorkingSetSize}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peaked working set size, in bytes }}\par
{
Definition at line {\b 27} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v PrivateUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:PrivateUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.PrivateUsage}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
same as {\b PageFileUsage}, Current Commit Charge value in butes for this process. This is the amount that the memory manage as allocated for this process. }}\par
{
Definition at line {\b 59} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v QuotaNonPagePoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:QuotaNonPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaNonPagePoolUsage}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current non page pool usage, in bytes }}\par
{
Definition at line {\b 47} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v QuotaPagedPoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:QuotaPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaPagedPoolUsage}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current page pool usage, in bytes }}\par
{
Definition at line {\b 39} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v QuotaPeakedNonPagePoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:QuotaPeakedNonPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaPeakedNonPagePoolUsage}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked non paged pool usage, in bytes }}\par
{
Definition at line {\b 43} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v QuotaPeakedPagedPoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:QuotaPeakedPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.QuotaPeakedPagedPoolUsage}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked page pool usage, in bytes }}\par
{
Definition at line {\b 35} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\xe \v WorkingSetSize\:InsightSheath.Debugging.Process.ProcessMemoryCount32}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount32\:WorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Process.ProcessMemoryCount32.WorkingSetSize}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Working set size, in bytes }}\par
{
Definition at line {\b 31} of file {\b ProcessMemoryCount_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b ProcessMemoryCount_x86.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.ProcessMemoryCount64 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 64-bit process }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b cb}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of this structure in unmanaged land. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PageFaultCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of Page Faults for a given process. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PeakWorkingSetSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peaked working set size, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b WorkingSetSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Working set size, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPeakedPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPagedPoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaPeakedNonPagePoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked non paged pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b QuotaNonPagePoolUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current non page pool usage, in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PageFileUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commit change value for the process in bytes. Note: MSDN Windows 7/ Server 2008 says check {\b PrivateUsage} instead }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PeakPageFileUsaged}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak value of committed change during process lifetime }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b PrivateUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
same as {\b PageFileUsage}, Current Commit Charge value in butes for this process. This is the amount that the memory manage as allocated for this process. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 64-bit process \par
}{
Definition at line {\b 14} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.cb}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of this structure in unmanaged land. }}\par
{
Definition at line {\b 19} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v PageFaultCount\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:PageFaultCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.PageFaultCount}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of Page Faults for a given process. }}\par
{
Definition at line {\b 23} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v PageFileUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:PageFileUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.PageFileUsage}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commit change value for the process in bytes. Note: MSDN Windows 7/ Server 2008 says check {\b PrivateUsage} instead }}\par
{
Definition at line {\b 51} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v PeakPageFileUsaged\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:PeakPageFileUsaged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.PeakPageFileUsaged}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak value of committed change during process lifetime }}\par
{
Definition at line {\b 55} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v PeakWorkingSetSize\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:PeakWorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.PeakWorkingSetSize}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peaked working set size, in bytes }}\par
{
Definition at line {\b 27} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v PrivateUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:PrivateUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.PrivateUsage}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
same as {\b PageFileUsage}, Current Commit Charge value in butes for this process. This is the amount that the memory manage as allocated for this process. }}\par
{
Definition at line {\b 59} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v QuotaNonPagePoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:QuotaNonPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaNonPagePoolUsage}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current non page pool usage, in bytes }}\par
{
Definition at line {\b 47} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v QuotaPagedPoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:QuotaPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaPagedPoolUsage}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current page pool usage, in bytes }}\par
{
Definition at line {\b 39} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v QuotaPeakedNonPagePoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:QuotaPeakedNonPagePoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaPeakedNonPagePoolUsage}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked non paged pool usage, in bytes }}\par
{
Definition at line {\b 43} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v QuotaPeakedPagedPoolUsage\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:QuotaPeakedPagedPoolUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.QuotaPeakedPagedPoolUsage}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
peaked page pool usage, in bytes }}\par
{
Definition at line {\b 35} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\xe \v WorkingSetSize\:InsightSheath.Debugging.Process.ProcessMemoryCount64}
{\xe \v InsightSheath.Debugging.Process.ProcessMemoryCount64\:WorkingSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.Process.ProcessMemoryCount64.WorkingSetSize}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Working set size, in bytes }}\par
{
Definition at line {\b 31} of file {\b ProcessMemoryCount_x64.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b ProcessMemoryCount_x64.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK}
{\xe \v InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK}
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block} }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block} \par
}{
Definition at line {\b 17} of file {\b PSAPI_WORKING_SET_INFORMATION.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b PSAPI_WORKING_SET_INFORMATION.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_INFORMATION Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_INFORMATION}
{\xe \v InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_INFORMATION}
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 10} of file {\b PSAPI_WORKING_SET_INFORMATION.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b PSAPI_WORKING_SET_INFORMATION.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Process.QueryWorkingStructs Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Process.QueryWorkingStructs}
{\xe \v InsightSheath.Debugging.Process.QueryWorkingStructs}
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b QueryWorkingStructs.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Process/{\b QueryWorkingStructs.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Misc.ReferenceCounter Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Misc.ReferenceCounter}
{\xe \v InsightSheath.Misc.ReferenceCounter}
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
USed by the ReferenceCounterNativeStaticContainer to track and change a reference. This is primary used by the DebugEvent class collection as we're handing out Multiple REferences to the same Native Pointer like candy and need to take steps to prevent users of the library from prematuring freeing the same sheath. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b AddRef} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b DecRef} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b Ref}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
USed by the ReferenceCounterNativeStaticContainer to track and change a reference. This is primary used by the DebugEvent class collection as we're handing out Multiple REferences to the same Native Pointer like candy and need to take steps to prevent users of the library from prematuring freeing the same sheath. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Why? GC knows DebugEvent, DebugEventCreateProcess both end up using NativecStaticContainer GC does NOT know of the Native Side being a block of memory for a DEBUG_EVENT struct. GC does not know that DebugEvent hands out DebugEventCreateProcesses that point to the same NativePointer\par
Got the above? Consider this example GC frees DebugEventCreateProcess, memory is invalided on the nativeside GC has not freed DebugEvent but memory thsi class points too is know invalid DebugEvent breaks.\par
}{
Definition at line {\b 26} of file {\b ReferenceCounter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddRef\:InsightSheath.Misc.ReferenceCounter}
{\xe \v InsightSheath.Misc.ReferenceCounter\:AddRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Misc.ReferenceCounter.AddRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ReferenceCounter.cs}.}\par
}
{\xe \v DecRef\:InsightSheath.Misc.ReferenceCounter}
{\xe \v InsightSheath.Misc.ReferenceCounter\:DecRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Misc.ReferenceCounter.DecRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b ReferenceCounter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Ref\:InsightSheath.Misc.ReferenceCounter}
{\xe \v InsightSheath.Misc.ReferenceCounter\:Ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Misc.ReferenceCounter.Ref{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b ReferenceCounter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Misc/{\b ReferenceCounter.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Abstract.ReferenceCounterNativeStaticContainer Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class contains an {\b AddRef()}/ {\b Release()} component for child classes. Destructors(), Call {\b Release()} and if that returns 0, free as appropriate. Not needed if the class itself is a 1 to 1 ie Sheath class pointer that contains one pointer, this can skip. Sheath, DebugEvent classes have this in the change, because they give out multiple references to a native class like candy. Each multiple class in the sheath points to a single native class. when the sheath class is freed(), }}\par
Inheritance diagram for InsightSheath.Abstract.ReferenceCounterNativeStaticContainer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_abstract_1_1_reference_counter_native_static_container.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReferenceCounterNativeStaticContainer} (IntPtr {\b Native})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReferenceCounterNativeStaticContainer} (IntPtr {\b Native}, bool {\b FreeOnCleanup}, ulong ReferenceCount)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to RefereneCount. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReferenceCounterNativeStaticContainer} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to 11. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b AddRef} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increase the Reference count to the native pointer and return the value. Call this when returning a seperate sheath class that may outlive the primary sheath class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b Release} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decrease the Reference count to the native pointer and return the value. If zero is returned, your native pointer should be ok to safely cleanup/free }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b ReferenceCounter}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reference count without adjusting it. Increase the reference counter when returning a pointer to a class }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class contains an {\b AddRef()}/ {\b Release()} component for child classes. Destructors(), Call {\b Release()} and if that returns 0, free as appropriate. Not needed if the class itself is a 1 to 1 ie Sheath class pointer that contains one pointer, this can skip. Sheath, DebugEvent classes have this in the change, because they give out multiple references to a native class like candy. Each multiple class in the sheath points to a single native class. when the sheath class is freed(), \par
}{
Definition at line {\b 21} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ReferenceCounterNativeStaticContainer\:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\:ReferenceCounterNativeStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.ReferenceCounterNativeStaticContainer (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to 1. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{The Native pointer to keep track of.\cell }
{\row }
}
}{
Definition at line {\b 27} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\xe \v ReferenceCounterNativeStaticContainer\:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\:ReferenceCounterNativeStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.ReferenceCounterNativeStaticContainer (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}, ulong  {\i ReferenceCount}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to RefereneCount. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{The Native pointer to keep track of.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{indicate if we are to invoke the unmanaged cleanup routine for free()\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ReferenceCount} \cell }{Starting reference count number. The unmanaged resource should not be freed during disposal if this is more than 0 after decreasing by 1\cell }
{\row }
}
}{
Definition at line {\b 38} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\xe \v ReferenceCounterNativeStaticContainer\:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\:ReferenceCounterNativeStaticContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.ReferenceCounterNativeStaticContainer (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create instance of this with the passed Native Pointer. Subclasses of this should include routines to call the native class's functions. Reference counter is set to 11. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{The Native pointer to keep track of.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{indicate if we are to invoke the unmanaged cleanup routine for free()\cell }
{\row }
}
}{
Definition at line {\b 49} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddRef\:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\:AddRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.AddRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increase the Reference count to the native pointer and return the value. Call this when returning a seperate sheath class that may outlive the primary sheath class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 73} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\xe \v Release\:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\:Release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.Release (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decrease the Reference count to the native pointer and return the value. If zero is returned, your native pointer should be ok to safely cleanup/free }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 82} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ReferenceCounter\:InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}
{\xe \v InsightSheath.Abstract.ReferenceCounterNativeStaticContainer\:ReferenceCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Abstract.ReferenceCounterNativeStaticContainer.ReferenceCounter{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reference count without adjusting it. Increase the reference counter when returning a pointer to a class }}\par
{
Definition at line {\b 59} of file {\b ReferenceCounterNativeStaticContainer.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Abstracts/{\b ReferenceCounterNativeStaticContainer.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.SymbolEngine.SourceFile Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.SymbolEngine.SourceFile}
{\xe \v InsightSheath.Debugging.SymbolEngine.SourceFile}
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b ModBase}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base address of the module this source file is to be used for }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b FileName}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
location to read the source file from. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 11} of file {\b PSourceFileStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v FileName\:InsightSheath.Debugging.SymbolEngine.SourceFile}
{\xe \v InsightSheath.Debugging.SymbolEngine.SourceFile\:FileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.SymbolEngine.SourceFile.FileName}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
location to read the source file from. }}\par
{
Definition at line {\b 21} of file {\b PSourceFileStruct.cs}.}\par
}
{\xe \v ModBase\:InsightSheath.Debugging.SymbolEngine.SourceFile}
{\xe \v InsightSheath.Debugging.SymbolEngine.SourceFile\:ModBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.SymbolEngine.SourceFile.ModBase}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base address of the module this source file is to be used for }}\par
{
Definition at line {\b 16} of file {\b PSourceFileStruct.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/SymbolEngine/{\b PSourceFileStruct.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.StartupInfoExW Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW}
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for the {\b StartupInfoExW} struct handler exported in InsightApi.dll. }}\par
Inheritance diagram for InsightSheath.Win32Struct.StartupInfoExW:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_win32_struct_1_1_startup_info_ex_w.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartupInfoExW} (IntPtr {\b Native})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartupInfoExW} (IntPtr {\b Native}, bool FreeConCleanup)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b StartupInfoExW} {\b MakeInstance} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call the routine on the native side to make an instance and return a pointer to the wrapper class already pointed to that. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b FlagSetterContainer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Desktop}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the desktop the process will be started on. Leave null to try inheriting the desktop the spawning process is running on. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Title}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or Set the name of the Console Window Title. No Extra Flags Needed. MSDN Documentation recommends this be NULL for Console processes that don't need a window or GUI processes that don't create a window }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b X}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the X position of the starting window (in pixels), use {\b StartupInfoExW_Flags.Startf_UsePosition} in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Y}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the Y position of the starting window (in pixels), use {\b StartupInfoExW_Flags.Startf_UsePosition} in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b XSize}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or Set the Width of the Window (in pixels), use {\b StartupInfoExW_Flags.Startf_UseSize} in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b YSize}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or Set the Height of the Window (in pixels), use {\b StartupInfoExW_Flags.Startf_UseSize} in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b XCountChars}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the starting width of the Console (if created and is in char rows), use {\b StartupInfoExW_Flags.Startf_UseCountChars}) in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b YCountChars}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the starting height of the Console (if created and is in char rows), use {\b StartupInfoExW_Flags.Startf_UseCountChars}) in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b FillAtribute}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set how the Console window colors will be starting out (ignored if no console), use {\b StartupInfoExW_Flags.Startf_UseFillAttribute} in {\b Flags} to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartupInfoExW_Flags} {\b Flags}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the flags that indicate which part of startup info is valid. Remember to set otherwise the system will ignore it. Look at {\b StartupInfoExW_Flags} or go to the source at  }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartupInfoExW_ShowWindow} {\b ShowWindow}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify how to show the initial window. Use {\b StartupInfoExW_Flags.Startf_UseShowWindow} in {\b Flags} to indicate use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b StandardInput}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set what's passed along to the hStdInput member, use {\b StartupInfoExW_Flags.Startf_UseHotKey}. or {\b StartupInfoExW_Flags.Startf_UseStdHandles} to indicate how this will be interpreted in the {\b Flags} setting }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b StandardOutput}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set what's passed to the hStdOutput member, use {\b StartupInfoExW_Flags.Startf_UseStdHandles} in {\b Flags} to indicate how to use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b StandardError}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set what's passed to the hStdError member, use {\b StartupInfoExW_Flags.Startf_UseStdHandles} in {\b Flags} to indicate how to use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b FlagSetterHelper}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manged side only. Set to true to enable setting the {\b Flags} value on setting the members in this class EXCEPT for {\b StandardInput} }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for the {\b StartupInfoExW} struct handler exported in InsightApi.dll. \par
}{
Definition at line {\b 64} of file {\b StartupInfoExW.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StartupInfoExW\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:StartupInfoExW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.StartupInfoExW.StartupInfoExW (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v StartupInfoExW\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:StartupInfoExW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.StartupInfoExW.StartupInfoExW (IntPtr  {\i Native}, bool  {\i FreeConCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b StartupInfoExW.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Dispose\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.StartupInfoExW.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources in addition to unmanaged.\cell }
{\row }
}
IMPORTANT! If your child class needs special needs beyond C/C++'s free(), override this and take care of them before calling base(). Should your custom class allocate multiple things for example {\b WindowsUnicodeString}'s implementation for reading from remote processes Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(IntPtr, IntPtr, bool, bool), you will need to make a routine to properly free. That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory. Design checks: list type="number"> listheader> description > First, override disposal()  /listheader > item>  Nest, add a private variable in your class called isDisposed. Set this to true when your class's native pointer is cleaned up completely  /item > item> description>if ReferenceCounterNativeStaticContainer is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it. /item> item> description>if ReferenceCounterNativeStaticContainer IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null. If the reference counter is more than 0 when decreased, set native to null instead of disposing. /item> \par
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 85} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v MakeInstance\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:MakeInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b StartupInfoExW} InsightSheath.Win32Struct.StartupInfoExW.MakeInstance (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call the routine on the native side to make an instance and return a pointer to the wrapper class already pointed to that. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 70} of file {\b StartupInfoExW.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v FlagSetterContainer\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:FlagSetterContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Win32Struct.StartupInfoExW.FlagSetterContainer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 372} of file {\b StartupInfoExW.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Desktop\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:Desktop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Win32Struct.StartupInfoExW.Desktop{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the desktop the process will be started on. Leave null to try inheriting the desktop the spawning process is running on. }}\par
{
Definition at line {\b 103} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v FillAtribute\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:FillAtribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.FillAtribute{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set how the Console window colors will be starting out (ignored if no console), use {\b StartupInfoExW_Flags.Startf_UseFillAttribute} in {\b Flags} to set }}\par
{
Definition at line {\b 253} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v Flags\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StartupInfoExW_Flags} InsightSheath.Win32Struct.StartupInfoExW.Flags{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the flags that indicate which part of startup info is valid. Remember to set otherwise the system will ignore it. Look at {\b StartupInfoExW_Flags} or go to the source at  }}\par
{
Definition at line {\b 272} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v FlagSetterHelper\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:FlagSetterHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Win32Struct.StartupInfoExW.FlagSetterHelper{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manged side only. Set to true to enable setting the {\b Flags} value on setting the members in this class EXCEPT for {\b StandardInput} }}\par
{
Definition at line {\b 361} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v ShowWindow\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:ShowWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StartupInfoExW_ShowWindow} InsightSheath.Win32Struct.StartupInfoExW.ShowWindow{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specify how to show the initial window. Use {\b StartupInfoExW_Flags.Startf_UseShowWindow} in {\b Flags} to indicate use. }}\par
{
Definition at line {\b 286} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v StandardError\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:StandardError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Win32Struct.StartupInfoExW.StandardError{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set what's passed to the hStdError member, use {\b StartupInfoExW_Flags.Startf_UseStdHandles} in {\b Flags} to indicate how to use. }}\par
{
Definition at line {\b 340} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v StandardInput\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:StandardInput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Win32Struct.StartupInfoExW.StandardInput{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set what's passed along to the hStdInput member, use {\b StartupInfoExW_Flags.Startf_UseHotKey}. or {\b StartupInfoExW_Flags.Startf_UseStdHandles} to indicate how this will be interpreted in the {\b Flags} setting }}\par
{
Definition at line {\b 305} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v StandardOutput\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:StandardOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Win32Struct.StartupInfoExW.StandardOutput{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set what's passed to the hStdOutput member, use {\b StartupInfoExW_Flags.Startf_UseStdHandles} in {\b Flags} to indicate how to use. }}\par
{
Definition at line {\b 320} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v Title\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:Title}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Win32Struct.StartupInfoExW.Title{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or Set the name of the Console Window Title. No Extra Flags Needed. MSDN Documentation recommends this be NULL for Console processes that don't need a window or GUI processes that don't create a window }}\par
{
Definition at line {\b 123} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v X\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.X{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the X position of the starting window (in pixels), use {\b StartupInfoExW_Flags.Startf_UsePosition} in {\b Flags} to set }}\par
{
Definition at line {\b 143} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v XCountChars\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:XCountChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.XCountChars{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the starting width of the Console (if created and is in char rows), use {\b StartupInfoExW_Flags.Startf_UseCountChars}) in {\b Flags} to set }}\par
{
Definition at line {\b 220} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v XSize\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:XSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.XSize{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or Set the Width of the Window (in pixels), use {\b StartupInfoExW_Flags.Startf_UseSize} in {\b Flags} to set }}\par
{
Definition at line {\b 181} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v Y\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:Y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.Y{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the Y position of the starting window (in pixels), use {\b StartupInfoExW_Flags.Startf_UsePosition} in {\b Flags} to set }}\par
{
Definition at line {\b 162} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v YCountChars\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:YCountChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.YCountChars{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the starting height of the Console (if created and is in char rows), use {\b StartupInfoExW_Flags.Startf_UseCountChars}) in {\b Flags} to set }}\par
{
Definition at line {\b 238} of file {\b StartupInfoExW.cs}.}\par
}
{\xe \v YSize\:InsightSheath.Win32Struct.StartupInfoExW}
{\xe \v InsightSheath.Win32Struct.StartupInfoExW\:YSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.StartupInfoExW.YSize{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or Set the Height of the Window (in pixels), use {\b StartupInfoExW_Flags.Startf_UseSize} in {\b Flags} to set }}\par
{
Definition at line {\b 201} of file {\b StartupInfoExW.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b StartupInfoExW.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.SymbolEngine.SymbolInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} imported for dealing with SymbolInfoW Native structures. }}\par
Inheritance diagram for InsightSheath.Debugging.SymbolEngine.SymbolInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_symbol_engine_1_1_symbol_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SymbolInfo} (IntPtr That)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SymbolInfo} (IntPtr That, bool {\b FreeOnCleanup})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b TypeDataIndex}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the type index for symbol for this }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SymbolIndex}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the unique value used by the symbol handler for this symbol }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SymbolSize}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How big is the symbol's data in bytes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b BaseModuleAddress}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get base address for the symbol's module }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SymbolFlags} {\b Flags}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the flags that describe what's in this structure }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SymbolRegisterOrValue}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SymbolRegister}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SymbolValue}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SymbolScope}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SymbolTagType} {\b SymbolTagType}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b SymbolName}{\f2  [get]}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} imported for dealing with SymbolInfoW Native structures. \par
}{
Definition at line {\b 96} of file {\b SymbolInfo.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SymbolInfo\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolInfo (IntPtr  {\i That}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolInfo\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolInfo (IntPtr  {\i That}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b SymbolInfo.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v BaseModuleAddress\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:BaseModuleAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Debugging.SymbolEngine.SymbolInfo.BaseModuleAddress{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get base address for the symbol's module }}\par
{
Definition at line {\b 146} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v Flags\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SymbolFlags} InsightSheath.Debugging.SymbolEngine.SymbolInfo.Flags{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the flags that describe what's in this structure }}\par
{
Definition at line {\b 157} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolIndex\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolIndex{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the unique value used by the symbol handler for this symbol }}\par
{
Definition at line {\b 123} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolName\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolName{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolRegister\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolRegister{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolRegisterOrValue\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolRegisterOrValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolRegisterOrValue{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolScope\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolScope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolScope{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolSize\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolSize{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How big is the symbol's data in bytes }}\par
{
Definition at line {\b 135} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolTagType\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolTagType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SymbolTagType} InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolTagType{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v SymbolValue\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:SymbolValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.SymbolValue{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b SymbolInfo.cs}.}\par
}
{\xe \v TypeDataIndex\:InsightSheath.Debugging.SymbolEngine.SymbolInfo}
{\xe \v InsightSheath.Debugging.SymbolEngine.SymbolInfo\:TypeDataIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.SymbolEngine.SymbolInfo.TypeDataIndex{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the type index for symbol for this }}\par
{
Definition at line {\b 112} of file {\b SymbolInfo.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/SymbolEngine/{\b SymbolInfo.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Thread.ThreadContext Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext}
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ThreadContext} is a class indented for reading/writing information about threads receives in the main InsightProcess structure We duplicate some of the functionality of the ProcessThread class for C# user familiarity. }}\par
Inheritance diagram for InsightSheath.Debugging.Thread.ThreadContext:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_thread_1_1_thread_context.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ThreadContext} (IntPtr {\b Native})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This links an instance of the {\b ThreadContext} on the native side with your Managed code. Use {\b CreateInstance(IntPtr)} or {\b CreateInstance(uint)}to make a new instance. This constructor links your .Net Wrapper to a Native underlying instance of the C++ class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ThreadContext} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is required because of how the parent child classes work, Same as {\b ThreadContext.ThreadContext(IntPtr)} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SuspendThread} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspend either a wow64 thread or x64 bit thread. Will trigger LoadLibrary calls the first time used on wow64 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ResumeThread} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resume either a wow64 thread or x64 bit thread. Will trigger LoadLibrary calls the first time used on wow64 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SetTargetThread} (IntPtr ThreadHandleNative)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the thread this class is handling based on thread parameter. Once set, you may do what you will with the original handle }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SetTargetThread} (uint {\b ThreadId})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the thread this class is handling based on thread id. Discards existing info that this class knowns about for the original thread (if any) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ThreadContext} {\b CreateInstance} (uint threadId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new instance of {\b ThreadContext} and point it to the passed thread whose id is this. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ThreadContext} {\b CreateInstance} (IntPtr ThreadHandle)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new instance of {\b ThreadContext} and point it to the thread specified by this handle. You don't need the handle afterwards. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
call the proper disposal routine for {\b ThreadContext} }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ThreadDescription}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
retrieve or set the thread's description. WARNING May Heap Corruption on Getting value. Current fix is in Native Debug Build and it just does not call local free per the MSDN documentation BUT does not cause appear memory leak after looping thru code to get/set 1000000 times so either so \'C2\'AF_(\'E3\'83\'84)_/\'C2\'AF Want to ensure the fix follows the documentation on MSDN unless MSDN is wrong. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ThreadId}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the ID of the thread this class is paired with. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IdealProcessor}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the Ideal / preferred processor for this thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ThreadPriorityLevel {\b ThreadPriority}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the targeted thread's priority. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b PriorityBoost}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the value indicating if Windows should temporarily boost the thread's priority if a window that the thread handles receives focus }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ProcessorAffinity}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set processor affinity / desired process this thread runs on. Warning. Does not work support more than 64-bit logical processors }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b ThreadStartAddress}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NOT IMPLEMENTED }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ThreadState {\b ThreadState}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Here for future. NOT IMPLEMENTED for this class. TODO: Add this feature with support of the native DLL }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ThreadWaitReason {\b ThreadWaitReason}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Here for future. NOT IMPLEMENTED for this class. TODO: Add this feature with support of the native DLL }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TimeSpan {\b ThreadCreationTime}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the {\b Thread} was created. Note this Refresh ALL items {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TimeSpan {\b ThreadExitTime}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If thread active, (defined as MSDN's getThreadExitCode gets 259 for a exit code), returns 0 instead of ExitTime, Note this Refershs ALL {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TimeSpan {\b UserProcessorTime}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amount of Time that the thread runs user level code, Note this Refreshes ALL {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TimeSpan {\b KernelProcessorTime}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amount of Time that the thread runs kernel level code, Note this Refreshes ALL {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TimeSpan {\b TotalProcessorTime}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b KernelProcessorTime} and {\b UserProcessorTime} added together for your convenience. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b Context}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retreieve a pointer to either a wow64_context or a Context struct depending on the thread's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b Wow64Context}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pointer to a wow64 context stuct for this thread. If it's not a wow64 thread, returns IntPtr.Zero instead. You can use {\b Wow64ContextLayout} to access }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ThreadContext} is a class indented for reading/writing information about threads receives in the main InsightProcess structure We duplicate some of the functionality of the ProcessThread class for C# user familiarity. \par
}{
Definition at line {\b 20} of file {\b ThreadContext.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ThreadContext\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Thread.ThreadContext.ThreadContext (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This links an instance of the {\b ThreadContext} on the native side with your Managed code. Use {\b CreateInstance(IntPtr)} or {\b CreateInstance(uint)}to make a new instance. This constructor links your .Net Wrapper to a Native underlying instance of the C++ class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArgumentNullException} \cell }{If passing null, this is thrown\cell }
{\row }
}
}{
Definition at line {\b 46} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadContext\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Thread.ThreadContext.ThreadContext (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is required because of how the parent child classes work, Same as {\b ThreadContext.ThreadContext(IntPtr)} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{Ignored. Always false. {\b Dispose()} has been overwritten to safely kill the instance\cell }
{\row }
}
}{
Definition at line {\b 62} of file {\b ThreadContext.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CreateInstance\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:CreateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b ThreadContext} InsightSheath.Debugging.Thread.ThreadContext.CreateInstance (IntPtr  {\i ThreadHandle}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new instance of {\b ThreadContext} and point it to the thread specified by this handle. You don't need the handle afterwards. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ThreadHandle} \cell }{Win32 Handle to thread you want to point this class instance to. You don't need the handle after this.\cell }
{\row }
}
}{
Definition at line {\b 37} of file {\b ThreadContext.cs}.}\par
}
{\xe \v CreateInstance\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:CreateInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b ThreadContext} InsightSheath.Debugging.Thread.ThreadContext.CreateInstance (uint  {\i threadId}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new instance of {\b ThreadContext} and point it to the passed thread whose id is this. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i threadId} \cell }{id of thread to point this class to\cell }
{\row }
}
}{
Definition at line {\b 28} of file {\b ThreadContext.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.Thread.ThreadContext.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
call the proper disposal routine for {\b ThreadContext} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{\cell }
{\row }
}
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 75} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ResumeThread\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ResumeThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.ThreadContext.ResumeThread (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resume either a wow64 thread or x64 bit thread. Will trigger LoadLibrary calls the first time used on wow64 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
current suspend value. Values > 0 mean thread suspended.\par
}}}{
Definition at line {\b 106} of file {\b ThreadContext.cs}.}\par
}
{\xe \v SetTargetThread\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:SetTargetThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Thread.ThreadContext.SetTargetThread (IntPtr  {\i ThreadHandleNative}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the thread this class is handling based on thread parameter. Once set, you may do what you will with the original handle }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ThreadHandleNative} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
returns true if the call worked and false if it did not\par
}}}{
Definition at line {\b 116} of file {\b ThreadContext.cs}.}\par
}
{\xe \v SetTargetThread\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:SetTargetThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Thread.ThreadContext.SetTargetThread (uint  {\i ThreadId}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the thread this class is handling based on thread id. Discards existing info that this class knowns about for the original thread (if any) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ThreadId} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 126} of file {\b ThreadContext.cs}.}\par
}
{\xe \v SuspendThread\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:SuspendThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.ThreadContext.SuspendThread (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspend either a wow64 thread or x64 bit thread. Will trigger LoadLibrary calls the first time used on wow64 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
current suspend value. Values > 0 mean thread suspended.\par
}}}{
Definition at line {\b 96} of file {\b ThreadContext.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Context\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:Context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.Thread.ThreadContext.Context{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retreieve a pointer to either a wow64_context or a Context struct depending on the thread's type. }}\par
{
Definition at line {\b 326} of file {\b ThreadContext.cs}.}\par
}
{\xe \v IdealProcessor\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:IdealProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InsightSheath.Debugging.Thread.ThreadContext.IdealProcessor{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the Ideal / preferred processor for this thread. }}\par
{
Definition at line {\b 162} of file {\b ThreadContext.cs}.}\par
}
{\xe \v KernelProcessorTime\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:KernelProcessorTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TimeSpan InsightSheath.Debugging.Thread.ThreadContext.KernelProcessorTime{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amount of Time that the thread runs kernel level code, Note this Refreshes ALL {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }}\par
{
Definition at line {\b 304} of file {\b ThreadContext.cs}.}\par
}
{\xe \v PriorityBoost\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:PriorityBoost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool InsightSheath.Debugging.Thread.ThreadContext.PriorityBoost{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the value indicating if Windows should temporarily boost the thread's priority if a window that the thread handles receives focus }}\par
{
Definition at line {\b 192} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ProcessorAffinity\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ProcessorAffinity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.ThreadContext.ProcessorAffinity{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set processor affinity / desired process this thread runs on. Warning. Does not work support more than 64-bit logical processors }}\par
{
Definition at line {\b 210} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadCreationTime\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadCreationTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TimeSpan InsightSheath.Debugging.Thread.ThreadContext.ThreadCreationTime{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the {\b Thread} was created. Note this Refresh ALL items {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Because of performance reasons in watching in debugger browsing/viewing - this is not browsable.\par
}{
Definition at line {\b 268} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadDescription\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadDescription}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Debugging.Thread.ThreadContext.ThreadDescription{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
retrieve or set the thread's description. WARNING May Heap Corruption on Getting value. Current fix is in Native Debug Build and it just does not call local free per the MSDN documentation BUT does not cause appear memory leak after looping thru code to get/set 1000000 times so either so \'C2\'AF_(\'E3\'83\'84)_/\'C2\'AF Want to ensure the fix follows the documentation on MSDN unless MSDN is wrong. }}\par
{
Definition at line {\b 135} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadExitTime\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadExitTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TimeSpan InsightSheath.Debugging.Thread.ThreadContext.ThreadExitTime{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If thread active, (defined as MSDN's getThreadExitCode gets 259 for a exit code), returns 0 instead of ExitTime, Note this Refershs ALL {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }}\par
{
Definition at line {\b 280} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadId\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.ThreadContext.ThreadId{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the ID of the thread this class is paired with. }}\par
{
Definition at line {\b 151} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadPriority\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ThreadPriorityLevel InsightSheath.Debugging.Thread.ThreadContext.ThreadPriority{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get or set the targeted thread's priority. }}\par
{
Definition at line {\b 177} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadStartAddress\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadStartAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.Thread.ThreadContext.ThreadStartAddress{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NOT IMPLEMENTED }}\par
{
Definition at line {\b 225} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadState\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ThreadState InsightSheath.Debugging.Thread.ThreadContext.ThreadState{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Here for future. NOT IMPLEMENTED for this class. TODO: Add this feature with support of the native DLL }}\par
{
Definition at line {\b 237} of file {\b ThreadContext.cs}.}\par
}
{\xe \v ThreadWaitReason\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:ThreadWaitReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ThreadWaitReason InsightSheath.Debugging.Thread.ThreadContext.ThreadWaitReason{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Here for future. NOT IMPLEMENTED for this class. TODO: Add this feature with support of the native DLL }}\par
{
Definition at line {\b 252} of file {\b ThreadContext.cs}.}\par
}
{\xe \v TotalProcessorTime\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:TotalProcessorTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TimeSpan InsightSheath.Debugging.Thread.ThreadContext.TotalProcessorTime{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b KernelProcessorTime} and {\b UserProcessorTime} added together for your convenience. }}\par
{
Definition at line {\b 315} of file {\b ThreadContext.cs}.}\par
}
{\xe \v UserProcessorTime\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:UserProcessorTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TimeSpan InsightSheath.Debugging.Thread.ThreadContext.UserProcessorTime{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amount of Time that the thread runs user level code, Note this Refreshes ALL {\b ThreadCreationTime}, {\b ThreadExitTime}, {\b UserProcessorTime}, {\b KernelProcessorTime} values and returns the one you want }}\par
{
Definition at line {\b 292} of file {\b ThreadContext.cs}.}\par
}
{\xe \v Wow64Context\:InsightSheath.Debugging.Thread.ThreadContext}
{\xe \v InsightSheath.Debugging.Thread.ThreadContext\:Wow64Context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Debugging.Thread.ThreadContext.Wow64Context{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pointer to a wow64 context stuct for this thread. If it's not a wow64 thread, returns IntPtr.Zero instead. You can use {\b Wow64ContextLayout} to access }}\par
{
Definition at line {\b 341} of file {\b ThreadContext.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Thread/{\b ThreadContext.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.UnicodeString32 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.UnicodeString32}
{\xe \v InsightSheath.Win32Struct.UnicodeString32}
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processed that are Wow/32- bit this is what our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from either a local native pointer or remote/other process. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Length}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current Length of the string pointed to in Buffer. Note if dealing with InsertHere, the memory block pointed to by bufffer currently will be set right after the native location of struct plus its size }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b MaxLength}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How big possibly is if the buffer. Note InsertHere dealing this is here for completeness sake. Your buffer (if remote) was allocated to be big enough to hold that containing string, that's all }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Buffer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte pointer to where the Unicode String is allocated. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processed that are Wow/32- bit this is what our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from either a local native pointer or remote/other process. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To marshal. Using Marshal.PtrToStructure<UnicodeString32>(IntPtr) and either Marshal.PtrToStringUni(IntPtr, int) for a local buffer or Remote.RemoteStructure.RemoteReadString(IntPtr, IntPtr, uint) for one located in a different process \par
}{
Definition at line {\b 59} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Buffer\:InsightSheath.Win32Struct.UnicodeString32}
{\xe \v InsightSheath.Win32Struct.UnicodeString32\:Buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.UnicodeString32.Buffer}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
4 byte pointer to where the Unicode String is allocated. }}\par
{
Definition at line {\b 72} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v Length\:InsightSheath.Win32Struct.UnicodeString32}
{\xe \v InsightSheath.Win32Struct.UnicodeString32\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Win32Struct.UnicodeString32.Length}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current Length of the string pointed to in Buffer. Note if dealing with InsertHere, the memory block pointed to by bufffer currently will be set right after the native location of struct plus its size }}\par
{
Definition at line {\b 64} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v MaxLength\:InsightSheath.Win32Struct.UnicodeString32}
{\xe \v InsightSheath.Win32Struct.UnicodeString32\:MaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Win32Struct.UnicodeString32.MaxLength}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How big possibly is if the buffer. Note InsertHere dealing this is here for completeness sake. Your buffer (if remote) was allocated to be big enough to hold that containing string, that's all }}\par
{
Definition at line {\b 68} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b WindowsUnicodeString.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.UnicodeString64 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.UnicodeString64}
{\xe \v InsightSheath.Win32Struct.UnicodeString64}
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processes that are 64-bit, this is our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from a source. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Length}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current Length of the string pointed to in Buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b MaxLength}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How big possibly is if the buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Padding}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Padding to ensure {\b Buffer} is at the right spot. Otherwise unused. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b Buffer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte pointer to where the Unicode String is allocated. InsertHere will place the string right after the location of the returned Unicode String struct }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processes that are 64-bit, this is our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from a source. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To marshal. Using Marshal.PtrToStructure<UnicodeString64>(IntPtr) and either Marshal.PtrToStringUni(IntPtr, int) for a local buffer or Remote.RemoteStructure.RemoteReadString(IntPtr, IntPtr, uint) for one located in a different process \par
}{
Definition at line {\b 82} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Buffer\:InsightSheath.Win32Struct.UnicodeString64}
{\xe \v InsightSheath.Win32Struct.UnicodeString64\:Buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.UnicodeString64.Buffer}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8 byte pointer to where the Unicode String is allocated. InsertHere will place the string right after the location of the returned Unicode String struct }}\par
{
Definition at line {\b 99} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v Length\:InsightSheath.Win32Struct.UnicodeString64}
{\xe \v InsightSheath.Win32Struct.UnicodeString64\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Win32Struct.UnicodeString64.Length}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current Length of the string pointed to in Buffer. }}\par
{
Definition at line {\b 87} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v MaxLength\:InsightSheath.Win32Struct.UnicodeString64}
{\xe \v InsightSheath.Win32Struct.UnicodeString64\:MaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort InsightSheath.Win32Struct.UnicodeString64.MaxLength}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How big possibly is if the buffer. }}\par
{
Definition at line {\b 91} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v Padding\:InsightSheath.Win32Struct.UnicodeString64}
{\xe \v InsightSheath.Win32Struct.UnicodeString64\:Padding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.UnicodeString64.Padding}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Padding to ensure {\b Buffer} is at the right spot. Otherwise unused. }}\par
{
Definition at line {\b 95} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b WindowsUnicodeString.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.UserProcessParameters32 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.UserProcessParameters32}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters32}
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x86 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b Reserved1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint[] {\b Reserved2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnicodeString32} {\b ImagePathName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnicodeString32} {\b CommandLine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x86 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  \par
}{
Definition at line {\b 14} of file {\b UserProcessParameters_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CommandLine\:InsightSheath.Win32Struct.UserProcessParameters32}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters32\:CommandLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnicodeString32} InsightSheath.Win32Struct.UserProcessParameters32.CommandLine}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UserProcessParameters_x86.cs}.}\par
}
{\xe \v ImagePathName\:InsightSheath.Win32Struct.UserProcessParameters32}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters32\:ImagePathName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnicodeString32} InsightSheath.Win32Struct.UserProcessParameters32.ImagePathName}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b UserProcessParameters_x86.cs}.}\par
}
{\xe \v Reserved1\:InsightSheath.Win32Struct.UserProcessParameters32}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters32\:Reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte [] InsightSheath.Win32Struct.UserProcessParameters32.Reserved1}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b UserProcessParameters_x86.cs}.}\par
}
{\xe \v Reserved2\:InsightSheath.Win32Struct.UserProcessParameters32}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters32\:Reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint [] InsightSheath.Win32Struct.UserProcessParameters32.Reserved2}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b UserProcessParameters_x86.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b UserProcessParameters_x86.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.UserProcessParameters64 Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.UserProcessParameters64}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters64}
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x64 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b Reserved1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong[] {\b Reserved2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnicodeString64} {\b ImagePathName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnicodeString64} {\b CommandLine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x64 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  \par
}{
Definition at line {\b 15} of file {\b UserProcessParameters_x64.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CommandLine\:InsightSheath.Win32Struct.UserProcessParameters64}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters64\:CommandLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnicodeString64} InsightSheath.Win32Struct.UserProcessParameters64.CommandLine}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UserProcessParameters_x64.cs}.}\par
}
{\xe \v ImagePathName\:InsightSheath.Win32Struct.UserProcessParameters64}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters64\:ImagePathName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnicodeString64} InsightSheath.Win32Struct.UserProcessParameters64.ImagePathName}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UserProcessParameters_x64.cs}.}\par
}
{\xe \v Reserved1\:InsightSheath.Win32Struct.UserProcessParameters64}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters64\:Reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte [] InsightSheath.Win32Struct.UserProcessParameters64.Reserved1}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b UserProcessParameters_x64.cs}.}\par
}
{\xe \v Reserved2\:InsightSheath.Win32Struct.UserProcessParameters64}
{\xe \v InsightSheath.Win32Struct.UserProcessParameters64\:Reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong [] InsightSheath.Win32Struct.UserProcessParameters64.Reserved2}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b UserProcessParameters_x64.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b UserProcessParameters_x64.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.WindowsObjectAttributes Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes}
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
made from specs here  }}\par
Inheritance diagram for InsightSheath.Win32Struct.WindowsObjectAttributes:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_win32_struct_1_1_windows_object_attributes.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsObjectAttributes} (IntPtr {\b Native})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsObjectAttributes} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsObjectAttributes} (IntPtr {\b Native}, bool {\b FreeOnCleanup}, {\b StructModeType} {\b StructType})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsObjectAttributes} (IntPtr {\b Native}, {\b StructModeType} {\b StructType})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b WindowsObjectAttributes} cleanup. We need to call the current native routine to cleanup and clear the cleanup flag so we don't delete mememory already deleted }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Blit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should marshal the relevant struct from the native pointer if {\b WasBlit} is not set and set afterwards. Accessors should call this each time they are called to retrieve values. Additionally, if the .NET struct will need to make changes to the land, you're going to need to call {\b Apply} BEFORE reading the managed struct. Not doing this will revert your changes on the managed side to the equivalent native values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Apply} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not currently implemented }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b Length}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the length value of the structure on the native size. {\b StructTypeContainer} must be set to something other than {\b StructModeType.MachineUnknown} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b RootDirectory}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the handle value of the structure on the native size. 4 byte values are already promoted to 8 bytes long when returned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsUnicodeString} {\b ObjectName}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve (and set the current {\b StructModeType} for the current UnicodeString structure pointed to. Can return null if that's not set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Attributes}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the object attributes of the native struct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b SecurityDescriptor}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a pointer to the security descriptor (may be not be relative to Your process.  to read the data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IntPtr {\b SecurityQualityOfService}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a pointer to the security quality of service struct (may be not be relative to Your process.  to read the data. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
made from specs here  \par
}{
Definition at line {\b 19} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WindowsObjectAttributes\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:WindowsObjectAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsObjectAttributes.WindowsObjectAttributes (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v WindowsObjectAttributes\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:WindowsObjectAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsObjectAttributes.WindowsObjectAttributes (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v WindowsObjectAttributes\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:WindowsObjectAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsObjectAttributes.WindowsObjectAttributes (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}, {\b StructModeType}  {\i StructType}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v WindowsObjectAttributes\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:WindowsObjectAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsObjectAttributes.WindowsObjectAttributes (IntPtr  {\i Native}, {\b StructModeType}  {\i StructType}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Apply\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:Apply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.WindowsObjectAttributes.Apply (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not currently implemented }}\par
{
Implements {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 100} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v Blit\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:Blit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.WindowsObjectAttributes.Blit (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should marshal the relevant struct from the native pointer if {\b WasBlit} is not set and set afterwards. Accessors should call this each time they are called to retrieve values. Additionally, if the .NET struct will need to make changes to the land, you're going to need to call {\b Apply} BEFORE reading the managed struct. Not doing this will revert your changes on the managed side to the equivalent native values. }}\par
{
Implements {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 74} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.WindowsObjectAttributes.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b WindowsObjectAttributes} cleanup. We need to call the current native routine to cleanup and clear the cleanup flag so we don't delete mememory already deleted }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{\cell }
{\row }
}
}{
Reimplemented from {\b InsightSheath.Abstract.PlatformDependantNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 45} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Attributes\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:Attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Win32Struct.WindowsObjectAttributes.Attributes{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the object attributes of the native struct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PlatformDependantNativeStruct.StructTypeContainer must be set to something other than {\b StructModeType.MachineUnknown}\par
}{
Definition at line {\b 203} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v Length\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.WindowsObjectAttributes.Length{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the length value of the structure on the native size. {\b StructTypeContainer} must be set to something other than {\b StructModeType.MachineUnknown} }}\par
{
Definition at line {\b 111} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v ObjectName\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:ObjectName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WindowsUnicodeString} InsightSheath.Win32Struct.WindowsObjectAttributes.ObjectName{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve (and set the current {\b StructModeType} for the current UnicodeString structure pointed to. Can return null if that's not set }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The returned object is pointing to the same native object as this class. If you want a unique one, duplicate it. PlatformDependantNativeStruct.StructTypeContainer must be set to something other than {\b StructModeType.MachineUnknown}\par
}{
Definition at line {\b 161} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v RootDirectory\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:RootDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Win32Struct.WindowsObjectAttributes.RootDirectory{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve the handle value of the structure on the native size. 4 byte values are already promoted to 8 bytes long when returned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PlatformDependantNativeStruct.StructTypeContainer must be set to something other than {\b StructModeType.MachineUnknown}\par
}{
Definition at line {\b 129} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v SecurityDescriptor\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:SecurityDescriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Win32Struct.WindowsObjectAttributes.SecurityDescriptor{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a pointer to the security descriptor (may be not be relative to Your process.  to read the data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PlatformDependantNativeStruct.StructTypeContainer must be set to something other than {\b StructModeType.MachineUnknown}. This can be 0 if the default one is OK. 4 byte pointers are promoted to 8 bytes long. The Remote.RemoteStructure.xxx routine does not read this into your process currently.\par
}{
Definition at line {\b 226} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\xe \v SecurityQualityOfService\:InsightSheath.Win32Struct.WindowsObjectAttributes}
{\xe \v InsightSheath.Win32Struct.WindowsObjectAttributes\:SecurityQualityOfService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntPtr InsightSheath.Win32Struct.WindowsObjectAttributes.SecurityQualityOfService{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a pointer to the security quality of service struct (may be not be relative to Your process.  to read the data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PlatformDependantNativeStruct.StructTypeContainer must be set to something other than {\b StructModeType.MachineUnknown}. This can be 0 if the default one is OK. 4 byte pointers are promoted to 8 bytes long. The Remote.RemoteStructure.xxx routine does not read this into your process currently.\par
}{
Definition at line {\b 256} of file {\b WindowsObjectAttributes.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b WindowsObjectAttributes.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.WindowsUnicodeString Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString}
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates both a {\b UnicodeString32} or {\b UnicodeString64} and lets one indicate which one to use based on {\b WindowsUnicodeString.StructType} You can use HelperRoutines.GetPEMachineType(string) on the process your dealing with to find what value was set as the machine type }}\par
Inheritance diagram for InsightSheath.Win32Struct.WindowsUnicodeString:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_win32_struct_1_1_windows_unicode_string.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsUnicodeString} (IntPtr {\b Native})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
After creating an instance, call SetStructType(ModeType) and specify which version of an Unicode string, this class contrains }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsUnicodeString} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
After creating an instance, call SetStructType(ModeType) and specify which version of an Unicode string, this class contrains }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsUnicodeString} (IntPtr {\b Native}, bool {\b FreeOnCleanup}, {\b StructModeType} {\b StructType})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b WindowsUnicodeString} and specify the native pointer, if the class will be subject to unmanaged cleanup and which Native Struct the pointer points too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WindowsUnicodeString} (IntPtr {\b Native}, {\b StructModeType} {\b StructType})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b WindowsUnicodeString} and specify the native pointer and which Native Struct the pointer points too }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override string {\b ToString} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equivalent to grabbing the {\b Buffer} property if {\b BufferPtr} is non zero }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Blit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marshals into a private {\b UnicodeString32} or {\b UnicodeString64} struct depending on the value of PlatformDependantNativeStruct.WasBlit being false. Sets to true afterwords. Will throw an InvalidOperationException if PlatformDependantNativeStruct.StructType is something other than {\b StructModeType.Machinex64} or {\b StructModeType.Machinex86} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The native memory is either a {\b UnicodeString32} or {\b UnicodeString64} struct Dependant on {\b StructType}. Pointer is a separate allocated string. This means NativeImports.NativeMethods.SimpleFree(IntPtr) is incorrect in this scenario. We'll need to call NativeImports.NativeMethods.RemoteFreeUnicodeString(IntPtr, bool) pointer here. Also {\b FreeOnCleanup} should be false if this structure is part of a larger struct directly and NOT A POINTER. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Apply} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not implemented }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Length}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the current length of the string in {\b BufferPtr} based on the current {\b StructType} setting }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MaxLength}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the max length (in bytes) of the string in {\b BufferPtr} based on the current {\b StructType} setting }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ulong {\b BufferPtr}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the buffer containing the string in the contained structure based on the current {\b StructType} setting. x86 (4 byte sized) pointers are promoted to a x64 (8 byte sized) return value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Buffer}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a .NET managed string containing the String that {\b BufferPtr} points to. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates both a {\b UnicodeString32} or {\b UnicodeString64} and lets one indicate which one to use based on {\b WindowsUnicodeString.StructType} You can use HelperRoutines.GetPEMachineType(string) on the process your dealing with to find what value was set as the machine type \par
}{
Definition at line {\b 107} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WindowsUnicodeString\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:WindowsUnicodeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsUnicodeString.WindowsUnicodeString (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
After creating an instance, call SetStructType(ModeType) and specify which version of an Unicode string, this class contrains }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 113} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v WindowsUnicodeString\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:WindowsUnicodeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsUnicodeString.WindowsUnicodeString (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
After creating an instance, call SetStructType(ModeType) and specify which version of an Unicode string, this class contrains }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to either a {\b UnicodeString32} or {\b UnicodeString64} to the structure this class will reference\cell }
{\row }
}
}{
Definition at line {\b 122} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v WindowsUnicodeString\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:WindowsUnicodeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsUnicodeString.WindowsUnicodeString (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}, {\b StructModeType}  {\i StructType}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b WindowsUnicodeString} and specify the native pointer, if the class will be subject to unmanaged cleanup and which Native Struct the pointer points too }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to either a {\b UnicodeString32} or {\b UnicodeString64} to the structure this class will reference\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i FreeOnCleanup} \cell }{if true then the structure is freed via RemoteRead_SimpleFree() which itself is a call to C/C++'s free() . Set TO FALSE if dealing with structures declared in C/C++ code vs dynamically allocated\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i StructType} \cell }{Use {\b StructModeType.Machinex86} to mark structure as a {\b UnicodeString32} pointer and {\b StructModeType.Machinex64} to mark struct as a {\b UnicodeString64} pointer\cell }
{\row }
}
}{
Definition at line {\b 133} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v WindowsUnicodeString\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:WindowsUnicodeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Win32Struct.WindowsUnicodeString.WindowsUnicodeString (IntPtr  {\i Native}, {\b StructModeType}  {\i StructType}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of {\b WindowsUnicodeString} and specify the native pointer and which Native Struct the pointer points too }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Native} \cell }{Native pointer to either a {\b UnicodeString32} or {\b UnicodeString64} to the structure this class will reference\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i StructType} \cell }{Use {\b StructModeType.Machinex86} to mark structure as a {\b UnicodeString32} pointer and {\b StructModeType.Machinex64} to mark struct as a {\b UnicodeString64} pointer\cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Apply\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:Apply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.WindowsUnicodeString.Apply (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not implemented }}\par
{
Implements {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 327} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v Blit\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:Blit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.WindowsUnicodeString.Blit (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marshals into a private {\b UnicodeString32} or {\b UnicodeString64} struct depending on the value of PlatformDependantNativeStruct.WasBlit being false. Sets to true afterwords. Will throw an InvalidOperationException if PlatformDependantNativeStruct.StructType is something other than {\b StructModeType.Machinex64} or {\b StructModeType.Machinex86} }}\par
{
Implements {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 159} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Win32Struct.WindowsUnicodeString.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The native memory is either a {\b UnicodeString32} or {\b UnicodeString64} struct Dependant on {\b StructType}. Pointer is a separate allocated string. This means NativeImports.NativeMethods.SimpleFree(IntPtr) is incorrect in this scenario. We'll need to call NativeImports.NativeMethods.RemoteFreeUnicodeString(IntPtr, bool) pointer here. Also {\b FreeOnCleanup} should be false if this structure is part of a larger struct directly and NOT A POINTER. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{\cell }
{\row }
}
Native side always returns a {\b UnicodeString64} bit. We simply calculate and discard value\par
}{
Reimplemented from {\b InsightSheath.Abstract.PlatformDependantNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 195} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v ToString\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:ToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override string InsightSheath.Win32Struct.WindowsUnicodeString.ToString (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Equivalent to grabbing the {\b Buffer} property if {\b BufferPtr} is non zero }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If {\b BufferPtr} is 0, return null. Otherwise returns {\b Buffer}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InvalidOperationException} \cell }{Can be triggered if one forgets to set {\b StructType}\cell }
{\row }
}
}{
Definition at line {\b 315} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Buffer\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:Buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string InsightSheath.Win32Struct.WindowsUnicodeString.Buffer{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a .NET managed string containing the String that {\b BufferPtr} points to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IMPORTANT!!!!! Use Remote.RemoteStructure.
(IntPtr, IntPtr, bool, bool) if dealing with a {\b BufferPtr} that is valid in the context of another process and not yours. This routine will take case or dealing with that. You'll either get incorrect results or generate an exception if you don't. \par
}{
Definition at line {\b 292} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v BufferPtr\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:BufferPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ulong InsightSheath.Win32Struct.WindowsUnicodeString.BufferPtr{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the buffer containing the string in the contained structure based on the current {\b StructType} setting. x86 (4 byte sized) pointers are promoted to a x64 (8 byte sized) return value }}\par
{
Definition at line {\b 270} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v Length\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InsightSheath.Win32Struct.WindowsUnicodeString.Length{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the current length of the string in {\b BufferPtr} based on the current {\b StructType} setting }}\par
{
Definition at line {\b 228} of file {\b WindowsUnicodeString.cs}.}\par
}
{\xe \v MaxLength\:InsightSheath.Win32Struct.WindowsUnicodeString}
{\xe \v InsightSheath.Win32Struct.WindowsUnicodeString\:MaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InsightSheath.Win32Struct.WindowsUnicodeString.MaxLength{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the max length (in bytes) of the string in {\b BufferPtr} based on the current {\b StructType} setting }}\par
{
Definition at line {\b 249} of file {\b WindowsUnicodeString.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b WindowsUnicodeString.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Win32Struct.WindowsUserProcessParameter Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Win32Struct.WindowsUserProcessParameter}
{\xe \v InsightSheath.Win32Struct.WindowsUserProcessParameter}
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 27} of file {\b WindowsUserProcessParameter.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Win32Struct/{\b WindowsUserProcessParameter.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Thread.Wow64Context Class Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context}
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
Inheritance diagram for InsightSheath.Debugging.Thread.Wow64Context:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_insight_sheath_1_1_debugging_1_1_thread_1_1_wow64_context.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Wow64Context} (IntPtr {\b Native})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Wow64Context} (IntPtr {\b Native}, bool {\b FreeOnCleanup})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Blit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should marshal the relevant struct from the native pointer if {\b WasBlit} is not set and set afterwards. Accessors should call this each time they are called to retrieve values. Additionally, if the .NET struct will need to make changes to the land, you're going to need to call {\b Apply} BEFORE reading the managed struct. Not doing this will revert your changes on the managed side to the equivalent native values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Dispose} (bool disposing)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Apply} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should convert the relevant struct in .NET land and place it in the {\b Native} if the protected value {\b StaleManagedStruct} was set to true Unmanaged land. It should throw a InvalidOperationException if it's not a valid thing (native pointer is known to be read only memory/ exist for a callback function for example) NotImplementedException exception if not done yet ecct... }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ContextFlags}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr0}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr1}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr2}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr3}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr6}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr7}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Wow64FloatingPointSaveArea} {\b FloatSave}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegGs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegFs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegEs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegDs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Ebp}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Eip}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Ecx}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Eax}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Edx}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Ebx}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Esi}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Edi}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegCs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b EFlags}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Esp}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegSs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b ExtendedRegisters}{\f2  [get, set]}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 105} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Wow64Context\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Wow64Context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Thread.Wow64Context.Wow64Context (IntPtr  {\i Native}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Wow64Context\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Wow64Context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InsightSheath.Debugging.Thread.Wow64Context.Wow64Context (IntPtr  {\i Native}, bool  {\i FreeOnCleanup}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 561} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Apply\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Apply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.Thread.Wow64Context.Apply (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should convert the relevant struct in .NET land and place it in the {\b Native} if the protected value {\b StaleManagedStruct} was set to true Unmanaged land. It should throw a InvalidOperationException if it's not a valid thing (native pointer is known to be read only memory/ exist for a callback function for example) NotImplementedException exception if not done yet ecct... }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InvalidOperationException} \cell }{Throw this when writing back to the unmanaged struct is not valid (for example read only memory or a local variable in a callback routine allocated on Unamanged heap)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NotSupportedException} \cell }{Throw this when writing back to the unmanaged struct is not valid (for example read only memory or a local variable in a callback routine allocated on Unamanged heap)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NotImplementedException} \cell }{The routine was added but not implemented yet.\cell }
{\row }
}
}{
Implements {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 596} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Blit\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Blit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.Thread.Wow64Context.Blit (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code should marshal the relevant struct from the native pointer if {\b WasBlit} is not set and set afterwards. Accessors should call this each time they are called to retrieve values. Additionally, if the .NET struct will need to make changes to the land, you're going to need to call {\b Apply} BEFORE reading the managed struct. Not doing this will revert your changes on the managed side to the equivalent native values. }}\par
{
Implements {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 568} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dispose\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void InsightSheath.Debugging.Thread.Wow64Context.Dispose (bool  {\i disposing}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic {\b NativeStaticContainer} disposal. Checks if not disposed, if FreeOnCleanup is set and Native != 0 null before calling a routine exported in InsightAPI to free the memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i disposing} \cell }{set to true if disposing of managed resources in addition to unmanaged.\cell }
{\row }
}
IMPORTANT! If your child class needs special needs beyond C/C++'s free(), override this and take care of them before calling base(). Should your custom class allocate multiple things for example WindowsUnicodeString's implementation for reading from remote processes Win32Struct.Remote.RemoteStructure.RemoteReadUnicodeString(IntPtr, IntPtr, bool, bool), you will need to make a routine to properly free. That routine allocates 2 buffers instead of 1. Calling C/C++'s free() alone is leaking memory. Design checks: list type="number"> listheader> description > First, override disposal()  /listheader > item>  Nest, add a private variable in your class called isDisposed. Set this to true when your class's native pointer is cleaned up completely  /item > item> description>if ReferenceCounterNativeStaticContainer is NOT in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is true and the Native pointer is not null. It should set the native pointer to null when FULLY done disposing it. /item> item> description>if ReferenceCounterNativeStaticContainer IS in the hierarchy then your routine should dispose of unmanaged resourced when isDisposed is true, FreeOnCleanup is AND THE REFERENCE COUNTER being decreased is 0, and the Native pointer is not null. If the reference counter is more than 0 when decreased, set native to null instead of disposing. /item> \par
}{
Reimplemented from {\b InsightSheath.Abstract.NativeStaticContainer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 583} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ContextFlags\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:ContextFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.ContextFlags{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr0\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dr0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Dr0{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr1\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dr1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Dr1{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr2\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dr2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Dr2{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr3\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Dr3{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr6\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dr6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Dr6{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr7\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Dr7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Dr7{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Eax\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Eax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Eax{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 380} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Ebp\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Ebp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Ebp{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 325} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Ebx\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Ebx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Ebx{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Ecx\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Ecx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Ecx{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 362} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Edi\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Edi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Edi{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 452} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Edx\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Edx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Edx{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b Wow64Context.cs}.}\par
}
{\xe \v EFlags\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:EFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.EFlags{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Eip\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Eip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Eip{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 344} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Esi\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Esi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Esi{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 434} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Esp\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:Esp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.Esp{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 507} of file {\b Wow64Context.cs}.}\par
}
{\xe \v ExtendedRegisters\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:ExtendedRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte [] InsightSheath.Debugging.Thread.Wow64Context.ExtendedRegisters{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 544} of file {\b Wow64Context.cs}.}\par
}
{\xe \v FloatSave\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:FloatSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Wow64FloatingPointSaveArea} InsightSheath.Debugging.Thread.Wow64Context.FloatSave{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegCs\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:SegCs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.SegCs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 470} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegDs\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:SegDs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.SegDs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 308} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegEs\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:SegEs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.SegEs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 288} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegFs\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:SegFs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.SegFs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegGs\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:SegGs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.SegGs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegSs\:InsightSheath.Debugging.Thread.Wow64Context}
{\xe \v InsightSheath.Debugging.Thread.Wow64Context\:SegSs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64Context.SegSs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 526} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Thread/{\b Wow64Context.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Thread.Wow64ContextLayout Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handler for reading from / writing to a Wow64ContextString }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ContextFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr6}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Dr7}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Wow64FloatingPointSaveArea} {\b FloatSave}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegGs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegFs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegEs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegDs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Edi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Esi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Ebx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Edx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Ecx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Eax}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Ebp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Eip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegCs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b EFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Esp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b SegSs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b ExtendedRegisters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handler for reading from / writing to a Wow64ContextString \par
}{
Definition at line {\b 73} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ContextFlags\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:ContextFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.ContextFlags}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr0\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Dr0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Dr0}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr1\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Dr1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Dr1}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr2\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Dr2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Dr2}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr3\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Dr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Dr3}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr6\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Dr6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Dr6}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Dr7\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Dr7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Dr7}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Eax\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Eax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Eax}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Ebp\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Ebp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Ebp}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Ebx\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Ebx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Ebx}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Ecx\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Ecx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Ecx}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Edi\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Edi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Edi}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Edx\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Edx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Edx}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Wow64Context.cs}.}\par
}
{\xe \v EFlags\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:EFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.EFlags}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Eip\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Eip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Eip}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Esi\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Esi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Esi}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Esp\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:Esp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.Esp}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Wow64Context.cs}.}\par
}
{\xe \v ExtendedRegisters\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:ExtendedRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte [] InsightSheath.Debugging.Thread.Wow64ContextLayout.ExtendedRegisters}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b Wow64Context.cs}.}\par
}
{\xe \v FloatSave\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:FloatSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Wow64FloatingPointSaveArea} InsightSheath.Debugging.Thread.Wow64ContextLayout.FloatSave}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegCs\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:SegCs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.SegCs}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegDs\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:SegDs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.SegDs}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegEs\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:SegEs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.SegEs}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegFs\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:SegFs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.SegFs}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegGs\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:SegGs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.SegGs}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b Wow64Context.cs}.}\par
}
{\xe \v SegSs\:InsightSheath.Debugging.Thread.Wow64ContextLayout}
{\xe \v InsightSheath.Debugging.Thread.Wow64ContextLayout\:SegSs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64ContextLayout.SegSs}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Thread/{\b Wow64Context.cs}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea Struct Reference\par \pard\plain 
{\tc\tcl2 \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ControlWord}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b StatusWord}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b TagWord}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ErrorOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b ErrorSelector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b DataOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b DataSelector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte[] {\b RegisterArea}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint {\b Cr0NpxState}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 54} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ControlWord\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:ControlWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.ControlWord}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Wow64Context.cs}.}\par
}
{\xe \v Cr0NpxState\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:Cr0NpxState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.Cr0NpxState}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Wow64Context.cs}.}\par
}
{\xe \v DataOffset\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:DataOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.DataOffset}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Wow64Context.cs}.}\par
}
{\xe \v DataSelector\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:DataSelector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.DataSelector}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b Wow64Context.cs}.}\par
}
{\xe \v ErrorOffset\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:ErrorOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.ErrorOffset}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Wow64Context.cs}.}\par
}
{\xe \v ErrorSelector\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:ErrorSelector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.ErrorSelector}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b Wow64Context.cs}.}\par
}
{\xe \v RegisterArea\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:RegisterArea}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte [] InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.RegisterArea}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b Wow64Context.cs}.}\par
}
{\xe \v StatusWord\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:StatusWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.StatusWord}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Wow64Context.cs}.}\par
}
{\xe \v TagWord\:InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}
{\xe \v InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea\:TagWord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea.TagWord}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Wow64Context.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Debugging/Thread/{\b Wow64Context.cs}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Abstracts/NativeStaticContainer.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Abstracts/NativeStaticContainer.cs}
{\xe \v Abstracts/NativeStaticContainer.cs}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Abstract.NativeStaticContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates a native pointer to an unmanaged structure that can potentially be freed with a single call to C/C++'s free(). If said Native class needs special free requirements, overwrite {\b Dispose(bool)} with a a call to a routine to properly free it. If your wrapper is handing out multiple natiove pointers to the same object, you'll need something like {\b ReferenceCounterNativeStaticContainer} }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Abstract}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeStaticContainer.cs\par \pard\plain 
{\tc\tcl2 \v Abstracts/NativeStaticContainer.cs}
{\xe \v Abstracts/NativeStaticContainer.cs}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Debugging.Process;\par
00002 {\cf17 using }InsightSheath.Win32Struct;\par
00003 {\cf17 using }System;\par
00004 {\cf17 using }System.Collections.Generic;\par
00005 {\cf17 using }System.Linq;\par
00006 {\cf17 using }System.Text;\par
00007 {\cf17 using }System.Threading.Tasks;\par
00008 \par
00009 {\cf17 namespace }InsightSheath.Abstract\par
00010 \{\par
00011 \par
00015     {\cf17 public} {\cf17 abstract} {\cf17 class }NativeStaticContainer : IDisposable\par
00016     \{\par
00020         {\cf17 protected} {\cf17 const} {\cf18 string} UnmanagedConstructorReturnedNull = {\cf22 "The unmanaged routine \{0\} to build the unmanaged part of \{1\} returned null."};\par
00024         {\cf17 protected} {\cf17 const} {\cf18 string} ReceivedNullPointerOnConstructor = {\cf22 "\{0\} Cannot be 0.  Use \{1\} to make a new instance and use this to point this managed wrapper to a native instance of the class: (\{2\}\}"};\par
00025 \par
00026    \par
00027 \par
00035         {\cf17 protected} {\cf17 static} ArgumentNullException WrapperConstructorReceivedNullPointerErrorException({\cf18 string} ArgumentPrefix, {\cf18 string} AlternativeInstance, {\cf18 string} ArgumentName)\par
00036         \{\par
00037             {\cf19 return} {\cf17 new} ArgumentNullException({\cf18 string}.Format(ReceivedNullPointerOnConstructor, ArgumentPrefix, AlternativeInstance, ArgumentName));\par
00038         \}\par
00039 \par
00045         {\cf17 public} {\cf17 override} {\cf18 bool} Equals({\cf18 object} obj)\par
00046         \{\par
00047             {\cf19 if} (obj == {\cf17 null})\par
00048             \{\par
00049                 {\cf19 return} {\cf17 false};\par
00050             \}\par
00051             {\cf19 if} (obj is NativeStaticContainer container)\par
00052             \{\par
00053                 {\cf19 return} container.Native == Native;\par
00054             \}\par
00055             {\cf19 return} {\cf17 false};\par
00056         \}\par
00057 \par
00062         {\cf17 public} {\cf17 override} {\cf18 int} GetHashCode()\par
00063         \{\par
00064             {\cf19 return} Native.GetHashCode();\par
00065         \}\par
00066 \par
00071         {\cf17 public} NativeStaticContainer(IntPtr Native)\par
00072         \{\par
00073             this.Native = Native;\par
00074         \}\par
00082         {\cf17 public} NativeStaticContainer(IntPtr Native, {\cf18 bool} FreeOnCleanup)\par
00083         \{\par
00084             this.Native = Native;\par
00085             FreeOnCleanupContainer = FreeOnCleanup;\par
00086         \}\par
00087 \par
00088 \par
00092         {\cf17 public} IntPtr NativePointer\par
00093         \{\par
00094             {\cf17 get}\par
00095             \{\par
00096                 {\cf19 return} Native;\par
00097             \}\par
00098         \}\par
00099 \par
00103         {\cf17 protected} {\cf18 void} ClearNative()\par
00104         \{\par
00105             Native = IntPtr.Zero;\par
00106         \}\par
00110         {\cf17 protected} IntPtr Native;\par
00114         {\cf17 protected} {\cf18 bool} FreeOnCleanup\par
00115         \{\par
00116             {\cf17 get}\par
00117             \{\par
00118                 {\cf19 return} FreeOnCleanupContainer;\par
00119             \}\par
00120         \}\par
00121 \par
00125         {\cf17 protected} {\cf18 bool} FreeOnCleanupContainer;\par
00126 \par
00130         {\cf17 private} {\cf18 bool} disposedValue;\par
00134         {\cf17 public} {\cf18 bool} IsDisposed \{ {\cf17 get} \{ {\cf19 return} disposedValue; \} \}\par
00135 \par
00158         {\cf17 protected} {\cf17 virtual} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00159         \{\par
00160             {\cf19 if} (!disposedValue)\par
00161             \{\par
00162                 {\cf20 /*}\par
00163 {\cf20                 if (disposing)}\par
00164 {\cf20                 \{}\par
00165 {\cf20                     // nothing managed to dispose}\par
00166 {\cf20                 \}*/}\par
00167 \par
00168                 {\cf19 if} ( (Native != IntPtr.Zero) && (FreeOnCleanup))\par
00169                 \{\par
00170                     {\cf20 // if we made it this far, we should free() the native pointer if non zero and where made with that flag on.}\par
00171                     \{\par
00172                         NativeImports.NativeMethods.SimpleFree(Native);\par
00173                     \}\par
00174                     {\cf20 // clear native pointer.}\par
00175                     ClearNative();\par
00176                 \}\par
00177                 disposedValue = {\cf17 true};\par
00178             \}\par
00179         \}\par
00180 \par
00184         ~NativeStaticContainer()\par
00185         \{\par
00186             Dispose(disposing: {\cf17 false});\par
00187         \}\par
00188 \par
00192         {\cf17 public} {\cf18 void} Dispose()\par
00193         \{\par
00194             {\cf20 // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method}\par
00195             Dispose(disposing: {\cf17 true});\par
00196             GC.SuppressFinalize({\cf17 this});\par
00197         \}\par
00198     \}\par
00199 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Abstracts/OnDemandMarshalNativeStruct.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Abstracts/OnDemandMarshalNativeStruct.cs}
{\xe \v Abstracts/OnDemandMarshalNativeStruct.cs}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Abstract.OnDemandMarshalNativeStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class that is the base for classes that retrieve there data from a native struct and marshal to a private struct + expose properties to access this struct. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Abstract}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OnDemandMarshalNativeStruct.cs\par \pard\plain 
{\tc\tcl2 \v Abstracts/OnDemandMarshalNativeStruct.cs}
{\xe \v Abstracts/OnDemandMarshalNativeStruct.cs}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Wrappers;\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Collections.Generic;\par
00004 {\cf17 using }System.Linq;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Abstract\par
00009 \{\par
00013     {\cf17 public} {\cf17 abstract} {\cf17 class }OnDemandMarshalNativeStruct: NativeStaticContainer\par
00014     \{\par
00015         {\cf17 public} OnDemandMarshalNativeStruct(IntPtr Native): base(Native)\par
00016         \{\par
00017 \par
00018         \}\par
00019 \par
00020         {\cf17 public} OnDemandMarshalNativeStruct(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, FreeOnCleanup)\par
00021         \{\par
00022 \par
00023         \}\par
00029         {\cf17 protected} {\cf17 abstract} {\cf18 void} Blit();\par
00030 \par
00039         {\cf17 protected} {\cf17 abstract} {\cf18 void} Apply();\par
00040 \par
00041 \par
00048         {\cf17 public} {\cf18 void} MarshalToNative()\par
00049         \{\par
00050             Apply();\par
00051         \}\par
00055         {\cf17 protected} {\cf18 bool} WasBlit;\par
00056 \par
00060         {\cf17 protected} {\cf18 bool} StaleManagedStruct;\par
00061 \par
00062     \}\par
00063 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Abstracts/PlatformDependantNativeStruct.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Abstracts/PlatformDependantNativeStruct.cs}
{\xe \v Abstracts/PlatformDependantNativeStruct.cs}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Abstract.PlatformDependantNativeStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a foundation to classes that encapsulates a native pointer to either a x64 bit struct or x86 struct dependent on the target. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Abstract}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PlatformDependantNativeStruct.cs\par \pard\plain 
{\tc\tcl2 \v Abstracts/PlatformDependantNativeStruct.cs}
{\xe \v Abstracts/PlatformDependantNativeStruct.cs}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }InsightSheath.Win32Struct;\par
00007 {\cf17 using }InsightSheath.Wrappers;\par
00008 \par
00009 {\cf17 namespace }InsightSheath.Abstract\par
00010 \{\par
00014     {\cf17 public} {\cf17 abstract} {\cf17 class }PlatformDependantNativeStruct: OnDemandMarshalNativeStruct\par
00015     \{\par
00016         {\cf17 public} PlatformDependantNativeStruct(IntPtr Native): base(Native)\par
00017         \{\par
00018 \par
00019         \}\par
00020 \par
00027         {\cf17 public} PlatformDependantNativeStruct(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, FreeOnCleanup)\par
00028         \{\par
00029 \par
00030         \}\par
00031 \par
00032         {\cf17 public} PlatformDependantNativeStruct(IntPtr Native, {\cf18 bool} FreeOnCleanup, StructModeType StructType): base(Native, FreeOnCleanup)\par
00033         \{\par
00034             StructTypeContainer = StructType;\par
00035         \}\par
00036 \par
00042         {\cf17 public} PlatformDependantNativeStruct(IntPtr Native, StructModeType StructType): base(Native)\par
00043         \{\par
00044             StructTypeContainer = StructType;\par
00045         \}\par
00046 \par
00051         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00052         \{\par
00053             base.Dispose(disposing);\par
00054         \}\par
00055 \par
00059         {\cf17 public} StructModeType StructType\par
00060         \{\par
00061             {\cf17 get} \{ {\cf19 return} StructTypeContainer; \} \par
00062             {\cf17 set} \{\par
00063                 {\cf19 if} (StructTypeContainer != value)\par
00064                 \{\par
00065                     StructTypeContainer = value;\par
00066                     WasBlit = {\cf17 false};\par
00067                 \}\par
00068             \}\par
00069         \}\par
00073         {\cf17 protected} StructModeType StructTypeContainer;\par
00074         \par
00075      \par
00079         {\cf17 protected} {\cf17 const} {\cf18 string} MachineTypeUnspecifiedError = {\cf22 "Pick which version of the struct to use. Set StructType to either \{0\} or \{1\} then attempt to access. Class name: \{2\}"};\par
00080         {\cf17 static} {\cf17 protected} {\cf18 string} MachineTypeUnspecifiedErrorMakeMessage({\cf18 string} Type0, {\cf18 string} Type1, {\cf18 string} classname)\par
00081         \{\par
00082             {\cf19 return} {\cf18 string}.Format(MachineTypeUnspecifiedError, Type0, Type1, classname);\par
00083         \}\par
00089         {\cf17 static} {\cf17 protected} InvalidOperationException ThrowNewInvalidOpMessage({\cf18 string} classname)\par
00090         \{\par
00091             {\cf19 return} {\cf17 new} InvalidOperationException(MachineTypeUnspecifiedErrorMakeMessage(Enum.GetName(typeof(StructModeType), StructModeType.Machinex64), Enum.GetName(typeof(StructModeType), StructModeType.Machinex86), classname));\par
00092         \}\par
00093     \}\par
00094 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Abstracts/ReferenceCounterNativeStaticContainer.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Abstracts/ReferenceCounterNativeStaticContainer.cs}
{\xe \v Abstracts/ReferenceCounterNativeStaticContainer.cs}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Abstract.ReferenceCounterNativeStaticContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class contains an {\b AddRef()}/ {\b Release()} component for child classes. Destructors(), Call {\b Release()} and if that returns 0, free as appropriate. Not needed if the class itself is a 1 to 1 ie Sheath class pointer that contains one pointer, this can skip. Sheath, DebugEvent classes have this in the change, because they give out multiple references to a native class like candy. Each multiple class in the sheath points to a single native class. when the sheath class is freed(), }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Abstract}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ReferenceCounterNativeStaticContainer.cs\par \pard\plain 
{\tc\tcl2 \v Abstracts/ReferenceCounterNativeStaticContainer.cs}
{\xe \v Abstracts/ReferenceCounterNativeStaticContainer.cs}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Misc;\par
00002 {\cf17 using }InsightSheath.Wrappers;\par
00003 {\cf17 using }System;\par
00004 {\cf17 using }System.Collections.Generic;\par
00005 {\cf17 using }System.Linq;\par
00006 {\cf17 using }System.Text;\par
00007 {\cf17 using }System.Threading.Tasks;\par
00008 \par
00009 {\cf17 namespace }InsightSheath.Abstract\par
00010 \{\par
00021     {\cf17 public} {\cf17 abstract} {\cf17 class }ReferenceCounterNativeStaticContainer : NativeStaticContainer\par
00022     \{\par
00027         {\cf17 public} ReferenceCounterNativeStaticContainer(IntPtr Native) : base(Native)\par
00028         \{\par
00029             ReferenceCount.Ref = 1;\par
00030         \}\par
00031 \par
00038         {\cf17 public} ReferenceCounterNativeStaticContainer(IntPtr Native, {\cf18 bool} FreeOnCleanup, ulong ReferenceCount) : base(Native, FreeOnCleanup)\par
00039         \{\par
00040             this.Native = Native;\par
00041             FreeOnCleanupContainer = FreeOnCleanup;\par
00042             this.ReferenceCount.Ref = ReferenceCount;\par
00043         \}\par
00049         {\cf17 public} ReferenceCounterNativeStaticContainer(IntPtr Native, {\cf18 bool} FreeOnCleanup) : base(Native, FreeOnCleanup)\par
00050         \{\par
00051             this.Native = Native;\par
00052             FreeOnCleanupContainer = FreeOnCleanup;\par
00053             ReferenceCount.Ref = 1;\par
00054         \}\par
00055 \par
00059         {\cf17 public} ulong ReferenceCounter\par
00060         \{\par
00061             {\cf17 get}\par
00062             \{\par
00063                 {\cf19 return} ReferenceCount.Ref;\par
00064             \}\par
00065         \}\par
00066 \par
00067 \par
00068 \par
00073         {\cf17 public} ulong AddRef()\par
00074         \{\par
00075             {\cf19 return} ReferenceCount.AddRef();\par
00076         \}\par
00077 \par
00082         {\cf17 public} ulong Release()\par
00083         \{\par
00084             {\cf19 return} ReferenceCount.DecRef();\par
00085         \}\par
00086 \par
00087         readonly ReferenceCounter ReferenceCount = {\cf17 new}();\par
00088     \}\par
00089 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/DebugEvent.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/DebugEvent.cs}
{\xe \v Debugging/DebugEvent.cs}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventStaticContainer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the basis of disposal the other {\b DebugEvent} classes use. Also exposes routines to read the ProcessID and ThreadID that triggered the event }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventLoadDllInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to a {\b DebugEventType.LoadDllEvent} in a {\b DebugEvent} struct }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventExceptionInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class Wrapper dealing with extracting Exception information from a {\b DebugEvent}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventCreateThreadInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventExitThreadInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventExitProcessInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventCreateProcessInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventStringInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to process specific {\b DebugEventType.OutputDebugString} components. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventRipInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Providers a wrapper to access the underlying structure. Assumes memory management is done elsewhere. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventUnloadDllInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEvent}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This encapsulates the Native {\b DebugEvent} structure via calling exported C routines in InsightAPI.dll. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.DebugExceptionInPage_Type} \{ {\b InsightSheath.Debugging.ReadException} = 0
, {\b InsightSheath.Debugging.WriteException} = 1
, {\b InsightSheath.Debugging.DepException} = 8
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of In Page exception flags. You can check if the exception is that at DebugEventExceptionInfo.ExceptionCode }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.DebugExceptionTypes} : uint \{ {\b InsightSheath.Debugging.AccessViolation} = 0xC0000005
, {\b InsightSheath.Debugging.ArrayBoundsExceeded} = 0xC000008C
, {\b InsightSheath.Debugging.Breakpoint} = 0x80000003
, {\b InsightSheath.Debugging.Datatyp_Misalighment} = 0x80000002
, {\b InsightSheath.Debugging.FloatPoint_Denormal_Operand} = 0xC000008D
, {\b InsightSheath.Debugging.Float_DivideByZero} = 0xC000008E
, {\b InsightSheath.Debugging.Float_InexactResult} = 0xC000008F
, {\b InsightSheath.Debugging.Float_Overflow} = 0xC0000091
, {\b InsightSheath.Debugging.Float_StackCheck} = 0xC0000092
, {\b InsightSheath.Debugging.Float_Underflow} = 0xC0000093
, {\b InsightSheath.Debugging.IllegalInstrution} = 0xC000001D
, {\b InsightSheath.Debugging.InPageError} = 0xC0000006
, {\b InsightSheath.Debugging.Int_DivideByZero} = 0xC0000094
, {\b InsightSheath.Debugging.Int_Overflow} = 0xC0000095
, {\b InsightSheath.Debugging.InvalidDisposition} = 0xC0000026
, {\b InsightSheath.Debugging.NonContinuableException} = 0xC0000025
, {\b InsightSheath.Debugging.PrivInstruction} = 0xC0000096
, {\b InsightSheath.Debugging.StackOverflow} = 0xC00000FD
, {\b InsightSheath.Debugging.DebugConsoleControlC} = 0xC000013A
, {\b InsightSheath.Debugging.InvalidHandleCloseException} = 0xC0000008
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum for the exceptions specifies within the MSDN documentation. NOT EXHAUSTIVE. Sourced from minwinbase.h in Visual studio }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.DebugEventType} \{ {\b InsightSheath.Debugging.ExceptionEvent} = 1
, {\b InsightSheath.Debugging.CreateTheadEvent} = 2
, {\b InsightSheath.Debugging.CreateProcessEvent} = 3
, {\b InsightSheath.Debugging.ExitThreadEvent} = 4
, {\b InsightSheath.Debugging.ExitProcessEvent} = 5
, {\b InsightSheath.Debugging.LoadDllEvent} = 6
, {\b InsightSheath.Debugging.UnloadDllEvent} = 7
, {\b InsightSheath.Debugging.OutputDebugString} = 8
, {\b InsightSheath.Debugging.RipEvent} = 9
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helpful enum for the various debug event types. Also specifies which C# class will assist in reading the event's data. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.RipErrorType} \{ {\b InsightSheath.Debugging.SleNoType} = 0
, {\b InsightSheath.Debugging.SleError} = 0x00000001
, {\b InsightSheath.Debugging.SleMinorError} = 0x00000002
, {\b InsightSheath.Debugging.SleWarning} = 0x00000003
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of error that is contained DebugEventRipInfo.ErrorType }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DebugEvent.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/DebugEvent.cs}
{\xe \v Debugging/DebugEvent.cs}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.IO;\par
00004 {\cf17 using }System.Linq;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.NativeImports;\par
00008 {\cf17 using }InsightSheath;\par
00009 {\cf17 using }System.Runtime.InteropServices;\par
00010 {\cf17 using }InsightSheath.Abstract;\par
00011 {\cf17 using }InsightSheath.Win32Struct.Remote;\par
00012 \par
00013 {\cf17 namespace }InsightSheath.Debugging\par
00014 \{\par
00015 \par
00016 \par
00026     \par
00027     \par
00031     {\cf17 public} {\cf17 enum} DebugExceptionInPage_Type\par
00032     \{\par
00036         ReadException = 0,\par
00040         WriteException = 1,\par
00044         DepException = 8,\par
00045     \}\par
00046 \par
00050     {\cf17 public} {\cf17 enum} DebugExceptionTypes: uint\par
00051     \{\par
00055          AccessViolation =  0xC0000005,\par
00059          ArrayBoundsExceeded = 0xC000008C,\par
00063          Breakpoint = 0x80000003,\par
00067          Datatyp_Misalighment = 0x80000002,\par
00071          FloatPoint_Denormal_Operand = 0xC000008D,\par
00075          Float_DivideByZero = 0xC000008E,\par
00079         Float_InexactResult = 0xC000008F,\par
00083          Float_Overflow = 0xC0000091,\par
00087          Float_StackCheck = 0xC0000092,\par
00091          Float_Underflow = 0xC0000093,\par
00095          IllegalInstrution = 0xC000001D,\par
00099          InPageError= 0xC0000006,\par
00103          Int_DivideByZero= 0xC0000094,\par
00107          Int_Overflow= 0xC0000095,\par
00111          InvalidDisposition= 0xC0000026,\par
00115          NonContinuableException= 0xC0000025,\par
00119          PrivInstruction= 0xC0000096,\par
00123         StackOverflow = 0xC00000FD,\par
00127          DebugConsoleControlC = 0xC000013A,\par
00132          InvalidHandleCloseException = 0xC0000008,\par
00133 \par
00134 \par
00135     \}\par
00136     \par
00137 \par
00141     {\cf17 public} {\cf17 enum} DebugEventType\par
00142     \{\par
00146         ExceptionEvent = 1,\par
00150         CreateTheadEvent = 2,\par
00154         CreateProcessEvent = 3,\par
00158         ExitThreadEvent = 4,\par
00162         ExitProcessEvent = 5,\par
00166         LoadDllEvent = 6,\par
00170         UnloadDllEvent = 7,\par
00174         OutputDebugString = 8,\par
00178         RipEvent = 9\par
00179 \par
00180     \}\par
00181 \par
00185     {\cf17 public} {\cf17 enum} RipErrorType\par
00186     \{\par
00190         SleNoType = 0,\par
00194         SleError = 0x00000001,\par
00198         SleMinorError = 0x00000002,\par
00202         SleWarning = 0x00000003\par
00203     \}\par
00204 \par
00205 \par
00206 \par
00207 \par
00208 \par
00212     {\cf17 public} {\cf17 abstract} {\cf17 class }DebugEventStaticContainer : ReferenceCounterNativeStaticContainer\par
00213     \{\par
00218         {\cf17 public} DebugEventStaticContainer(IntPtr Native): base(Native)\par
00219         \{\par
00220             \par
00221         \}\par
00227         {\cf17 public} DebugEventStaticContainer(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, FreeOnCleanup)\par
00228         \{\par
00229             \par
00230         \}\par
00231 \par
00238         {\cf17 public} DebugEventStaticContainer(IntPtr Native, {\cf18 bool} FreeOnCleanup, ulong ReferenceCounter): base(Native, FreeOnCleanup, ReferenceCounter)\par
00239         \{\par
00240 \par
00241         \}\par
00242 \par
00243 \par
00244         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00245         \{\par
00246 \par
00247             \par
00248             {\cf19 if} (!IsDisposed)\par
00249             \{\par
00250                 {\cf19 if} (Release() == 0)\par
00251                 \{\par
00252                     {\cf19 if} (FreeOnCleanup)\par
00253                     \{\par
00254                         NativeMethods.SimpleFree(Native);\par
00255                     \}\par
00256                     ClearNative();\par
00257                 \}\par
00258                 {\cf19 else}\par
00259                 \{\par
00260                     ClearNative();\par
00261                 \}\par
00262             \}\par
00263             base.Dispose(disposing);\par
00264 \par
00265         \}\par
00266 \par
00270         {\cf17 private} {\cf18 bool} disposedValue;\par
00274         ~DebugEventStaticContainer()\par
00275          \{\par
00276                   Dispose(disposing: {\cf17 false});\par
00277          \}\par
00278 \par
00279 \par
00280 \par
00284         {\cf17 public} uint ProcessID\par
00285         \{\par
00286             {\cf17 get}\par
00287             \{\par
00288                 {\cf19 return} DebugEventNative.DebugEvent_GetProcessID(Native);\par
00289             \}\par
00290         \}\par
00291 \par
00295         {\cf17 public} uint ThreadID\par
00296         \{\par
00297             {\cf17 get}\par
00298             \{\par
00299                 {\cf19 return} DebugEventNative.DebugEvent_GetThreadID(Native);\par
00300             \}\par
00301         \}\par
00302 \par
00306         {\cf17 public} DebugEventType EventType\par
00307         \{\par
00308             {\cf17 get}\par
00309             \{\par
00310                 {\cf19 return} DebugEventNative.DebugEvent_GetEventType(Native);\par
00311             \}\par
00312         \}\par
00313         \par
00318         {\cf17 public} {\cf18 bool} IsEventFrom32BitProcess\par
00319         \{\par
00320             {\cf17 get}\par
00321             \{\par
00322                 {\cf19 return} DebugEventNative.DebugEvent_IsEventFrom32Bit(Native);\par
00323             \}\par
00324         \}\par
00325 \par
00326     \}\par
00327 \par
00328     \par
00332     {\cf17 public} {\cf17 class }DebugEventLoadDllInfo : DebugEventStaticContainer\par
00333     \{\par
00334         {\cf17 public} DebugEventLoadDllInfo(IntPtr Nat) : base(Nat)\par
00335         \{\par
00336 \par
00337         \}\par
00338 \par
00339         {\cf17 public} DebugEventLoadDllInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00340         \{\par
00341 \par
00342         \}\par
00343 \par
00344 \par
00345         {\cf17 public} DebugEventLoadDllInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00346         \{\par
00347 \par
00348         \}\par
00349 \par
00353         {\cf17 public} IntPtr FileHandle\par
00354         \{\par
00355             {\cf17 get}\par
00356             \{\par
00357                 {\cf19 return} DebugEventNative.DebugEvent_LoadDllInfo_GetHFile(Native);\par
00358             \}\par
00359         \}\par
00360 \par
00364         {\cf17 public} IntPtr DllBaseAddress\par
00365         \{\par
00366             {\cf17 get}\par
00367             \{\par
00368                 {\cf19 return} DebugEventNative.DebugEvent_LoadDllInfo_GetBaseOfDll(Native);\par
00369             \}\par
00370         \}\par
00371 \par
00375         {\cf17 public} uint DebugInfoSize\par
00376         \{\par
00377             {\cf17 get}\par
00378             \{\par
00379                 {\cf19 return} DebugEventNative.DebugEvent_LoadDllINfo_GetDebugInfoSize(Native);\par
00380             \}\par
00381         \}\par
00385         {\cf17 public} uint DebugInfoOffset\par
00386         \{\par
00387             {\cf17 get}\par
00388             \{\par
00389                 {\cf19 return} DebugEventNative.DebugEvent_LoadDllINfo_GetDebugInfoOffset(Native);\par
00390             \}\par
00391         \}\par
00392 \par
00393 \par
00397         {\cf17 public} {\cf18 bool} IsImageNameStringUnicode\par
00398         \{\par
00399             {\cf17 get}\par
00400             \{\par
00401                 {\cf19 if} (DebugEventNative.DebugEvent_LoadDllInfo_GetUnicodeFlag(Native) != 0) \par
00402                 \{\par
00403                     {\cf19 return} {\cf17 true};\par
00404                 \}\par
00405                 {\cf19 return} {\cf17 false};\par
00406             \}\par
00407         \}\par
00408 \par
00414         {\cf17 public} {\cf18 byte}[] GetDebugInfo()\par
00415         \{\par
00416             {\cf19 if} (this.FileHandle == IntPtr.Zero)\par
00417             \{\par
00418                 {\cf19 return} {\cf17 null};\par
00419             \}\par
00420             {\cf19 else}\par
00421             \{\par
00422                 {\cf19 if} (DebugInfoSize != 0)\par
00423                 \{\par
00424                     var ret = {\cf17 new} {\cf18 byte}[this.DebugInfoSize];\par
00425                     {\cf17 using} (var fn = {\cf17 new} FileStream({\cf17 new} Microsoft.Win32.SafeHandles.SafeFileHandle(FileHandle,{\cf17 false}), FileAccess.ReadWrite))\par
00426                     \{\par
00427                         fn.Seek(DebugInfoOffset, SeekOrigin.Begin);\par
00428                         fn.Read(ret, 0, ret.Length);\par
00429                         {\cf19 return} ret;\par
00430                     \}\par
00431                 \}\par
00432                 {\cf19 return} {\cf17 null};\par
00433 \par
00434             \}\par
00435         \}\par
00436 \par
00440         {\cf17 public} {\cf18 string} ImageName\par
00441         \{\par
00442             {\cf17 get}\par
00443             \{\par
00444                 {\cf19 if} (FileHandle != IntPtr.Zero)\par
00445                 \{\par
00446                     {\cf19 return} HelperRoutines.GetFileNameViaHandle(FileHandle);\par
00447                 \}\par
00448                 {\cf19 return} {\cf17 null}; \par
00449             \}\par
00450         \}\par
00451     \}\par
00452 \par
00456     {\cf17 public} {\cf17 class }DebugEventExceptionInfo : DebugEventStaticContainer\par
00457     \{\par
00458         {\cf17 public} DebugEventExceptionInfo(IntPtr Nat) : base(Nat)\par
00459         \{\par
00460 \par
00461         \}\par
00462 \par
00463         {\cf17 public} DebugEventExceptionInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00464         \{\par
00465 \par
00466         \}\par
00467 \par
00468 \par
00469         {\cf17 public} DebugEventExceptionInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00470         \{\par
00471 \par
00472         \}\par
00473 \par
00474         {\cf17 public} uint ExceptionParameterCount\par
00475         \{\par
00476             {\cf17 get}\par
00477             \{\par
00478                 {\cf19 return} DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionArgumentCount(Native);\par
00479             \}\par
00480         \}\par
00481 \par
00482         \par
00483 \par
00488         {\cf17 public} uint[] ExceptionParameter32\par
00489         \{\par
00490             {\cf17 get}\par
00491             \{\par
00492                 IntPtr ptr = DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionInformation(Native);\par
00493                 {\cf19 if} (ptr != IntPtr.Zero)\par
00494                 \{\par
00495                     uint[] ret = {\cf17 new} uint[ExceptionParameterCount];\par
00496                     IntPtr stepper = ptr;\par
00497                     {\cf19 for} ({\cf18 int} step = 0; step < ExceptionParameterCount; step++)\par
00498                     \{\par
00499                         ret[step] = (uint) MemoryNative.Peek8(stepper);\par
00500                         stepper += {\cf17 sizeof}(ulong);\par
00501                     \}\par
00502                     NativeMethods.SimpleFree(ptr);\par
00503                     {\cf19 return} ret;\par
00504                 \}\par
00505                 {\cf19 return} {\cf17 null};\par
00506             \}\par
00507         \}\par
00508 \par
00512         {\cf17 public} ulong[] ExceptionParameter64\par
00513         \{\par
00514             {\cf17 get}\par
00515             \{\par
00516                 IntPtr ptr = DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionInformation(Native);\par
00517                 {\cf19 if} (ptr != IntPtr.Zero)\par
00518                 \{\par
00519                     ulong[] ret = {\cf17 new} ulong[ExceptionParameterCount];\par
00520                     IntPtr stepper = ptr;\par
00521                     {\cf19 for} ({\cf18 int} step = 0; step < ExceptionParameterCount; step++)\par
00522                     \{\par
00523                         ret[step] = MemoryNative.Peek8(stepper);\par
00524                         stepper += {\cf17 sizeof}(ulong);\par
00525                     \}\par
00526                     NativeMethods.SimpleFree(ptr);\par
00527                     {\cf19 return} ret;\par
00528                 \}\par
00529                 {\cf19 return} {\cf17 null};\par
00530             \}\par
00531         \}\par
00532 \par
00536         {\cf17 public} ulong ExceptionAddress64\par
00537         \{\par
00538             {\cf17 get}\par
00539             \{\par
00540                 {\cf19 return} DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionAddress(Native);\par
00541             \}\par
00542         \}\par
00543 \par
00547         {\cf17 public} uint ExceptionAddress32\par
00548         \{\par
00549             {\cf17 get}\par
00550             \{\par
00551                 {\cf19 return} (uint)DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionAddress(Native);\par
00552             \}\par
00553         \}\par
00554 \par
00555 \par
00556         {\cf17 public} uint ExceptionFlags\par
00557         \{\par
00558             {\cf17 get}\par
00559             \{\par
00560                 {\cf19 return} DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionFlags(Native);\par
00561             \}\par
00562         \}    \par
00563 \par
00564 \par
00568         {\cf17 public} uint ExceptionCode_as_int\par
00569         \{\par
00570             {\cf17 get}\par
00571             \{\par
00572                 {\cf19 return} DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionCode(Native);\par
00573             \}\par
00574         \}\par
00575 \par
00576         {\cf17 public} DebugExceptionTypes ExceptionCode\par
00577         \{\par
00578             {\cf17 get}\par
00579             \{\par
00580                 {\cf19 return} (DebugExceptionTypes)DebugEventNative.DebugEvent_ExceptionInfo_GetExceptionCode(Native);\par
00581             \}\par
00582         \}\par
00583 \par
00587         {\cf17 public} {\cf18 bool} IsFirstChanceException\par
00588         \{\par
00589             {\cf17 get}\par
00590             \{\par
00591                 {\cf19 if} (DebugEventNative.DebugEvent_ExceptionInfo_GetFirstChance(Native) != 0)\par
00592                 \{\par
00593                     {\cf19 return} {\cf17 true};\par
00594                 \}\par
00595                 {\cf19 return} {\cf17 false};\par
00596             \}\par
00597         \}\par
00598     \}\par
00599 \par
00600 \par
00601     {\cf17 public} {\cf17 class }DebugEventCreateThreadInfo : DebugEventStaticContainer\par
00602     \{\par
00603         {\cf17 public} DebugEventCreateThreadInfo(IntPtr Nat) : base(Nat)\par
00604         \{\par
00605 \par
00606         \}\par
00607 \par
00608         {\cf17 public} DebugEventCreateThreadInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00609         \{\par
00610 \par
00611         \}\par
00612 \par
00613         {\cf17 public} DebugEventCreateThreadInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00614         \{\par
00615 \par
00616         \}\par
00617 \par
00621         {\cf17 public} IntPtr ThreadHandle\par
00622         \{\par
00623             {\cf17 get}\par
00624             \{\par
00625                 {\cf19 return} DebugEventNative.DebugEvent_CreateThreadInfo_GetThreadHandle(Native);\par
00626             \}\par
00627         \}\par
00628 \par
00632         {\cf17 public} IntPtr ThreadStartAddress\par
00633         \{\par
00634             {\cf17 get}\par
00635             \{\par
00636                 {\cf19 return} DebugEventNative.DebugEvent_CreateThreadInfo_GetThreadStartAddress(Native);\par
00637             \}\par
00638         \}\par
00639 \par
00643         {\cf17 public} IntPtr ThreadLocalBase\par
00644         \{\par
00645             {\cf17 get}\par
00646             \{\par
00647                 {\cf19 return} DebugEventNative.DebugEvent_CreateThreadInfo_GetThreadLocalBase(Native);\par
00648             \}\par
00649         \}\par
00650 \par
00654         {\cf17 public} IntPtr ThreadLocalStoragePointer\par
00655         \{\par
00656             {\cf17 get}\par
00657             \{\par
00658                 {\cf19 return} {\cf17 new} IntPtr(ThreadLocalBase.ToInt32() + 0x2C);\par
00659             \}\par
00660         \}\par
00661     \}\par
00662 \par
00663 \par
00664 \par
00665 \par
00666     {\cf17 public} {\cf17 class }DebugEventExitThreadInfo : DebugEventStaticContainer\par
00667     \{\par
00668         {\cf17 public} DebugEventExitThreadInfo(IntPtr Nat) : base(Nat)\par
00669         \{\par
00670 \par
00671         \}\par
00672 \par
00673         {\cf17 public} DebugEventExitThreadInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00674         \{\par
00675 \par
00676         \}\par
00677 \par
00678         {\cf17 public} DebugEventExitThreadInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00679         \{\par
00680 \par
00681         \}\par
00682 \par
00683 \par
00687         {\cf17 public} uint ExitCode\par
00688         \{\par
00689             {\cf17 get}\par
00690             \{\par
00691                 {\cf19 return} DebugEventNative.DebugEvent_ExitThreadInfo_GetExitCode(Native);\par
00692             \}\par
00693         \}\par
00694     \}\par
00695 \par
00696 \par
00697     {\cf17 public} {\cf17 class }DebugEventExitProcessInfo : DebugEventStaticContainer\par
00698     \{\par
00699         {\cf17 public} DebugEventExitProcessInfo(IntPtr Nat) : base(Nat)\par
00700         \{\par
00701 \par
00702         \}\par
00703 \par
00704         {\cf17 public} DebugEventExitProcessInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00705         \{\par
00706 \par
00707         \}\par
00708 \par
00709         {\cf17 public} DebugEventExitProcessInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00710         \{\par
00711 \par
00712         \}\par
00713 \par
00717         {\cf17 public} uint ExitCode\par
00718         \{\par
00719             {\cf17 get}\par
00720             \{\par
00721                 {\cf19 return} DebugEventNative.DebugEvent_ExitProcessInfo_GetExitCode(Native);\par
00722             \}\par
00723         \}\par
00724     \}\par
00725 \par
00726 \par
00727     {\cf17 public} {\cf17 class }DebugEventCreateProcessInfo :DebugEventStaticContainer\par
00728     \{\par
00729         {\cf17 public} DebugEventCreateProcessInfo(IntPtr Nat): base(Nat)\par
00730         \{\par
00731             \par
00732         \}\par
00733 \par
00734 \par
00735         {\cf17 public} DebugEventCreateProcessInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00736         \{\par
00737 \par
00738         \}\par
00739 \par
00740         {\cf17 public} DebugEventCreateProcessInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00741         \{\par
00742 \par
00743         \}\par
00744 \par
00748         {\cf17 public} IntPtr NativeFileHandle\par
00749         \{\par
00750             {\cf17 get}\par
00751             \{\par
00752                 {\cf19 return} DebugEventNative.DebugEvent_CreateProcessGetFileHandle(Native);\par
00753             \}\par
00754         \}\par
00755 \par
00756 \par
00760         {\cf17 public} {\cf18 string} ImageName\par
00761         \{\par
00762             {\cf17 get}\par
00763             \{\par
00764                 {\cf19 return} HelperRoutines.GetFileNameViaHandle(NativeFileHandle); \par
00765             \}\par
00766         \}\par
00767 \par
00772         {\cf17 public} {\cf18 byte}[] GetFileContents()\par
00773         \{\par
00774             \par
00775             \{\par
00776                 {\cf19 if} (NativeFileHandle != IntPtr.Zero)\par
00777                 \{\par
00778                    \par
00779                     {\cf19 if} (ImageName != {\cf17 null})\par
00780                     \{\par
00781                         {\cf19 return} File.ReadAllBytes(ImageName);\par
00782                     \}\par
00783                 \}\par
00784                 {\cf19 return} {\cf17 null};\par
00785             \}\par
00786         \}\par
00787 \par
00788         \par
00789 \par
00790 \par
00791  \par
00792         \par
00793     \}\par
00797     {\cf17 public} {\cf17 class }DebugEventStringInfo: DebugEventStaticContainer\par
00798     \{\par
00799         {\cf17 public} DebugEventStringInfo(IntPtr Native) :base(Native)\par
00800         \{\par
00801             \par
00802         \}\par
00803 \par
00804         {\cf17 public} DebugEventStringInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00805         \{\par
00806 \par
00807         \}\par
00808 \par
00809         {\cf17 public} DebugEventStringInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00810         \{\par
00811 \par
00812         \}\par
00813 \par
00814         {\cf17 public} {\cf17 override} {\cf18 string} ToString()\par
00815         \{\par
00816             {\cf19 return} OutputString;\par
00817         \}\par
00821         {\cf17 public} {\cf18 string} OutputString\par
00822         \{\par
00823             {\cf17 get}\par
00824             \{\par
00825                 \par
00826                 {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.OutputDebugString)\par
00827                 \{\par
00828                     {\cf19 return} {\cf17 null};\par
00829                 \}\par
00830                 {\cf19 else}\par
00831                 \{\par
00832                     IntPtr NativeHandle = NativeMethods.OpenProcessForMemoryAccess(DebugEventNative.DebugEvent_GetProcessID(Native));\par
00833                     {\cf19 if} (NativeHandle == IntPtr.Zero)\par
00834                     \{\par
00835                         {\cf19 return} {\cf17 null};\par
00836                     \}\par
00840                     {\cf18 string} Managed = RemoteStructure.RemoteReadDebugString(NativeHandle, Native);\par
00841                     NativeMethods.CloseHandle(NativeHandle);\par
00842                     {\cf19 return} Managed;\par
00843                 \}\par
00844             \}\par
00845         \}\par
00846         \par
00847     \}\par
00848 \par
00852     {\cf17 public} {\cf17 class }DebugEventRipInfo: DebugEventStaticContainer\par
00853     \{\par
00854         {\cf17 public} DebugEventRipInfo(IntPtr NativePtr) : base(NativePtr)\par
00855         \{\par
00856 \par
00857         \}\par
00858         {\cf17 public} DebugEventRipInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00859         \{\par
00860 \par
00861         \}\par
00862 \par
00863         {\cf17 public} DebugEventRipInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00864         \{\par
00865 \par
00866         \}\par
00867 \par
00868 \par
00869 \par
00873         {\cf17 public} uint Error\par
00874             \{\par
00875                 {\cf17 get}\par
00876                 \{\par
00877                     {\cf19 return} DebugEventNative.DebugEvent_RipGetError(Native);\par
00878                 \}\par
00879             \}\par
00880 \par
00881 \par
00885             {\cf17 public} RipErrorType ErrorType\par
00886             \{\par
00887                 {\cf17 get}\par
00888                 \{\par
00889                     {\cf19 return} DebugEventNative.DebugEvent_RipGetErrorType(Native);\par
00890                 \}\par
00891             \}\par
00892 \par
00893         \}\par
00894 \par
00895 \par
00896 \par
00897     {\cf17 public} {\cf17 class }DebugEventUnloadDllInfo: DebugEventStaticContainer\par
00898     \{\par
00899 \par
00904         {\cf17 public} DebugEventUnloadDllInfo(IntPtr NativePtr) : base(NativePtr)\par
00905         \{\par
00906 \par
00907         \}\par
00908 \par
00909         {\cf17 public} DebugEventUnloadDllInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00910         \{\par
00911 \par
00912         \}\par
00913 \par
00914         {\cf17 public} DebugEventUnloadDllInfo(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00915         \{\par
00916 \par
00917         \}\par
00918 \par
00919 \par
00923         {\cf17 public} IntPtr BaseOfDll\par
00924         \{\par
00925             {\cf17 get}\par
00926             \{\par
00927                 {\cf19 return} {\cf17 new} IntPtr(({\cf18 long})DebugEventNative.DebugEvent_UnloadDllInfo_GetBaseAddress(Native));\par
00928             \}\par
00929         \}\par
00930 \par
00931     \}\par
00932 \par
00936     {\cf17 public} {\cf17 class }DebugEvent : DebugEventStaticContainer\par
00937     \{\par
00938        \par
00939         {\cf17 private} {\cf17 static} readonly {\cf18 string} error_msg_bad_event_fetch = {\cf22 "Attempt to fetch \{0\} from an event that does not contain the event \{1\}"};\par
00940 \par
00945         {\cf17 public} DebugEvent(IntPtr NativePtr) : base(NativePtr)\par
00946         \{\par
00947             FreeOnCleanupContainer = {\cf17 false};\par
00948         \}\par
00949 \par
00950 \par
00951         {\cf17 public} DebugEvent(IntPtr Nat, {\cf18 bool} FreeOnCleanup) : base(Nat, FreeOnCleanup, 1)\par
00952         \{\par
00953 \par
00954         \}\par
00955 \par
00956         {\cf17 public} DebugEvent(IntPtr Nat, {\cf18 bool} FreeOnCleanup, ulong RefCount) : base(Nat, FreeOnCleanup, RefCount)\par
00957         \{\par
00958 \par
00959         \}\par
00960 \par
00965         {\cf17 public} {\cf17 static} DebugEvent CreatePrivateStruct()\par
00966         \{\par
00967             {\cf19 return} {\cf17 new} DebugEvent(DebugEventNative.DebugEvent_AllocateStructure(), {\cf17 true});\par
00968         \}\par
00969   \par
00970 \par
00971 \par
00972         {\cf18 bool} disposedValue;\par
00973         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00974         \{\par
00975             {\cf19 if} (!disposedValue)\par
00976             \{\par
00977 \par
00978                 disposedValue = {\cf17 true};\par
00979             \}\par
00980             base.Dispose(disposing);\par
00981         \}\par
00982 \par
00983 \par
00984 \par
00985 {\cf21         #region Wrapper Creation}\par
00990         {\cf17 public} DebugEventCreateProcessInfo GetDebugEventCreateProcessInfo()\par
00991         \{\par
00992             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.CreateProcessEvent)\par
00993             \{\par
00994                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Create Process Information"}, {\cf22 " Create Process Event"} \}));\par
00995             \}\par
00996             AddRef();\par
00997             var ret = {\cf17 new} DebugEventCreateProcessInfo(Native, FreeOnCleanup, ReferenceCounter);\par
00998             {\cf19 if} (ret == {\cf17 null})\par
00999             \{\par
01000                 Release();\par
01001             \}\par
01002             {\cf19 return} ret;\par
01003         \}\par
01004 \par
01005         {\cf17 public} DebugEventCreateThreadInfo GetDebugEventCreateThreadInfo()\par
01006         \{\par
01007             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.CreateTheadEvent)\par
01008             \{\par
01009                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Create Thread Information"}, {\cf22 " Create Thread Event"} \}));\par
01010             \}\par
01011             AddRef();\par
01012             var ret = {\cf17 new} DebugEventCreateThreadInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01013             {\cf19 if} (ret == {\cf17 null})\par
01014             \{\par
01015                 Release();\par
01016             \}\par
01017             {\cf19 return} ret;\par
01018         \}\par
01019 \par
01020 \par
01021         {\cf17 public} DebugEventExceptionInfo GetDebugEventExceptionInfo()\par
01022         \{\par
01023             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.ExceptionEvent)\par
01024             \{\par
01025                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Exception Information"}, {\cf22 " Exception Event"} \}));\par
01026             \}\par
01027 \par
01028             AddRef();\par
01029             var ret = {\cf17 new} DebugEventExceptionInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01030             {\cf19 if} (ret == {\cf17 null})\par
01031             \{\par
01032                 Release();\par
01033             \}\par
01034             {\cf19 return} ret;\par
01035 \par
01036             \par
01037         \}\par
01038 \par
01039         {\cf17 public} DebugEventExitProcessInfo GetEventExitProcessInfo()\par
01040         \{\par
01041             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.ExitProcessEvent)\par
01042             \{\par
01043                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Process Exit Information"}, {\cf22 " Process Exit Event"} \}));\par
01044             \}\par
01045 \par
01046             AddRef();\par
01047             var ret = {\cf17 new} DebugEventExitProcessInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01048             {\cf19 if} (ret == {\cf17 null})\par
01049             \{\par
01050                 Release();\par
01051             \}\par
01052             {\cf19 return} ret;\par
01053 \par
01054         \}\par
01055 \par
01056         {\cf17 public} DebugEventExitThreadInfo GetEventExitThreadInfo()\par
01057         \{\par
01058             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.ExitThreadEvent)\par
01059             \{\par
01060                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Thread Exit Information"}, {\cf22 " Thread Exit Event"} \}));\par
01061             \}\par
01062 \par
01063             AddRef();\par
01064             var ret = {\cf17 new} DebugEventExitThreadInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01065             {\cf19 if} (ret == {\cf17 null})\par
01066             \{\par
01067                 Release();\par
01068             \}\par
01069             {\cf19 return} ret;\par
01070         \}\par
01071 \par
01072 \par
01073         {\cf17 public} DebugEventLoadDllInfo GetDebugEventLoadDll()\par
01074         \{\par
01075             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.LoadDllEvent)\par
01076             \{\par
01077                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "DLL Load Information"}, {\cf22 " DLL Load  Event"} \}));\par
01078             \}\par
01079 \par
01080             AddRef();\par
01081             var ret = {\cf17 new} DebugEventLoadDllInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01082             {\cf19 if} (ret == {\cf17 null})\par
01083             \{\par
01084                 Release();\par
01085             \}\par
01086             {\cf19 return} ret;\par
01087         \}\par
01088 \par
01093         {\cf17 public} DebugEventStringInfo GetDebugEventStringInfo()\par
01094         \{\par
01095             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.OutputDebugString)\par
01096             \{\par
01097                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Debug String Information"}, {\cf22 " Debug String Struct"} \}));\par
01098             \}\par
01099 \par
01100             AddRef();\par
01101             var ret = {\cf17 new} DebugEventStringInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01102             {\cf19 if} (ret == {\cf17 null})\par
01103             \{\par
01104                 Release();\par
01105             \}\par
01106             {\cf19 return} ret;\par
01107         \}\par
01108 \par
01109 \par
01115         {\cf17 public} DebugEventRipInfo GetDebugEventRipInfo()\par
01116         \{\par
01117             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.RipEvent)\par
01118             \{\par
01119                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Rip Information"}, {\cf22 "Rip Struct"} \}));\par
01120             \}\par
01121             AddRef();\par
01122             var ret = {\cf17 new} DebugEventRipInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01123             {\cf19 if} (ret == {\cf17 null})\par
01124             \{\par
01125                 Release();\par
01126             \}\par
01127             {\cf19 return} ret;\par
01128         \}\par
01129 \par
01130         {\cf17 public} DebugEventUnloadDllInfo GetDebugEventUnloadDllInfo()\par
01131         \{\par
01132             {\cf19 if} (DebugEventNative.DebugEvent_GetEventType(Native) != DebugEventType.UnloadDllEvent)\par
01133             \{\par
01134                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf18 string}.Format(error_msg_bad_event_fetch, {\cf17 new} {\cf18 object}[] \{ {\cf22 "Dll free/unload Information"}, {\cf22 " Unload Dll Event"} \}));\par
01135             \}\par
01136             AddRef();\par
01137             var ret = {\cf17 new} DebugEventUnloadDllInfo(Native, FreeOnCleanup, ReferenceCounter);\par
01138             {\cf19 if} (ret == {\cf17 null})\par
01139             \{\par
01140                 Release();\par
01141             \}\par
01142             {\cf19 return} ret;\par
01143         \}\par
01144 \par
01145 {\cf21         #endregion}\par
01146 {\cf21         #region C# boiler plate dispose and the underlying struct}\par
01147 \par
01148 \par
01149 \par
01150 \par
01151         ~DebugEvent()\par
01152          \{\par
01153              {\cf20 // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method}\par
01154              Dispose(disposing: {\cf17 false});\par
01155          \}\par
01156 \par
01157 \par
01158 {\cf21         #endregion}\par
01159  \par
01160     \}\par
01161 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/DebugEventWorkerThreadSupport.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/DebugEventWorkerThreadSupport.cs}
{\xe \v Debugging/DebugEventWorkerThreadSupport.cs}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.DebugEventWorkerThreadSupport}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you are wanting to control your debug message pump on the .NET side rather than native (why?), then these routines will help you glue everything together. This class exists only in the sheath and is not duplicated in Native. Some routines here may be echoed in other classes in the sheath Some of the routines here exist as extensions to {\b DebugEvent} }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DebugEventWorkerThreadSupport.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/DebugEventWorkerThreadSupport.cs}
{\xe \v Debugging/DebugEventWorkerThreadSupport.cs}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 {\cf17 using }InsightSheath;\par
00008 {\cf17 using }InsightSheath.Debugging.Process;\par
00009 \par
00010 {\cf17 namespace }InsightSheath.Debugging\par
00011 \{\par
00017     {\cf17 public} {\cf17 static} {\cf17 class }DebugEventWorkerThreadSupport\par
00018     \{\par
00019         [DllImport({\cf22 "kernel32.dll"},SetLastError ={\cf17 true})]\par
00020         {\cf17 internal} {\cf17 static} {\cf17 extern} {\cf18 bool} WaitForDebugEventEx(IntPtr DebugEvent, uint Timeout);\par
00021 \par
00022         [DllImport({\cf22 "kernel32.dll"}, SetLastError = {\cf17 true}, EntryPoint ={\cf22 "ContinueDebugEvent"})]\par
00023         {\cf17 internal} {\cf17 static} {\cf17 extern} {\cf18 bool} ContinueDebugEventInternal(uint ProcessId, uint ThreadID, uint ContinueState);\par
00024 \par
00031         {\cf17 public} {\cf17 static} {\cf18 bool} WaitForDebugEvent({\cf17 this} DebugEvent Output, uint WaitTime)\par
00032         \{\par
00033             {\cf19 return} WaitForDebugEventEx(Output.NativePointer, WaitTime);\par
00034         \}\par
00035 \par
00044 {\cf21 #pragma warning disable IDE0060 }{\cf20 // Remove unused parameter}\par
00045         {\cf17 public} {\cf17 static} {\cf18 bool} ContinueDebugEvent({\cf17 this} DebugEvent that,uint ProcessId, uint ThreadId, DebugContState ContinueState)\par
00046 {\cf21 #pragma warning restore IDE0060 }{\cf20 // Remove unused parameter}\par
00047         \{\par
00048             {\cf19 return} ContinueDebugEventInternal(ProcessId, ThreadId, (uint)ContinueState);\par
00049         \}\par
00050     \}\par
00051 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Process/InsightMemory.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/InsightMemory.cs}
{\xe \v Debugging/Process/InsightMemory.cs}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.Process.InsightMemory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory data about an arbitrary process of your choice }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Process}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightMemory.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/InsightMemory.cs}
{\xe \v Debugging/Process/InsightMemory.cs}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.NativeImports;\par
00008 {\cf17 using }InsightSheath.Win32Struct;\par
00009 {\cf17 using }InsightSheath.Abstract;\par
00010 \par
00011 {\cf17 namespace }InsightSheath.Debugging.Process\par
00012 \{\par
00016     {\cf17 public} {\cf17 class }InsightMemory : NativeStaticContainer\par
00017     \{\par
00022         {\cf17 public} {\cf17 static} InsightMemory CreateInstance()\par
00023         \{\par
00024             {\cf19 return} {\cf17 new} InsightMemory(InternalInsightMemory.MakeInstance());\par
00025         \}\par
00026 \par
00032         {\cf17 public} {\cf17 static} InsightMemory CreateInstance(IntPtr Handle)\par
00033         \{\par
00034             var ret = {\cf17 new} InsightMemory(InternalInsightMemory.MakeInstance());\par
00035             ret.SetTargetProcess(Handle);\par
00036             {\cf19 return} ret;\par
00037         \}\par
00038 \par
00044         {\cf17 public} {\cf17 static} InsightMemory CreateInstance(uint Process)\par
00045         \{\par
00046             var ret = {\cf17 new} InsightMemory(InternalInsightMemory.MakeInstance());\par
00047             ret.SetTargetProcess(Process);\par
00048             {\cf19 return} ret;\par
00049         \}\par
00055         {\cf17 public} {\cf17 static} InsightMemory DuplicateInstance(InsightMemory Other)\par
00056         \{\par
00057             {\cf19 return} {\cf17 new} InsightMemory(InternalInsightMemory.DupInstance(Other.Native));\par
00058         \}\par
00059         \par
00065         {\cf17 public} InsightMemory(IntPtr that): base(that)\par
00066         \{\par
00067             {\cf19 if} (that == IntPtr.Zero)\par
00068             \{\par
00069                 {\cf20 //throw new ArgumentNullException(nameof(that));}\par
00070                 {\cf20 //throw new ArgumentNullException(WrapperConstructorReceivedNullPointerErrorMsg("Argument", this.GetType().Name + ".CreateInstance", nameof(Native)));}\par
00071                 {\cf19 throw} WrapperConstructorReceivedNullPointerErrorException({\cf22 "Argument"}, GetType().Name + {\cf22 ".CreateInstance"}, nameof(Native));\par
00072             \}\par
00073         \}\par
00074 \par
00081         {\cf17 public} InsightMemory(IntPtr that, {\cf18 bool} FreeOnCleanup): base(that, false)\par
00082         \{\par
00083             {\cf19 if} (that == IntPtr.Zero)\par
00084             \{\par
00085                 {\cf19 throw} {\cf17 new} ArgumentNullException(nameof(that));\par
00086             \}\par
00087         \}\par
00088 \par
00093         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00094         \{\par
00095             base.Dispose(disposing);\par
00096             InternalInsightMemory.KillInstance(Native);\par
00097             GC.SuppressFinalize({\cf17 this});\par
00098         \}\par
00099 \par
00104         {\cf17 public} {\cf18 bool} AutoUpdateMemory\par
00105         \{\par
00106             {\cf17 get}\par
00107             \{\par
00108                 {\cf19 return} InternalInsightMemory.GetAutoRefreshMemoryStats(Native);\par
00109             \}\par
00110             {\cf17 set}\par
00111             \{\par
00112                 InternalInsightMemory.SetAutoRefreshMemoryStats(Native, value);\par
00113             \}\par
00114         \}\par
00115 \par
00116 \par
00121         {\cf17 public} ProcessMemoryCount32? MemoryStatsBulk32\par
00122         \{\par
00123             {\cf17 get}\par
00124             \{\par
00125                 IntPtr ret =  InternalInsightMemory.InsightMemory_GetMemoryStatsBulk(Native);\par
00126                 {\cf19 if} (ret != IntPtr.Zero)\par
00127                 \{\par
00128                     {\cf19 return} Marshal.PtrToStructure<ProcessMemoryCount32>(ret);\par
00129                 \}\par
00130                 {\cf19 return} {\cf17 null};\par
00131             \}\par
00132         \}\par
00133 \par
00138         {\cf17 public} ProcessMemoryCount64? MemoryStatsBulk64\par
00139         \{\par
00140             {\cf17 get}\par
00141             \{\par
00142                 IntPtr ret = InternalInsightMemory.InsightMemory_GetMemoryStatsBulk(Native);\par
00143                 {\cf19 if} (ret != IntPtr.Zero)\par
00144                 \{\par
00145                     {\cf19 return} Marshal.PtrToStructure<ProcessMemoryCount64>(ret);\par
00146                 \}\par
00147                 {\cf19 return} {\cf17 null};\par
00148             \}\par
00149         \}\par
00156         {\cf17 public} {\cf18 bool} SetTargetProcess(IntPtr Handle)\par
00157         \{\par
00158             {\cf19 return} InternalInsightMemory.SetTargetProcess(Native, (ulong)Handle, {\cf17 true});\par
00159         \}\par
00160 \par
00167         {\cf17 public} {\cf18 bool} SetTargetProcess(uint ProcessId)\par
00168         \{\par
00169             {\cf19 return} InternalInsightMemory.SetTargetProcess(Native, ProcessId, {\cf17 false});\par
00170         \}\par
00171 \par
00176         {\cf17 public} {\cf18 bool} ManualRefreshStats()\par
00177         \{\par
00178             {\cf19 return} InternalInsightMemory.UpdateMemoryStats(Native);\par
00179         \}\par
00180 \par
00185         {\cf17 public} ulong PageFaultCount\par
00186         \{\par
00187             {\cf17 get}\par
00188             \{\par
00189                 {\cf19 return} InternalInsightMemory.GetPageFaultCount(Native);\par
00190             \}\par
00191         \}\par
00192 \par
00197         {\cf17 public} ulong PeakWorkingSetSize\par
00198         \{\par
00199             {\cf17 get}\par
00200             \{\par
00201                 {\cf19 return} InternalInsightMemory.GetPeakWorkingSetSize(Native);\par
00202             \}\par
00203         \}\par
00208         {\cf17 public} ulong WorkingSetSize\par
00209         \{\par
00210             {\cf17 get}\par
00211             \{\par
00212                 {\cf19 return} InternalInsightMemory.GetWorkingSetSize(Native);\par
00213             \}\par
00214         \}\par
00215 \par
00220         {\cf17 public} ulong QuotaPeakPagedPoolUsage\par
00221         \{\par
00222             {\cf17 get}\par
00223             \{\par
00224                 {\cf19 return} InternalInsightMemory.GetQuotaPeakPagedPoolUsage(Native);\par
00225             \}\par
00226         \}\par
00231         {\cf17 public} ulong QuotaPagedPoolUsage\par
00232         \{\par
00233             {\cf17 get}\par
00234             \{\par
00235                 {\cf19 return} InternalInsightMemory.GetQuotaPagePoolUsage(Native);\par
00236             \}\par
00237         \}\par
00242         {\cf17 public} ulong QuotaPeakNonPagedPoolUsage\par
00243         \{\par
00244             {\cf20 //InsightMemory_GetPeakNonPagePoolUsage}\par
00245             {\cf17 get}\par
00246             \{\par
00247                 {\cf19 return} InternalInsightMemory.GetPeakNonPagePoolUsage(Native);\par
00248             \}\par
00249         \}\par
00250 \par
00255         {\cf17 public} ulong QuotaNonPagedPoolUsage\par
00256         \{\par
00257             {\cf17 get}\par
00258             \{\par
00259                 {\cf19 return} InternalInsightMemory.GetQuotaNonPagedPoolUsage(Native);\par
00260             \}\par
00261         \}\par
00262 \par
00267         {\cf17 public} ulong PageFileUsage\par
00268         \{\par
00269             {\cf17 get}\par
00270             \{\par
00271                 {\cf19 return} InternalInsightMemory.GetPageFileUsage(Native);\par
00272             \}\par
00273         \}\par
00278         {\cf17 public} ulong PeakPageFileUsage\par
00279         \{\par
00280             {\cf17 get}\par
00281             \{\par
00282                 {\cf19 return} InternalInsightMemory.GetPeakPageFileUsage(Native);\par
00283             \}\par
00284         \}\par
00285 \par
00290         {\cf17 public} ulong PrivateUsage\par
00291         \{\par
00292             {\cf17 get}\par
00293             \{\par
00294                 {\cf19 return} InternalInsightMemory.GetPrivateUsage(Native);\par
00295             \}\par
00296         \}\par
00297     \}\par
00298 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Process/InsightProcess.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/InsightProcess.cs}
{\xe \v Debugging/Process/InsightProcess.cs}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.Process.InsightProcess}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
choose an environment and spawn a process. This class is a wrapper for the C++ Class named "InsightProcess" implemented as a native DLL in the source PS_ProcessInformation.cpp and said class is the functionally the heart of the DLL. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Process}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.Process.DebugContState} : uint \{ {\b InsightSheath.Debugging.Process.DebugContinueState} = 0x00010002
, {\b InsightSheath.Debugging.Process.DebugExceptionNotHandled} = 0x80010001
, {\b InsightSheath.Debugging.Process.DebugExceptionReplyLater} = 0x40010001
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum to control how to return control of a debugged process your debugger is respending too back to Windows. Used in several spots. InsightProcess, DebugEventWorkerThreadSupport }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.Process.DebugModeType} \{ {\b InsightSheath.Debugging.Process.NoWorkerThread} = 0
, {\b InsightSheath.Debugging.Process.WorkerThread} = 1
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags to indicate to InsightProcess if you want the worker thread or not. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightProcess.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/InsightProcess.cs}
{\xe \v Debugging/Process/InsightProcess.cs}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.NativeImports;\par
00002 {\cf17 using }InsightSheath.Win32Struct;\par
00003 {\cf17 using }System;\par
00004 {\cf17 using }System.Collections.Generic;\par
00005 {\cf17 using }System.Diagnostics;\par
00006 {\cf17 using }System.Linq;\par
00007 {\cf17 using }System.Runtime.InteropServices;\par
00008 {\cf17 using }System.Text;\par
00009 {\cf17 using }System.Threading.Tasks;\par
00010 {\cf17 using }InsightSheath.Abstract;\par
00011 {\cf17 using }InsightSheath.Debugging.SymbolEngine;\par
00012 \par
00013 {\cf17 namespace }InsightSheath.Debugging.Process\par
00014 \{\par
00018     {\cf17 public} {\cf17 enum} DebugContState : uint\par
00019     \{\par
00023         DebugContinueState = 0x00010002,\par
00027         DebugExceptionNotHandled = 0x80010001,\par
00031         DebugExceptionReplyLater = 0x40010001\par
00032     \}\par
00033 \par
00037     [Flags]\par
00038     {\cf17 public} {\cf17 enum} DebugModeType\par
00039     \{\par
00044         NoWorkerThread = 0,\par
00048         WorkerThread = 1\par
00049 \par
00050     \}\par
00051 \par
00052 \par
00058     {\cf17 public} {\cf17 class }InsightProcess : NativeStaticContainer\par
00059     \{\par
00060 {\cf21         #region Forewords}\par
00061         {\cf20 /*}\par
00062 {\cf20          * This area contains routines that are probably duplicated else were; however, they exist to make getting starting easier}\par
00063 {\cf20          */}\par
00064 \par
00065 {\cf21         #endregion}\par
00071         {\cf17 public} InsightProcess(IntPtr That): base(That)\par
00072         \{\par
00073             {\cf19 if} (That == IntPtr.Zero)\par
00074             \{\par
00075                 {\cf20 //throw new ArgumentNullException(WrapperConstructorReceivedNullPointerErrorMsg("Argument", this.GetType().Name + ".CreateInstance", nameof(Native)));}\par
00076                 {\cf19 throw} WrapperConstructorReceivedNullPointerErrorException({\cf22 "Argument"}, GetType().Name + {\cf22 ".CreateInstance"}, nameof(Native));\par
00077             \}\par
00078         \}\par
00085         {\cf17 public} InsightProcess(IntPtr That, {\cf18 bool} FreeOnCleanup): base(That, FreeOnCleanup)\par
00086         \{\par
00087             {\cf19 if} (That == IntPtr.Zero)\par
00088             \{\par
00089                 {\cf20 //throw new ArgumentNullException(WrapperConstructorReceivedNullPointerErrorMsg("Argument", this.GetType().Name + ".CreateInstance", nameof(Native)));}\par
00090                 {\cf19 throw} WrapperConstructorReceivedNullPointerErrorException({\cf22 "Argument"}, GetType().Name + {\cf22 ".CreateInstance"}, nameof(Native));\par
00091             \}\par
00092         \}\par
00097         {\cf17 public} {\cf17 override} {\cf18 int} GetHashCode()\par
00098         \{\par
00099             {\cf19 return} Native.GetHashCode();\par
00100         \}\par
00110         {\cf17 public} delegate {\cf18 int} DebugEventCallBackRoutine(IntPtr DebugEvent, IntPtr ContinueState, IntPtr WaitTimer, IntPtr CustomArg);\par
00111 \par
00115         [Obsolete({\cf22 "Not supported anymore"})]\par
00116         {\cf17 public} {\cf17 enum} ProcessRestriction : uint\par
00117         \{\par
00121             DropFileReadRequests = 1,\par
00125             PositiveDenyFileReadRequests = 2,\par
00129             NegativeDenyFileReadRequest = 3,\par
00130 \par
00134             DropFileWriteRequests = 4,\par
00138             PositiveDenyFileWriteRequest = 5,\par
00142             NegativeDenyFileWriteRequests = 6,\par
00143 \par
00144 \par
00148             NegativeDenyProcessSpawn = 7,\par
00149 \par
00153             CommandProcessProperate = 8,\par
00154 \par
00155 \par
00159             CommadMaxValue = 255\par
00160         \}\par
00161 \par
00162 \par
00163 \par
00169         DebugEventCallBackRoutine BackUpCopy;\par
00173         [Flags]\par
00174         {\cf17 public} {\cf17 enum} SpecialCaseFlags\par
00175         \{\par
00179             None = 0,\par
00183             DebugOnlyThis = 1,\par
00187             DebugChild = 2,\par
00191             CreateSuspended = 4,\par
00192         \}\par
00193 \par
00199         {\cf17 public} {\cf17 static} InsightProcess CreateInstance()\par
00200         \{\par
00201             IntPtr ret = InsightProcessInternal.CreateInsightProcessNativeClass();\par
00202             {\cf19 if} (ret == IntPtr.Zero)\par
00203             \{\par
00204                 {\cf19 throw} {\cf17 new} InvalidOperationException({\cf22 "Native DLL InsightApi Failed to instance a copy of its InsightProcess class via the exported routine"});\par
00205             \}\par
00206             {\cf19 else}\par
00207             \{\par
00208                 {\cf19 return} {\cf17 new} InsightProcess(ret);\par
00209             \}\par
00210         \}\par
00211 \par
00212 \par
00213 {\cf21         #region Exported Routines}\par
00218         {\cf17 public} {\cf18 int} SpawnProcess()\par
00219         \{\par
00220             {\cf19 if} (ExtraFlags != SpecialCaseFlags.None)\par
00221             \{\par
00222                 {\cf20 // the code that applies the special case flags as in the get property code for CreationFlags.}\par
00223 \par
00224                 uint flags = CreationFlags;\par
00225                 CreationFlags = flags;\par
00226             \}\par
00227             {\cf19 return} InsightProcessInternal.InsightProcess_Spawn(Native).ToInt32();\par
00228         \}\par
00229 \par
00234         {\cf17 public} {\cf18 void} PulseDebugEventThead()\par
00235         \{\par
00236             InsightProcessInternal.InsightProcess_PulseDebugEvent(Native);\par
00237         \}\par
00238 \par
00239 \par
00244         {\cf17 public} InsightHunter GetSymbolHandler()\par
00245         \{\par
00246             IntPtr ret = InsightProcessInternal.InsightProcess_GetSymbolEngineClassPtr(Native);\par
00247             {\cf19 if} (ret != IntPtr.Zero)\par
00248             \{\par
00249                 {\cf19 return} {\cf17 new} InsightHunter(ret, {\cf17 false});\par
00250             \}\par
00251             {\cf19 return} {\cf17 null};\par
00252         \}\par
00253 \par
00259         {\cf17 public} {\cf18 bool} UpdateSymbolEngine(IntPtr DebugEnvent)\par
00260         \{\par
00261          \par
00262 \par
00263             {\cf19 throw} {\cf17 new} NotImplementedException(nameof(UpdateSymbolEngine) + {\cf22 " is not implemented in PSProcessInformation.cs, the native version at PS_ProcessInformation.cpp AND the C linking code at PS_ProcessInformation.CCall.cpp.  You'll need to add code at all three spots. "});\par
00264 \par
00265         \}\par
00266 \par
00267 {\cf21         #endregion}\par
00268 \par
00269 {\cf21         #region Multi Process info}\par
00274    \par
00279       \par
00280 \par
00281 {\cf21         #endregion}\par
00282 \par
00283 {\cf21         #region Process Statistics}\par
00284 \par
00285 {\cf21         #endregion}\par
00286 {\cf21         #region Member Access }\par
00287 \par
00288 \par
00289 \par
00293         {\cf17 public} DebugModeType DebugMode\par
00294         \{\par
00295             {\cf17 get}\par
00296             \{\par
00297                 {\cf19 return} InsightProcessInternal.InsightProcess_GetDebugMode(Native);\par
00298             \}\par
00299             {\cf17 set}\par
00300             \{\par
00301                 InsightProcessInternal.InsightProcess_SetDebugMode(Native, value);\par
00302             \}\par
00303         \}\par
00304 \par
00308         {\cf17 public} {\cf18 bool} RequestDebugPriv\par
00309         \{\par
00310             {\cf17 set}\par
00311             \{\par
00312                 InsightProcessInternal.InsightProcess_RequestDebugPriv(Native, value);\par
00313             \}\par
00314             {\cf17 get}\par
00315             \{\par
00316                 {\cf18 bool} tmp = InsightProcessInternal.InsightProcess_RequestDebugPriv(Native, {\cf17 false});\par
00317                 {\cf19 if} (tmp != {\cf17 false})\par
00318                 \{\par
00319                     InsightProcessInternal.InsightProcess_RequestDebugPriv(Native, tmp);\par
00320                 \}\par
00321                 {\cf19 return} tmp;\par
00322             \}\par
00323         \}\par
00324 \par
00325 \par
00330         {\cf17 public} DebugEventCallBackRoutine UserDebugCallRoutine\par
00331         \{\par
00332             {\cf17 get}\par
00333             \{\par
00334                 {\cf19 return} (DebugEventCallBackRoutine)InsightProcessInternal.InsightProcess_GetDebugCallbackRoutine(Native);\par
00335             \}\par
00336             {\cf17 set}\par
00337             \{\par
00338                 InsightProcessInternal.InsightProcess_SetDebugCallbackRoutine(Native, value);\par
00339                 BackUpCopy = value;\par
00340             \}\par
00341         \}\par
00342 \par
00343    \par
00344 \par
00345 \par
00346 \par
00350         {\cf17 public} {\cf18 string}[] DetourList\par
00351         \{\par
00352             {\cf17 get}\par
00353             \{\par
00354                 ulong size = InsightProcessInternal.InsightProcess_GetDetourListSize(Native);\par
00355                 {\cf19 if} (size == 0)\par
00356                 \{\par
00357                     {\cf19 return} {\cf17 null};\par
00358                 \}\par
00359                 {\cf19 else}\par
00360                 \{\par
00361                     List<string> ret = {\cf17 new} List<string>();\par
00362                     {\cf19 for} (uint step = 0; step < size; step++)\par
00363                     \{\par
00364                         IntPtr ListPtrEntry = (IntPtr)InsightProcessInternal.PSProcessInformation_GetDetourListIndex(Native, step);\par
00365                         ret.Add(Marshal.PtrToStringAnsi(ListPtrEntry));\par
00366                     \}\par
00367                     {\cf19 return} ret.ToArray();\par
00368                 \}\par
00369             \}\par
00370         \}\par
00371 \par
00372 \par
00373 \par
00377         {\cf17 public} {\cf18 string} ProcessName\par
00378         \{\par
00379             {\cf17 get}\par
00380             \{\par
00381                 {\cf19 return} Marshal.PtrToStringUni(InsightProcessInternal.InsightProcess_GetProcessName(Native));\par
00382             \}\par
00383             {\cf17 set}\par
00384             \{\par
00385                 InsightProcessInternal.InsightProcess_SetProcessName(Native, value);\par
00386             \}\par
00387         \}\par
00388 \par
00392         {\cf17 public} {\cf18 string} ProcessArguments\par
00393         \{\par
00394             {\cf17 get}\par
00395             \{\par
00396                 {\cf19 return} Marshal.PtrToStringUni(InsightProcessInternal.InsightProcess_GetProcessArgument(Native));\par
00397             \}\par
00398             {\cf17 set}\par
00399             \{\par
00400                 InsightProcessInternal.InsightProcess_SetProcessArgument(Native, value);\par
00401             \}\par
00402         \}\par
00403 \par
00407         {\cf17 public} {\cf18 string} WorkingDirectory\par
00408         \{\par
00409             {\cf17 get}\par
00410             \{\par
00411                 {\cf19 return} Marshal.PtrToStringUni(InsightProcessInternal.PsProcessInformation_GetWorkingDirectory(Native));\par
00412             \}\par
00413             {\cf17 set}\par
00414             \{\par
00415                 InsightProcessInternal.InsightProcess_SetWorkingDirectory(Native, value);\par
00416             \}\par
00417         \}\par
00418 \par
00419 \par
00423         {\cf17 public} {\cf18 bool} DetourMustSucceed\par
00424         \{\par
00425             {\cf17 get}\par
00426             \{\par
00427                 {\cf19 return} {\cf17 false};\par
00428             \}\par
00429             {\cf17 set}\par
00430             \{\par
00431 \par
00432             \}\par
00433         \}\par
00434 \par
00438         {\cf17 public} {\cf18 bool} InheritDefaultEnviroment\par
00439         \{\par
00440             {\cf17 set}\par
00441             \{\par
00442                 InsightProcessInternal.InsightProcess_SetInheritDefaultEnviroment(Native, value);\par
00443             \}\par
00444         \}\par
00445 \par
00449         {\cf17 public} {\cf18 bool} EnableSymbolEngine\par
00450         \{\par
00451             {\cf17 get}\par
00452             \{\par
00453                 {\cf19 return} InsightProcessInternal.InsightProcess_GetSymbolHandling(Native);\par
00454             \}\par
00455             {\cf17 set}\par
00456             \{\par
00457                 InsightProcessInternal.InsightProcess_SetSymbolHandling(Native, value);\par
00458             \}\par
00459         \}\par
00460 \par
00461 \par
00462 \par
00466         {\cf17 public} uint CreationFlags\par
00467         \{\par
00468             {\cf17 get}\par
00469             \{\par
00470                 uint Val = InsightProcessInternal.InsightProcess_GetCreationFlags(Native);\par
00471                 {\cf19 return} Val;\par
00472             \}\par
00473             {\cf17 set}\par
00474             \{\par
00475                 uint Val = value;\par
00476                 \par
00477                 {\cf19 if} (ExtraFlags != SpecialCaseFlags.None)\par
00478                 \{\par
00479                     {\cf19 if} (ExtraFlags.HasFlag(SpecialCaseFlags.DebugOnlyThis))\par
00480                     \{\par
00481                         {\cf20 // DEBUG_PROCESS ONLY}\par
00482                         Val |= 1;\par
00483                     \}\par
00484                     {\cf19 else}\par
00485                     \{\par
00486                         {\cf19 if} (ExtraFlags.HasFlag(SpecialCaseFlags.DebugChild))\par
00487                         \{\par
00488                             {\cf20 //  DEBUG THIS PROCESS and kids.}\par
00489                             Val |= 2;\par
00490                         \}\par
00491                     \}\par
00492 \par
00493                     {\cf19 if} (ExtraFlags.HasFlag(SpecialCaseFlags.CreateSuspended))\par
00494                     \{\par
00496                         Val |= 4;\par
00497                     \}\par
00498                 \}\par
00499                 InsightProcessInternal.InsightProcess_SetCreationFlags(Native, Val);\par
00500             \}\par
00501         \}\par
00502 \par
00507         {\cf17 public} SpecialCaseFlags ExtraFlags\par
00508         \{\par
00509             {\cf17 get}\par
00510             \{\par
00511                 uint Flags = CreationFlags;\par
00512                 {\cf19 return} _ContainerFlag;\par
00513             \}\par
00514             {\cf17 set}\par
00515             \{\par
00516                 _ContainerFlag = value;\par
00517                 uint Flags = CreationFlags;\par
00518             \}\par
00519         \}\par
00520         {\cf17 private} SpecialCaseFlags _ContainerFlag;\par
00521 \par
00522 \par
00528         {\cf17 public} {\cf18 void} SetExplicitEnviromentValue({\cf18 string} Name, {\cf18 string} Value)\par
00529         \{\par
00530             InsightProcessInternal.InsightProcess_SetExplicitEnviromentValue(Native, Name, Value);\par
00531         \}\par
00532 \par
00538         {\cf17 public} {\cf18 string} GetExplicitEnviromentValue({\cf18 string} Name)\par
00539         \{\par
00540             {\cf19 return} Marshal.PtrToStringUni(InsightProcessInternal.InsightProcess_GetExplicitEnviromentValue(Native, Name));\par
00541         \}\par
00542 \par
00548         {\cf17 public} StartupInfoExW GetStartupInfoClass()\par
00549         \{\par
00550             {\cf20 /* MEMORY MANAGEMENT IMPORTANCE***** }\par
00551 {\cf20              * Should the Native implementation for InsightProcess's instance of StartupInfo change to}\par
00552 {\cf20              * be allocated on demand, }\par
00553 {\cf20              * the false in this statement will need to be changed to true*/}\par
00554             {\cf19 return} {\cf17 new} StartupInfoExW(InsightProcessInternal.InsightProcess_GetStartupInfoClass(Native), {\cf17 false});\par
00555         \}\par
00556 \par
00563         {\cf17 public} {\cf18 void} AddDetoursDll({\cf18 string} NewDllToForceLoad)\par
00564         \{\par
00565             InsightProcessInternal.PsProcessInformation_AddDetourDllToLoad(Native, NewDllToForceLoad);\par
00566         \}\par
00567 \par
00571         {\cf17 public} {\cf18 void} ResetDetoursDllList()\par
00572         \{\par
00573             InsightProcessInternal.InsightProcess_ClearDetourList(Native);\par
00574         \}\par
00575 \par
00576 \par
00581         {\cf17 public} {\cf18 bool} HelperDll_AddLoadLibraryPath({\cf18 string} NewLocation)\par
00582         \{\par
00583             {\cf19 return} InsightProcessInternal.InsightProcess_AddPriorityLoadLibraryPath(Native, NewLocation);\par
00584         \}\par
00585 \par
00589         {\cf17 public} {\cf18 void} HelperDll_ClearLoadLibraryPath()\par
00590         \{\par
00591             InsightProcessInternal.InsightProcess_ClearPriorityDllPath(Native);\par
00592         \}\par
00593 \par
00599         {\cf17 public} uint HelperDll_GetLoadLibraryPathCount()\par
00600         \{\par
00601             {\cf19 return} InsightProcessInternal.InsightProcess_GetProrityLoadLibraryPath_NumberOf(Native);\par
00602         \}\par
00603 \par
00609         {\cf17 public} {\cf18 string} HelperDll_IndexLoadLibraryPath({\cf18 int} index)\par
00610         \{\par
00611             IntPtr ret = InsightProcessInternal.InsightProcess_IndexPriorityDllPath(Native, index);\par
00612             {\cf19 if} (ret != IntPtr.Zero)\par
00613             \{\par
00614                 {\cf19 return} Marshal.PtrToStringUni(ret);\par
00615             \}\par
00616             {\cf19 return} {\cf17 null};\par
00617             \par
00618         \}\par
00619 \par
00620 \par
00621 \par
00622 {\cf21         #endregion}\par
00623 {\cf21         #region Getting Memory information about your main running process}\par
00627         {\cf17 public} ProcessMemoryCount32? GetMemoryStatsBulk\par
00628         \{\par
00629             {\cf17 get}\par
00630             \{\par
00631                 IntPtr ret = InsightProcessInternal.InsightProcess_GetMemoryStatsBulkPtr(Native);\par
00632                 {\cf19 if} (ret != IntPtr.Zero)\par
00633                 \{\par
00634                     {\cf19 return} Marshal.PtrToStructure<ProcessMemoryCount32>(ret);\par
00635                 \}\par
00636                 {\cf19 return} {\cf17 null};\par
00637             \}\par
00638         \}\par
00643         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00644         {\cf17 public} ulong PageFaultCount\par
00645         \{\par
00646             {\cf17 get}\par
00647             \{\par
00648                 {\cf19 return} InsightProcessInternal.InsightProcess_GetPageFaultCount(Native);\par
00649             \}\par
00650         \}\par
00655         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00656         {\cf17 public} ulong PeakWorkingSet\par
00657         \{\par
00658             {\cf17 get}\par
00659             \{\par
00660                 {\cf19 return} InsightProcessInternal.InsightProcess_GetPeakWorkingSet(Native);\par
00661             \}\par
00662         \}\par
00667         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00668         {\cf17 public} ulong WorkingSet\par
00669         \{\par
00670             {\cf17 get}\par
00671             \{\par
00672                 {\cf19 return} InsightProcessInternal.InsightProcess_GetWorkingSetSize(Native);\par
00673             \}\par
00674         \}\par
00679         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00680         {\cf17 public} ulong QuotaPeakPagePoolUsage\par
00681         \{\par
00682             {\cf17 get}\par
00683             \{\par
00684                 {\cf19 return} InsightProcessInternal.InsightProcess_GetQuotaPeakPagePoolUsage(Native);\par
00685             \}\par
00686         \}\par
00687 \par
00692         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00693         {\cf17 public} ulong QuotaPagePoolUsage\par
00694         \{\par
00695             {\cf17 get}\par
00696             \{\par
00697                 {\cf19 return} InsightProcessInternal.InsightProcess_GetQuotaPagePoolUsage(Native);\par
00698             \}\par
00699         \}\par
00700 \par
00705         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00706         {\cf17 public} ulong QuotaPeakNonPagePoolUsage\par
00707         \{\par
00708             {\cf17 get}\par
00709             \{\par
00710                 {\cf19 return} InsightProcessInternal.InsightProcess_GetQuotaPeakNonPagePoolUsage(Native);\par
00711             \}\par
00712         \}\par
00717         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00718         {\cf17 public} ulong QuotaNonPagePoolUsage\par
00719         \{\par
00720             {\cf17 get}\par
00721             \{\par
00722                 {\cf19 return} InsightProcessInternal.InsightProcess_GetQuotaPeakNonPagePoolUsage(Native);\par
00723             \}\par
00724         \}\par
00728         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00729         {\cf17 public} ulong PageFileUsage\par
00730         \{\par
00731             {\cf17 get}\par
00732             \{\par
00733                 {\cf19 return} InsightProcessInternal.InsightProcess_GetPageFileUsage(Native);\par
00734             \}\par
00735         \}\par
00736 \par
00741         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00742         {\cf17 public} ulong PeakPageFileUsage\par
00743         \{\par
00744             {\cf17 get}\par
00745             \{\par
00746                 {\cf19 return} InsightProcessInternal.InsightProcess_GetPeakPageFileUsage(Native);\par
00747             \}\par
00748         \}\par
00753         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00754         {\cf17 public} ulong PrivateUsage\par
00755         \{\par
00756             {\cf17 get}\par
00757             \{\par
00758                 {\cf19 return} InsightProcessInternal.InsightProcess_GetPrivateUsage(Native);\par
00759             \}\par
00760         \}\par
00761 \par
00762 \par
00763 \par
00764 \par
00765 \par
00766 {\cf21         #endregion}\par
00767 {\cf21         #region Deconstructors / Cleanup}\par
00768 \par
00769         ~InsightProcess()\par
00770         \{\par
00771             Dispose({\cf17 false});\par
00772         \}\par
00773 \par
00774         \par
00775 \par
00776         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} Managed)\par
00777         \{\par
00778             {\cf19 if} (IsCleanned)\par
00779             \{\par
00780                 {\cf19 throw} {\cf17 new} ObjectDisposedException(nameof(InsightProcess));\par
00781             \}\par
00782             {\cf19 if} (Managed)\par
00783             \{\par
00784 \par
00785             \}\par
00786             {\cf19 if} (Native != IntPtr.Zero)\par
00787             \{\par
00788                 InsightProcessInternal.InsightProcess_KillInstance(Native);\par
00789             \}\par
00790             IsCleanned = {\cf17 true};\par
00791         \}\par
00792 \par
00798         {\cf17 public} {\cf17 static} {\cf18 void} SetDebugEventCallbackResponse(IntPtr contStat, DebugContState Response)\par
00799         \{\par
00800             MemoryNative.SetDebugEventCallbackResponse(contStat, Response);\par
00801         \}\par
00802 \par
00806         {\cf18 bool} IsCleanned = {\cf17 false};\par
00807 {\cf21         #endregion}\par
00808     \}\par
00809 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Process/ProcessMemoryCount_x64.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/ProcessMemoryCount_x64.cs}
{\xe \v Debugging/Process/ProcessMemoryCount_x64.cs}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.Process.ProcessMemoryCount64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 64-bit process }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Process}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ProcessMemoryCount_x64.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/ProcessMemoryCount_x64.cs}
{\xe \v Debugging/Process/ProcessMemoryCount_x64.cs}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Debugging.Process\par
00009 \{\par
00013     [StructLayout(LayoutKind.Sequential, Pack = 4)]\par
00014     {\cf17 public} {\cf17 struct }ProcessMemoryCount64\par
00015     \{\par
00019         {\cf17 public} ulong cb;\par
00023         {\cf17 public} ulong PageFaultCount;\par
00027         {\cf17 public} ulong PeakWorkingSetSize;\par
00031         {\cf17 public} ulong WorkingSetSize;\par
00035         {\cf17 public} ulong QuotaPeakedPagedPoolUsage;\par
00039         {\cf17 public} ulong QuotaPagedPoolUsage;\par
00043         {\cf17 public} ulong QuotaPeakedNonPagePoolUsage;\par
00047         {\cf17 public} ulong QuotaNonPagePoolUsage;\par
00051         {\cf17 public} ulong PageFileUsage;\par
00055         {\cf17 public} ulong PeakPageFileUsaged;\par
00059         {\cf17 public} ulong PrivateUsage;\par
00060     \}\par
00061 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Process/ProcessMemoryCount_x86.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/ProcessMemoryCount_x86.cs}
{\xe \v Debugging/Process/ProcessMemoryCount_x86.cs}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.Process.ProcessMemoryCount32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Process} Memory count for 32-bit process }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Process}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ProcessMemoryCount_x86.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/ProcessMemoryCount_x86.cs}
{\xe \v Debugging/Process/ProcessMemoryCount_x86.cs}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Debugging.Process\par
00009 \{\par
00013     [StructLayout(LayoutKind.Sequential, Pack = 4)]\par
00014     {\cf17 public} {\cf17 struct }ProcessMemoryCount32\par
00015     \{\par
00019         {\cf17 public} uint cb;\par
00023         {\cf17 public} uint PageFaultCount;\par
00027         {\cf17 public} uint PeakWorkingSetSize;\par
00031         {\cf17 public} uint WorkingSetSize;\par
00035         {\cf17 public} uint QuotaPeakedPagedPoolUsage;\par
00039         {\cf17 public} uint QuotaPagedPoolUsage;\par
00043         {\cf17 public} uint QuotaPeakedNonPagePoolUsage;\par
00047         {\cf17 public} uint QuotaNonPagePoolUsage;\par
00051         {\cf17 public} uint PageFileUsage;\par
00055         {\cf17 public} uint PeakPageFileUsaged;\par
00059         {\cf17 public} uint PrivateUsage;\par
00060     \}\par
00061 \par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Process/PSAPI_WORKING_SET_INFORMATION.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/PSAPI_WORKING_SET_INFORMATION.cs}
{\xe \v Debugging/Process/PSAPI_WORKING_SET_INFORMATION.cs}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_INFORMATION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.Process.PSAPI_WORKING_SET_EX_BLOCK}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block} }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Process}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PSAPI_WORKING_SET_INFORMATION.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/PSAPI_WORKING_SET_INFORMATION.cs}
{\xe \v Debugging/Process/PSAPI_WORKING_SET_INFORMATION.cs}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 \par
00007 {\cf17 namespace }InsightSheath.Debugging.Process\par
00008 \{\par
00009     {\cf20 // https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information}\par
00010     {\cf17 class }PSAPI_WORKING_SET_EX_INFORMATION\par
00011     \{\par
00012     \}\par
00013 \par
00017     {\cf17 struct }PSAPI_WORKING_SET_EX_BLOCK\par
00018     \{\par
00019     \}\par
00020 \par
00021 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Process/QueryWorkingStructs.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/QueryWorkingStructs.cs}
{\xe \v Debugging/Process/QueryWorkingStructs.cs}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.Process.QueryWorkingStructs}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Process}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QueryWorkingStructs.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Process/QueryWorkingStructs.cs}
{\xe \v Debugging/Process/QueryWorkingStructs.cs}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 \par
00007 {\cf17 namespace }InsightSheath.Debugging.Process\par
00008 \{\par
00009     {\cf17 class }QueryWorkingStructs\par
00010     \{\par
00011     \}\par
00012 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/SymbolEngine/DebugHelp_ApiVersionStruct.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/DebugHelp_ApiVersionStruct.cs}
{\xe \v Debugging/SymbolEngine/DebugHelp_ApiVersionStruct.cs}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.SymbolEngine.API_VERSION}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b API_VERSION} struct for DebugHelp symbol library. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.SymbolEngine.DebugHelp_ApiVersionStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} for Api Version struture. Note: Impementation in Insight has the struct as part of it, you DON'T want to free any pointer to it you get from insite. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.SymbolEngine}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DebugHelp_ApiVersionStruct.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/DebugHelp_ApiVersionStruct.cs}
{\xe \v Debugging/SymbolEngine/DebugHelp_ApiVersionStruct.cs}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.Abstract;\par
00008 {\cf17 using }InsightSheath.NativeImports;\par
00009 {\cf17 using }InsightSheath.Wrappers;\par
00010 {\cf17 namespace }InsightSheath.Debugging.SymbolEngine\par
00011 \{\par
00012 \par
00016     [StructLayout(LayoutKind.Sequential, Pack = 4)]\par
00017     {\cf17 public} {\cf17 struct }API_VERSION\par
00018     \{\par
00022         {\cf17 public} ushort MajorVersion;\par
00026         {\cf17 public} ushort MinorVersion;\par
00030         {\cf17 public} ushort Revision;\par
00034         {\cf17 public} ushort Reserved;\par
00035     \}\par
00036 \par
00040     {\cf17 public} {\cf17 class }DebugHelp_ApiVersionStruct : NativeStaticContainer\par
00041     \{\par
00046         {\cf17 public} DebugHelp_ApiVersionStruct(IntPtr Native) : base(Native)\par
00047         \{\par
00048 \par
00049         \}\par
00050 \par
00056         {\cf17 public} DebugHelp_ApiVersionStruct(IntPtr Native, {\cf18 bool} FreeOnClean) : base(Native, false)\par
00057         \{\par
00058 \par
00059         \}\par
00060 \par
00064         {\cf17 public} ushort Revision\par
00065         \{\par
00066             {\cf17 get}\par
00067             \{\par
00068                 {\cf19 return} DebugHelpApiVersionStructInternal.DebugHelp_ApiVerion_GetRevision(Native);\par
00069             \}\par
00070         \}\par
00074         {\cf17 public} ushort Major\par
00075         \{\par
00076             {\cf17 get}\par
00077             \{\par
00078                 {\cf19 return} DebugHelpApiVersionStructInternal.DebugHelp_ApiVerion_GetMajor(Native);\par
00079             \}\par
00080         \}\par
00081 \par
00085         {\cf17 public} ushort Minor\par
00086         \{\par
00087             {\cf17 get}\par
00088             \{\par
00089                 {\cf19 return} DebugHelpApiVersionStructInternal.DebugHelp_ApiVerion_GetMinor(Native);\par
00090             \}\par
00091         \}\par
00092 \par
00093 \par
00094     \}\par
00095 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/SymbolEngine/InsightHunter.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/InsightHunter.cs}
{\xe \v Debugging/SymbolEngine/InsightHunter.cs}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.SymbolEngine.InsightHunter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A part of the symbol engine exported in InsightAPI in the Native DLL. This class is VERY VERY VERY tightly coupled with the InsightProcess class but distinct enough to warrent its own class/wrapper wrappers. If you need not have symbol processing, disabling InsightProcess.EnableSymbolEngine is set to false if fine. That turns off the code that updates the native {\b InsightHunter} class when the worker thread receives a debug event NOTE: You'll need to spawn at least one process with InsightProcess to get much use out of this. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.SymbolEngine}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate bool {\b InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSearchCallBackRoutine} (IntPtr SymbolInfo)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the callback for {\b InsightHunter.EnumerateSymbols(string, InsightHunter_SymbolSearchCallBackRoutine)}. The passed pointer to your routine is a native pointer to a struct {\b SymbolInfo}'s that exists for while your routine is active. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
delegate bool {\b InsightSheath.Debugging.SymbolEngine.InsightHunter_SymbolSourceCallbackRoutine} (IntPtr SourceInfo)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback for Enumerating source files. Return true to continue and false to quit. }{
}\par
}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightHunter.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/InsightHunter.cs}
{\xe \v Debugging/SymbolEngine/InsightHunter.cs}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Abstract;\par
00002 {\cf17 using }InsightSheath.Debugging;\par
00003 {\cf17 using }InsightSheath.Win32Struct;\par
00004 {\cf17 using }System;\par
00005 {\cf17 using }System.Runtime.InteropServices;\par
00006 {\cf17 using }InsightSheath.Debugging.Process;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Debugging.SymbolEngine\par
00009 \{\par
00017     {\cf17 public} delegate {\cf18 bool} InsightHunter_SymbolSearchCallBackRoutine(IntPtr SymbolInfo);\par
00018 \par
00020     {\cf20 //typedef BOOL(WINAPI* SymbolSourceCallBack)(PSOURCEFILEW);}\par
00021     {\cf17 public} delegate {\cf18 bool} InsightHunter_SymbolSourceCallbackRoutine(IntPtr SourceInfo);\par
00022 \par
00023 \par
00030     {\cf17 public} {\cf17 class }InsightHunter : NativeStaticContainer\par
00031     \{\par
00035         [Flags]\par
00036         {\cf17 public} {\cf17 enum} SymbolOptionsFlags : uint\par
00037         \{\par
00038             AllowAbsoluteSymbols = 0x00000800,\par
00039             AllowZeroAddress = 0x01000000,\par
00040             AutoPublics = 0x00010000,\par
00041             CaseInsentive = 0x00000001,\par
00042             DebugMode = 0x80000000,\par
00043             DeferredLoad = 0x00000004,\par
00044             DisableSymServerAutoDetect = 0x02000000,\par
00045             ExactSymbolRequired = 0x02000000,\par
00046             FailCriticalErrors = 0x00000200,\par
00047             FavorCompressed = 0x00800000,\par
00048             FlatDirectory = 0x00400000,\par
00049             IgnoreCodeViewRecord = 0x00000080,\par
00050             IgnoreImageDir = 0x00200000,\par
00051             IgnoreNtSymPath = 0x00001000,\par
00052             Include32BitModules = 0x00002000,\par
00053             LoadAnything = 0x00000040,\par
00054             LoadLines = 0x00000010,\par
00055             SYMOPT_NO_CPP = 0x00000008,\par
00056             NoImageSearch = 0x00020000,\par
00057             NoPrompts = 0x00080000,\par
00058             NoPublics = 0x00008000,\par
00059             NoUnqualifiedLoads = 0x00000100,\par
00060             Overwrite = 0x00100000,\par
00061             PublicsOnly = 0x00004000,\par
00065             SecureMode = 0x00040000,\par
00066             UndecorateSymbols = 0x00000002\par
00067         \}\par
00068 \par
00069         {\cf17 public} InsightHunter(IntPtr That) : base(That)\par
00070         \{\par
00071             SyncAccess = {\cf17 true};\par
00072         \}\par
00073 \par
00074         {\cf17 public} InsightHunter(IntPtr That, {\cf18 bool} FreeOnDispose) : base(That, FreeOnDispose)\par
00075         \{\par
00076             SyncAccess = {\cf17 true};\par
00077         \}\par
00078 \par
00079 {\cf21         #region public exported api}\par
00085         {\cf17 public} {\cf18 bool} LoadExeSymbolInfo(DebugEvent debugEvent)\par
00086         \{\par
00087             {\cf19 return} NativeImports.InsightHunterInternal.Insight_LoadExeSymbolInfo(Native, debugEvent.NativePointer);\par
00088         \}\par
00089 \par
00095         {\cf17 public} {\cf18 bool} LoadExeSymbolInfo(IntPtr DebugEvent)\par
00096         \{\par
00097 \par
00098             {\cf19 return} NativeImports.InsightHunterInternal.Insight_LoadExeSymbolInfo(Native, DebugEvent);\par
00099         \}\par
00100 \par
00101 \par
00107         {\cf17 public} {\cf18 bool} LoadDllSymbolInfo(DebugEvent DebugEvent)\par
00108         \{\par
00109             {\cf19 return} NativeImports.InsightHunterInternal.Insight_LoadDllSymbolInfo(Native, DebugEvent.NativePointer);\par
00110         \}\par
00111 \par
00112 \par
00113 \par
00119         {\cf17 public} {\cf18 bool} UnloadDllSymbolInfo(DebugEvent DebugEvent)\par
00120         \{\par
00121             {\cf19 return} NativeImports.InsightHunterInternal.Insight_UnLoadExeSymbolInfo(Native, DebugEvent.NativePointer);\par
00122         \}\par
00123 \par
00124         {\cf17 public} {\cf18 bool} UnloadDllSymbolInfo(IntPtr DebugEvent)\par
00125         \{\par
00126             {\cf19 return} NativeImports.InsightHunterInternal.Insight_UnLoadExeSymbolInfo(Native, DebugEvent);\par
00127         \}\par
00128 \par
00129 \par
00130 \par
00136         {\cf17 public} {\cf18 bool} SetParentWindow(IntPtr HWND)\par
00137         \{\par
00138             {\cf19 return} NativeImports.InsightHunterInternal.Insight_SetParentWindow(Native, HWND);\par
00139         \}\par
00140 \par
00141 \par
00148         {\cf17 public} {\cf18 bool} EnumerateSymbols({\cf18 string} SearchString, InsightHunter_SymbolSearchCallBackRoutine DotNetCallback)\par
00149         \{\par
00150             {\cf19 return} NativeImports.InsightHunterInternal.Insight_EnumerateLoadedSymbolsW(Native, SearchString, DotNetCallback);\par
00151         \}\par
00152 \par
00159         {\cf17 public} {\cf18 bool} EnumerateSourceFiles({\cf18 string} SearchString, InsightHunter_SymbolSourceCallbackRoutine DotNetCallBack)\par
00160         \{\par
00161             {\cf19 return} NativeImports.InsightHunterInternal.Insight_EnumerateSourceFilesW(Native, SearchString, DotNetCallBack);\par
00162         \}\par
00167         {\cf17 public} {\cf18 bool} RefreshModules()\par
00168         \{\par
00169             {\cf19 return} NativeImports.InsightHunterInternal.Insight_RefreshLoadedModules(Native);\par
00170         \}\par
00171 {\cf21         #endregion}\par
00172 \par
00173 {\cf21         #region Properties}\par
00177         {\cf17 public} {\cf18 bool} SyncAccess\par
00178         \{\par
00179             {\cf17 get}\par
00180             \{\par
00181                 {\cf19 return} NativeImports.InsightHunterInternal.Insight_GetThreadSync(Native);\par
00182             \}\par
00183             {\cf17 set}\par
00184             \{\par
00185                 NativeImports.InsightHunterInternal.Insight_SetThreadSync(Native, value);\par
00186             \}\par
00187         \}\par
00188 \par
00192         {\cf17 public} SymbolOptionsFlags SymbolOptions\par
00193         \{\par
00194             {\cf17 get}\par
00195             \{\par
00196                 {\cf19 return} NativeImports.InsightHunterInternal.Insight_GetSymbolOptions(Native);\par
00197             \}\par
00198             {\cf17 set}\par
00199             \{\par
00200                 NativeImports.InsightHunterInternal.Insight_SetSymbolOptions(Native, value);\par
00201             \}\par
00202         \}\par
00203 \par
00207         {\cf17 public} DebugHelp_ApiVersionStruct DebugHelp_Version\par
00208         \{\par
00209             {\cf17 get}\par
00210             \{\par
00211                 {\cf19 return}  {\cf17 new} DebugHelp_ApiVersionStruct(NativeImports.InsightHunterInternal.Insight_GetImageHelpVersionData(Native));\par
00212             \}\par
00213             {\cf17 set}\par
00214             \{\par
00215                 NativeImports.InsightHunterInternal.Insight_SetImageHelpCompatability(value.NativePointer, value.Major, value.Minor, value.Revision);\par
00216             \}\par
00217         \}\par
00218 \par
00219         {\cf17 public} API_VERSION DebugHelp_Version2\par
00220         \{\par
00221             {\cf17 get}\par
00222             \{\par
00223                 {\cf19 return} Marshal.PtrToStructure<API_VERSION>( NativeImports.InsightHunterInternal.Insight_GetImageHelpVersionData(Native));\par
00224             \}\par
00225             {\cf17 set}\par
00226             \{\par
00227                 NativeImports.InsightHunterInternal.Insight_SetImageHelpCompatability(this.Native, value.MajorVersion, value.MinorVersion, value.Revision);\par
00228             \}\par
00229         \}\par
00230 {\cf21         #endregion}\par
00231     \}\par
00232 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/SymbolEngine/PSourceFileStruct.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/PSourceFileStruct.cs}
{\xe \v Debugging/SymbolEngine/PSourceFileStruct.cs}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.SymbolEngine.SourceFile}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.SymbolEngine}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PSourceFileStruct.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/PSourceFileStruct.cs}
{\xe \v Debugging/SymbolEngine/PSourceFileStruct.cs}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Debugging.SymbolEngine\par
00009 \{\par
00010     [StructLayout(LayoutKind.Sequential, Pack = 4)]\par
00011     {\cf17 public} {\cf17 struct }SourceFile\par
00012     \{\par
00016         {\cf17 public} ulong ModBase;\par
00020         [MarshalAs(UnmanagedType.LPWStr)]\par
00021         {\cf17 public} {\cf18 string} FileName;\par
00022     \}\par
00023 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/SymbolEngine/SymbolInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/SymbolInfo.cs}
{\xe \v Debugging/SymbolEngine/SymbolInfo.cs}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.SymbolEngine.SymbolInfo}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Wrappers} imported for dealing with SymbolInfoW Native structures. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.SymbolEngine}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.SymbolEngine.SymbolTagType} : uint \{ {\b InsightSheath.Debugging.SymbolEngine.Null} = 0
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Should be from the SymTagEnum at MSDN {\f2 https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/bkedss5f(v=vs.100)} }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Debugging.SymbolEngine.SymbolFlags} : uint \{ {\b InsightSheath.Debugging.SymbolEngine.ClrToken} = 0x00040000
, {\b InsightSheath.Debugging.SymbolEngine.Constant} = 0x00000100
, {\b InsightSheath.Debugging.SymbolEngine.Export} = 0x00000200
, {\b InsightSheath.Debugging.SymbolEngine.Forwarder} = 0x00000400
, {\b InsightSheath.Debugging.SymbolEngine.FrameRel} = 0x00000020
, {\b InsightSheath.Debugging.SymbolEngine.Function} = 0x00000800
, {\b InsightSheath.Debugging.SymbolEngine.IrlRel} = 0x00010000
, {\b InsightSheath.Debugging.SymbolEngine.Local} =0x00000080
, {\b InsightSheath.Debugging.SymbolEngine.Metadata} = 0x00020000
, {\b InsightSheath.Debugging.SymbolEngine.Parameter} = 0x00000040
, {\b InsightSheath.Debugging.SymbolEngine.Register} = 0x00000008
, {\b InsightSheath.Debugging.SymbolEngine.Regrel} = 0x00000010
, {\b InsightSheath.Debugging.SymbolEngine.Slot} = 0x00008000
, {\b InsightSheath.Debugging.SymbolEngine.Thunk} = 0x00002000
, {\b InsightSheath.Debugging.SymbolEngine.TlsRel} = 0x00004000
, {\b InsightSheath.Debugging.SymbolEngine.ValuePresent} = 0x00000001
, {\b InsightSheath.Debugging.SymbolEngine.Virtual} = 0x00001000
 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SymbolInfo.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/SymbolEngine/SymbolInfo.cs}
{\xe \v Debugging/SymbolEngine/SymbolInfo.cs}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }InsightSheath.NativeImports;\par
00007 {\cf17 using }System.Runtime.InteropServices;\par
00008 {\cf17 using }InsightSheath.Abstract;\par
00009 \par
00010 {\cf17 namespace }InsightSheath.Debugging.SymbolEngine\par
00011 \{\par
00015     {\cf17 public} {\cf17 enum} SymbolTagType: uint\par
00016     \{\par
00017        Null = 0\par
00018     \}\par
00019      [Flags]\par
00020     {\cf17 public} {\cf17 enum} SymbolFlags : uint \par
00021     \{\par
00025         ClrToken = 0x00040000,\par
00029         Constant = 0x00000100,\par
00033         Export = 0x00000200,\par
00037         Forwarder = 0x00000400,\par
00041         FrameRel = 0x00000020,\par
00045         Function = 0x00000800,\par
00049         IrlRel = 0x00010000,\par
00053         Local =0x00000080,\par
00057         Metadata = 0x00020000,\par
00061         Parameter = 0x00000040,\par
00065         Register = 0x00000008,\par
00069         Regrel = 0x00000010,\par
00073         Slot = 0x00008000,\par
00077         Thunk = 0x00002000,\par
00081         TlsRel = 0x00004000,\par
00085         ValuePresent = 0x00000001,\par
00089         Virtual = 0x00001000\par
00090 \par
00091     \}\par
00092 \par
00096     {\cf17 public} {\cf17 class }SymbolInfo : NativeStaticContainer\par
00097     \{\par
00098         {\cf17 public} SymbolInfo(IntPtr That) : base(That)\par
00099         \{\par
00100 \par
00101         \}\par
00102 \par
00103         {\cf17 public} SymbolInfo(IntPtr That, {\cf18 bool} FreeOnCleanup) : base(That, FreeOnCleanup)\par
00104         \{\par
00105 \par
00106         \}\par
00107 \par
00108 \par
00112         {\cf17 public} uint TypeDataIndex\par
00113         \{\par
00114             {\cf17 get}\par
00115             \{\par
00116                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetTypeIndex(Native);\par
00117             \}\par
00118         \}\par
00119 \par
00123         {\cf17 public} uint SymbolIndex\par
00124         \{\par
00125             {\cf17 get}\par
00126             \{\par
00127                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetIndex(Native);\par
00128             \}\par
00129         \}\par
00130 \par
00131 \par
00135         {\cf17 public} uint SymbolSize\par
00136         \{\par
00137             {\cf17 get}\par
00138             \{\par
00139                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetSymbolSize(Native);\par
00140             \}\par
00141         \}\par
00142 \par
00146         {\cf17 public} ulong BaseModuleAddress\par
00147         \{\par
00148             {\cf17 get}\par
00149             \{\par
00150                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetModuleBase(Native);\par
00151             \}\par
00152         \}\par
00153 \par
00157         {\cf17 public} SymbolFlags Flags\par
00158         \{\par
00159             {\cf17 get}\par
00160             \{\par
00161                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetFlags(Native);\par
00162             \}\par
00163         \}\par
00164 \par
00165         {\cf17 public} uint SymbolRegisterOrValue\par
00166         \{\par
00167             {\cf17 get}\par
00168             \{\par
00169                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetValOrReg(Native);\par
00170             \}\par
00171         \}\par
00172 \par
00173         {\cf17 public} uint SymbolRegister\par
00174         \{\par
00175             {\cf17 get}\par
00176             \{\par
00177                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetReg(Native);\par
00178             \}\par
00179         \}\par
00180 \par
00181 \par
00182         {\cf17 public} uint SymbolValue\par
00183         \{\par
00184             {\cf17 get}\par
00185             \{\par
00186                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetVal(Native);\par
00187             \}\par
00188         \}\par
00189 \par
00190 \par
00191         {\cf17 public} uint SymbolScope\par
00192         \{\par
00193             {\cf17 get}\par
00194             \{\par
00195                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetScope(Native);\par
00196             \}\par
00197         \}\par
00198 \par
00199 \par
00200         {\cf17 public} SymbolTagType SymbolTagType\par
00201         \{\par
00202             {\cf17 get}\par
00203             \{\par
00204                 {\cf19 return} SymbolInfoInternal.SymbolInfo_GetTagType(Native);\par
00205             \}\par
00206         \}\par
00207 \par
00208         {\cf17 public} {\cf18 string} SymbolName\par
00209         \{\par
00210             {\cf17 get}\par
00211             \{\par
00212                 {\cf19 return} Marshal.PtrToStringUni(SymbolInfoInternal.SymbolInfo_GetName(Native));\par
00213             \}\par
00214         \}\par
00215 \par
00216     \}\par
00217 \par
00218 \par
00219     \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Thread/ThreadContext.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Thread/ThreadContext.cs}
{\xe \v Debugging/Thread/ThreadContext.cs}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.Thread.ThreadContext}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ThreadContext} is a class indented for reading/writing information about threads receives in the main InsightProcess structure We duplicate some of the functionality of the ProcessThread class for C# user familiarity. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Thread}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ThreadContext.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Thread/ThreadContext.cs}
{\xe \v Debugging/Thread/ThreadContext.cs}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Abstract;\par
00002 {\cf17 using }InsightSheath.Debugging.Process;\par
00003 {\cf17 using }InsightSheath.NativeImports;\par
00004 {\cf17 using }System;\par
00005 {\cf17 using }System.Collections.Generic;\par
00006 {\cf17 using }System.Diagnostics;\par
00007 {\cf17 using }System.Linq;\par
00008 {\cf17 using }System.Runtime.InteropServices.ComTypes;\par
00009 {\cf17 using }System.Text;\par
00010 {\cf17 using }System.Threading.Tasks;\par
00011 \par
00012 {\cf17 namespace }InsightSheath.Debugging.Thread\par
00013 \{\par
00014 \par
00015     \par
00020     {\cf17 public} {\cf17 class }ThreadContext : NativeStaticContainer\par
00021     \{\par
00022 \par
00023 \par
00028         {\cf17 public} {\cf17 static} ThreadContext CreateInstance(uint threadId)\par
00029         \{\par
00030             {\cf19 return} {\cf17 new} ThreadContext(ThreadContextInternal.ThreadContext_CreateInstance(threadId, 1));\par
00031         \}\par
00032 \par
00037         {\cf17 public} {\cf17 static} ThreadContext CreateInstance(IntPtr ThreadHandle)\par
00038         \{\par
00039             {\cf19 return} {\cf17 new} ThreadContext(ThreadContextInternal.ThreadContext_CreateInstance((ulong)ThreadHandle.ToInt64(), 0));\par
00040         \}\par
00041 \par
00046         {\cf17 public} ThreadContext(IntPtr Native) : base(Native)\par
00047         \{\par
00048             {\cf19 if} (NativePointer == IntPtr.Zero)\par
00049             \{\par
00050                 {\cf20 //throw new ArgumentNullException(WrapperConstructorReceivedNullPointerErrorMsg("Argument", "ThreadContext.CreateInstance", nameof(Native)));}\par
00051                 {\cf19 throw} WrapperConstructorReceivedNullPointerErrorException({\cf22 "Argument"}, GetType().Name + {\cf22 ".CreateInstance"}, nameof(Native));\par
00052             \}\par
00053             \par
00054         \}\par
00055 \par
00061 {\cf21 #pragma warning disable IDE0060 }{\cf20 // Remove unused parameter}\par
00062         {\cf17 public} ThreadContext(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, false)\par
00063 #pragma warning restore IDE0060 {\cf20 // Remove unused parameter}\par
00064         \{\par
00065             {\cf19 if} (NativePointer == IntPtr.Zero)\par
00066             \{\par
00067                 {\cf20 //throw new ArgumentNullException(WrapperConstructorReceivedNullPointerErrorMsg("Argument", "ThreadContext.CreateInstance", nameof(Native)));}\par
00068                 {\cf19 throw} WrapperConstructorReceivedNullPointerErrorException({\cf22 "Argument"}, GetType().Name + {\cf22 ".CreateInstance"}, nameof(Native));\par
00069             \}\par
00070         \}\par
00075         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00076         \{\par
00077             {\cf19 if} (disposing)\par
00078             \{\par
00079 \par
00080 \par
00081             \}\par
00082             {\cf19 if} (FreeOnCleanup)\par
00083             \{\par
00084                 ThreadContextInternal.ThreadContext_KillInstance(Native);\par
00085             \}\par
00086             ClearNative();\par
00087             base.Dispose(disposing);\par
00088         \}\par
00089 \par
00090 \par
00091 \par
00096         {\cf17 public} uint SuspendThread()\par
00097         \{\par
00098             {\cf19 return} ThreadContextInternal.ThreadContext_SuspendThread(Native);\par
00099         \}\par
00100 \par
00101 \par
00106         {\cf17 public} uint ResumeThread()\par
00107         \{\par
00108             {\cf19 return} ThreadContextInternal.ThreadContext_ResumeThread(Native);\par
00109         \}\par
00110 \par
00116         {\cf17 public} {\cf18 bool} SetTargetThread(IntPtr ThreadHandleNative)\par
00117         \{\par
00118             {\cf19 return} ThreadContextInternal.ThreadContext_SetTargetThread(Native, ThreadHandleNative, ThreadConext_Arguments.UseHandle);\par
00119         \}\par
00120 \par
00126         {\cf17 public} {\cf18 bool} SetTargetThread(uint ThreadId)\par
00127         \{\par
00128             {\cf19 return} ThreadContextInternal.ThreadContext_SetTargetThread(Native,  (IntPtr) ThreadId, ThreadConext_Arguments.UseThreadId);\par
00129         \}\par
00135         {\cf17 public} {\cf18 string} ThreadDescription\par
00136         \{\par
00137             {\cf17 get}\par
00138             \{\par
00139                 {\cf19 return} ThreadContextInternal.ThreadContext_GetThreadDescriptionW(Native);\par
00140             \}\par
00141             {\cf17 set}\par
00142             \{\par
00143                 ThreadContextInternal.ThreadContext_SetTheadDescriptionW(Native, value);\par
00144             \}\par
00145         \}\par
00146 \par
00147         \par
00151         {\cf17 public} uint ThreadId\par
00152         \{\par
00153             {\cf17 get}\par
00154             \{\par
00155                 {\cf19 return} ThreadContextInternal.ThreadContext_GetTargetThreadId(Native);\par
00156             \}\par
00157         \}\par
00158 \par
00162         {\cf17 public} {\cf18 int} IdealProcessor\par
00163         \{\par
00164             {\cf17 get}\par
00165             \{\par
00166                 {\cf19 return} ({\cf18 int})ThreadContextInternal.ThreadContext_GetIdealProcessor(Native);\par
00167             \}\par
00168             {\cf17 set}\par
00169             \{\par
00170                 _ = ThreadContextInternal.ThreadContext_SetIdealProcessor(Native, (uint)value);\par
00171             \}\par
00172         \}\par
00173     \par
00177         {\cf17 public} ThreadPriorityLevel ThreadPriority\par
00178         \{\par
00179             {\cf17 get}\par
00180             \{\par
00181                 {\cf19 return} (ThreadPriorityLevel)ThreadContextInternal.ThreadContext_GetPriority(Native);\par
00182             \}\par
00183             {\cf17 set}\par
00184             \{\par
00185                 ThreadContextInternal.ThreadContext_SetPriority(Native, ({\cf18 int})value);\par
00186             \}\par
00187         \}\par
00188 \par
00192         {\cf17 public} {\cf18 bool} PriorityBoost\par
00193         \{\par
00194             {\cf17 get}\par
00195             \{\par
00196                 {\cf19 return} ThreadContextInternal.ThreadContext_GetThreadPriorityBoostSetting(Native);\par
00197             \}\par
00198             {\cf17 set}\par
00199             \{\par
00200                 ThreadContextInternal.ThreadContext_SetThreadPriorityBoostSetting(Native, value);\par
00201             \}\par
00202         \par
00203         \}\par
00204 \par
00205 \par
00209 \par
00210         {\cf17 public} uint ProcessorAffinity\par
00211         \{\par
00212             {\cf17 get}\par
00213             \{\par
00214                 {\cf19 return} ThreadContextInternal.ThreadContext_GetThreadProcessAffinityMask(Native);\par
00215             \}\par
00216             {\cf17 set}\par
00217             \{\par
00218                 ThreadContextInternal.ThreadContext_SetThreadProcessAffinityMask(Native, value);\par
00219             \}\par
00220         \}\par
00221 \par
00225         {\cf17 public} IntPtr ThreadStartAddress\par
00226         \{\par
00227             {\cf17 get}\par
00228             \{\par
00229                 {\cf19 throw} {\cf17 new} NotImplementedException(nameof(ThreadStartAddress));\par
00230             \}\par
00231         \}\par
00232 \par
00233 \par
00237         {\cf17 public} ThreadState ThreadState\par
00238         \{\par
00239             {\cf17 get} \par
00240             \{\par
00241                 {\cf19 throw} {\cf17 new} NotImplementedException(nameof(ThreadState));\par
00242             \}\par
00243             {\cf17 set}\par
00244             \{\par
00245                {\cf19 throw} {\cf17 new} NotImplementedException(nameof(ThreadState));\par
00246             \}\par
00247         \}\par
00248 \par
00252         {\cf17 public} ThreadWaitReason ThreadWaitReason\par
00253         \{\par
00254             {\cf17 get}\par
00255             \{\par
00256                 {\cf19 throw} {\cf17 new} NotImplementedException(nameof(ThreadWaitReason));\par
00257             \}\par
00258             {\cf17 set}\par
00259             \{\par
00260                 {\cf19 throw} {\cf17 new} NotImplementedException(nameof(ThreadWaitReason));\par
00261             \}\par
00262         \}\par
00267         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\par
00268         {\cf17 public} TimeSpan ThreadCreationTime\par
00269         \{\par
00270             {\cf17 get}\par
00271             \{\par
00272                 {\cf19 return}  {\cf17 new} TimeSpan(({\cf18 long})MemoryNative.Peek8(ThreadContextInternal.ThreadContext_GetThreadTimeCreationTime(Native)));\par
00273             \}\par
00274         \}\par
00275 \par
00279         \par
00280         {\cf17 public} TimeSpan ThreadExitTime\par
00281         \{\par
00282             {\cf17 get}\par
00283             \{\par
00284                 {\cf19 return} {\cf17 new} TimeSpan(({\cf18 long})MemoryNative.Peek8(ThreadContextInternal.ThreadContext_GetThreadTimeExitTime(Native)));\par
00285             \}\par
00286         \}\par
00287 \par
00291         \par
00292         {\cf17 public} TimeSpan UserProcessorTime\par
00293         \{\par
00294             {\cf17 get}\par
00295             \{\par
00296                 {\cf19 return} {\cf17 new} TimeSpan(({\cf18 long})MemoryNative.Peek8(ThreadContextInternal.ThreadContext_GetThreadTimeUserTime(Native)));\par
00297             \}\par
00298         \}\par
00299 \par
00303         \par
00304         {\cf17 public} TimeSpan KernelProcessorTime\par
00305         \{\par
00306             {\cf17 get}\par
00307             \{\par
00308                 {\cf19 return} {\cf17 new} TimeSpan(({\cf18 long})MemoryNative.Peek8(ThreadContextInternal.ThreadContext_GetThreadTimeKernelTime(Native)));\par
00309             \}\par
00310         \}\par
00311 \par
00315         {\cf17 public} TimeSpan TotalProcessorTime\par
00316         \{\par
00317             {\cf17 get}\par
00318             \{\par
00319                 {\cf19 return} KernelProcessorTime + UserProcessorTime;\par
00320             \}\par
00321         \}\par
00322 \par
00326         {\cf17 public} IntPtr Context\par
00327         \{\par
00328             {\cf17 get}\par
00329             \{\par
00330                 {\cf19 return} ThreadContextInternal.ThreadContext_GetContext(Native);\par
00331             \}\par
00332             {\cf17 set}\par
00333             \{\par
00334                 ThreadContextInternal.ThreadContext_SetContext(Native, value);\par
00335             \}\par
00336         \}\par
00337 \par
00341         {\cf17 public} IntPtr Wow64Context\par
00342         \{\par
00343             {\cf17 get}\par
00344             \{\par
00345                 {\cf19 return} ThreadContextInternal.ThreadContext_GetWow64Context(Native);\par
00346             \}\par
00347             {\cf17 set}\par
00348             \{\par
00349                 ThreadContextInternal.ThreadContext_SetWow64Context(Native, value);\par
00350             \}\par
00351         \}\par
00352     \}\par
00353 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Debugging/Thread/Wow64Context.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Debugging/Thread/Wow64Context.cs}
{\xe \v Debugging/Thread/Wow64Context.cs}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.Thread.Wow64FloatingPointSaveArea}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Debugging.Thread.Wow64ContextLayout}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handler for reading from / writing to a Wow64ContextString }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Debugging.Thread.Wow64Context}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Debugging.Thread}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Wow64Context.cs\par \pard\plain 
{\tc\tcl2 \v Debugging/Thread/Wow64Context.cs}
{\xe \v Debugging/Thread/Wow64Context.cs}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Abstract;\par
00002 {\cf17 using }InsightSheath.Wrappers;\par
00003 {\cf17 using }System;\par
00004 {\cf17 using }System.Collections.Generic;\par
00005 {\cf17 using }System.Linq;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 {\cf17 using }System.Text;\par
00008 {\cf17 using }System.Threading.Tasks;\par
00009 \par
00010 {\cf17 namespace }InsightSheath.Debugging.Thread\par
00011 \{\par
00012     {\cf20 /*}\par
00013 {\cf20      * typedef struct _WOW64_FLOATING_SAVE_AREA \{}\par
00014 {\cf20     DWORD   ControlWord;}\par
00015 {\cf20     DWORD   StatusWord;}\par
00016 {\cf20     DWORD   TagWord;}\par
00017 {\cf20     DWORD   ErrorOffset;}\par
00018 {\cf20     DWORD   ErrorSelector;}\par
00019 {\cf20     DWORD   DataOffset;}\par
00020 {\cf20     DWORD   DataSelector;}\par
00021 {\cf20     BYTE    RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];}\par
00022 {\cf20     DWORD   Cr0NpxState;}\par
00023 {\cf20 \} WOW64_FLOATING_SAVE_AREA;}\par
00024 {\cf20      * ypedef struct _WOW64_CONTEXT \{}\par
00025 {\cf20   DWORD                    ContextFlags;}\par
00026 {\cf20   DWORD                    Dr0;}\par
00027 {\cf20   DWORD                    Dr1;}\par
00028 {\cf20   DWORD                    Dr2;}\par
00029 {\cf20   DWORD                    Dr3;}\par
00030 {\cf20   DWORD                    Dr6;}\par
00031 {\cf20   DWORD                    Dr7;}\par
00032 {\cf20   WOW64_FLOATING_SAVE_AREA FloatSave;}\par
00033 {\cf20   DWORD                    SegGs;}\par
00034 {\cf20   DWORD                    SegFs;}\par
00035 {\cf20   DWORD                    SegEs;}\par
00036 {\cf20   DWORD                    SegDs;}\par
00037 {\cf20   DWORD                    Edi;}\par
00038 {\cf20   DWORD                    Esi;}\par
00039 {\cf20   DWORD                    Ebx;}\par
00040 {\cf20   DWORD                    Edx;}\par
00041 {\cf20   DWORD                    Ecx;}\par
00042 {\cf20   DWORD                    Eax;}\par
00043 {\cf20   DWORD                    Ebp;}\par
00044 {\cf20   DWORD                    Eip;}\par
00045 {\cf20   DWORD                    SegCs;}\par
00046 {\cf20   DWORD                    EFlags;}\par
00047 {\cf20   DWORD                    Esp;}\par
00048 {\cf20   DWORD                    SegSs;}\par
00049 {\cf20   BYTE                     ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];}\par
00050 {\cf20 \} WOW64_CONTEXT;}\par
00051 {\cf20      * */}\par
00052 \par
00053     [StructLayout(LayoutKind.Sequential)]\par
00054     {\cf17 public} {\cf17 struct }Wow64FloatingPointSaveArea\par
00055     \{\par
00056         {\cf17 public} uint ControlWord;\par
00057         {\cf17 public} uint StatusWord;\par
00058         {\cf17 public} uint TagWord;\par
00059         {\cf17 public} uint ErrorOffset;\par
00060         {\cf17 public} uint ErrorSelector;\par
00061         {\cf17 public} uint DataOffset;\par
00062         {\cf17 public} uint DataSelector;\par
00063         {\cf20 /* WOW64_SIZE_OF_80387_REGISTERS = 80 in winnt.h */}\par
00064         [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst =80)]\par
00065         {\cf17 public} {\cf18 byte}[] RegisterArea;\par
00066         {\cf17 public} uint Cr0NpxState;\par
00067 \par
00068     \}\par
00072     [StructLayout(LayoutKind.Sequential)]\par
00073     {\cf17 public} {\cf17 struct }Wow64ContextLayout\par
00074     \{\par
00075         {\cf17 public} uint ContextFlags;\par
00076         {\cf17 public} uint Dr0;\par
00077         {\cf17 public} uint Dr1;\par
00078         {\cf17 public} uint Dr2;\par
00079         {\cf17 public} uint Dr3;\par
00080         {\cf17 public} uint Dr6;\par
00081         {\cf17 public} uint Dr7;\par
00082         {\cf17 public} Wow64FloatingPointSaveArea FloatSave;\par
00083         {\cf17 public} uint SegGs;\par
00084         {\cf17 public} uint SegFs;\par
00085         {\cf17 public} uint SegEs;\par
00086         {\cf17 public} uint SegDs;\par
00087         {\cf17 public} uint Edi;\par
00088         {\cf17 public} uint Esi;\par
00089         {\cf17 public} uint Ebx;\par
00090         {\cf17 public} uint Edx;\par
00091         {\cf17 public} uint Ecx;\par
00092         {\cf17 public} uint Eax;\par
00093         {\cf17 public} uint Ebp;\par
00094         {\cf17 public} uint Eip;\par
00095         {\cf17 public} uint SegCs;\par
00096         {\cf17 public} uint EFlags;\par
00097         {\cf17 public} uint Esp;\par
00098         {\cf17 public} uint SegSs;\par
00099         {\cf20 /* WOW64_MAXIMUM_SUPPORTED_EXTENSION is 512 in winnt.h*/}\par
00100         [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]\par
00101         {\cf17 public} {\cf18 byte}[] ExtendedRegisters;\par
00102     \}\par
00103 \par
00104     \par
00105     {\cf17 public} {\cf17 class }Wow64Context: OnDemandMarshalNativeStruct\par
00106     \{\par
00107         {\cf17 public} Wow64Context(IntPtr Native): base(Native)\par
00108         \{\par
00109             WasBlit = {\cf17 false};\par
00110             StaleManagedStruct = {\cf17 false};\par
00111             \par
00112         \}\par
00113         {\cf17 public} uint ContextFlags\par
00114         \{\par
00115             {\cf17 get}\par
00116             \{\par
00117                 {\cf19 if} (!WasBlit)\par
00118                 \{\par
00119                     Blit();\par
00120                 \}\par
00121                 {\cf19 return} Private.ContextFlags;\par
00122             \}\par
00123             {\cf17 set}\par
00124             \{\par
00125                 Private.ContextFlags = value;\par
00126                 StaleManagedStruct = {\cf17 true};\par
00127             \}\par
00128         \}\par
00129         {\cf17 public} uint Dr0\par
00130         \{\par
00131             {\cf17 get}\par
00132             \{\par
00133                 {\cf19 if} (!WasBlit)\par
00134                 \{\par
00135                     Blit();\par
00136                 \}\par
00137                 {\cf19 return} Private.Dr0;\par
00138             \}\par
00139             {\cf17 set}\par
00140             \{\par
00141                 Private.Dr0 = value;\par
00142                 StaleManagedStruct = {\cf17 true};\par
00143             \}\par
00144         \}\par
00145 \par
00146         {\cf17 public} uint Dr1\par
00147         \{\par
00148             {\cf17 get}\par
00149             \{\par
00150                 {\cf19 if} (!WasBlit)\par
00151                 \{\par
00152                     Blit();\par
00153                 \}\par
00154                 {\cf19 return} Private.Dr1;\par
00155             \}\par
00156             {\cf17 set}\par
00157             \{\par
00158                 Private.Dr1 = value;\par
00159                 StaleManagedStruct = {\cf17 true};\par
00160             \}\par
00161         \}\par
00162 \par
00163         {\cf17 public} uint Dr2\par
00164         \{\par
00165             {\cf17 get}\par
00166             \{\par
00167                 {\cf19 if} (!WasBlit)\par
00168                 \{\par
00169                     Blit();\par
00170                 \}\par
00171                 {\cf19 return} Private.Dr2;\par
00172             \}\par
00173             {\cf17 set}\par
00174             \{\par
00175                 Private.Dr2 = value;\par
00176                 StaleManagedStruct = {\cf17 true};\par
00177             \}\par
00178         \}\par
00179 \par
00180         {\cf17 public} uint Dr3\par
00181         \{\par
00182             {\cf17 get}\par
00183             \{\par
00184                 {\cf19 if} (!WasBlit)\par
00185                 \{\par
00186                     Blit();\par
00187                 \}\par
00188                 {\cf19 return} Private.Dr3;\par
00189                 StaleManagedStruct = {\cf17 true};\par
00190             \}\par
00191             {\cf17 set}\par
00192             \{\par
00193                 Private.Dr3 = value;\par
00194             \}\par
00195         \}\par
00196 \par
00197         {\cf17 public} uint Dr6\par
00198         \{\par
00199             {\cf17 get}\par
00200             \{\par
00201                 {\cf19 if} (!WasBlit)\par
00202                 \{\par
00203                     Blit();\par
00204                 \}\par
00205                 {\cf19 return} Private.Dr6;\par
00206 \par
00207             \}\par
00208             {\cf17 set}\par
00209             \{\par
00210                 Private.Dr6 = value;\par
00211                 StaleManagedStruct = {\cf17 true};\par
00212             \}\par
00213         \}\par
00214 \par
00215         {\cf17 public} uint Dr7\par
00216         \{\par
00217             {\cf17 get}\par
00218             \{\par
00219                 {\cf19 if} (!WasBlit)\par
00220                 \{\par
00221                     Blit();\par
00222                 \}\par
00223                 {\cf19 return} Private.Dr7;\par
00224             \}\par
00225             {\cf17 set}\par
00226             \{\par
00227                 Private.Dr7 = value;\par
00228                 StaleManagedStruct = {\cf17 true};\par
00229             \}\par
00230         \}\par
00231 \par
00232 \par
00233         \par
00234         {\cf17 public} Wow64FloatingPointSaveArea FloatSave\par
00235         \{\par
00236             {\cf17 get}\par
00237             \{\par
00238                 {\cf19 if} (!WasBlit)\par
00239                 \{\par
00240                     Blit();\par
00241                 \}\par
00242                 {\cf19 return} Private.FloatSave;\par
00243             \}\par
00244             {\cf17 set}\par
00245             \{\par
00246                 Private.FloatSave = value;\par
00247                 StaleManagedStruct = {\cf17 true};\par
00248             \}\par
00249         \}\par
00250 \par
00251         {\cf17 public} uint SegGs\par
00252         \{\par
00253             {\cf17 get}\par
00254             \{\par
00255                 {\cf19 if} (!WasBlit)\par
00256                 \{\par
00257                     Blit();\par
00258                 \}\par
00259                 {\cf19 return} Private.SegGs;\par
00260             \}\par
00261             {\cf17 set}\par
00262             \{\par
00263                 Private.SegGs = value;\par
00264                 StaleManagedStruct = {\cf17 true};\par
00265             \}\par
00266         \}\par
00267 \par
00268 \par
00269         {\cf17 public} uint SegFs\par
00270         \{\par
00271             {\cf17 get}\par
00272             \{\par
00273                 {\cf19 if} (!WasBlit)\par
00274                 \{\par
00275                     Blit();\par
00276                 \}\par
00277                 {\cf19 return} Private.SegFs;\par
00278             \}\par
00279             {\cf17 set}\par
00280             \{\par
00281                 Private.SegFs = value;\par
00282                 StaleManagedStruct = {\cf17 true};\par
00283             \}\par
00284         \}\par
00285 \par
00286 \par
00287 \par
00288         {\cf17 public} uint SegEs\par
00289         \{\par
00290             {\cf17 get}\par
00291             \{\par
00292                 {\cf19 if} (!WasBlit)\par
00293                 \{\par
00294                     Blit();\par
00295                 \}\par
00296                 {\cf19 return} Private.SegEs;\par
00297             \}\par
00298             {\cf17 set}\par
00299             \{\par
00300                 Private.SegEs = value;\par
00301                 StaleManagedStruct = {\cf17 true};\par
00302             \}\par
00303         \}\par
00304 \par
00305 \par
00306 \par
00307 \par
00308         {\cf17 public} uint SegDs\par
00309         \{\par
00310             {\cf17 get}\par
00311             \{\par
00312                 {\cf19 if} (!WasBlit)\par
00313                 \{\par
00314                     Blit();\par
00315                 \}\par
00316                 {\cf19 return} Private.SegDs;\par
00317             \}\par
00318             {\cf17 set}\par
00319             \{\par
00320                 Private.SegDs = value;\par
00321                 StaleManagedStruct = {\cf17 true};\par
00322             \}\par
00323         \}\par
00324 \par
00325         {\cf17 public} uint Ebp\par
00326         \{\par
00327             {\cf17 get}\par
00328             \{\par
00329                 {\cf19 if} (!WasBlit)\par
00330                 \{\par
00331                     Blit();\par
00332                 \}\par
00333                 {\cf19 return} Private.Ebp;\par
00334             \}\par
00335             {\cf17 set}\par
00336             \{\par
00337                 Private.Ebp = value;\par
00338                 StaleManagedStruct = {\cf17 true};\par
00339             \}\par
00340         \}\par
00341 \par
00342 \par
00343 \par
00344         {\cf17 public} uint Eip\par
00345         \{\par
00346             {\cf17 get}\par
00347             \{\par
00348                 {\cf19 if} (!WasBlit)\par
00349                 \{\par
00350                     Blit();\par
00351                 \}\par
00352                 {\cf19 return} Private.Eip;\par
00353             \}\par
00354             {\cf17 set}\par
00355             \{\par
00356                 Private.Eip = value;\par
00357                 StaleManagedStruct = {\cf17 true};\par
00358             \}\par
00359         \}\par
00360 \par
00361 \par
00362         {\cf17 public} uint Ecx\par
00363         \{\par
00364             {\cf17 get}\par
00365             \{\par
00366                 {\cf19 if} (!WasBlit)\par
00367                 \{\par
00368                     Blit();\par
00369                 \}\par
00370                 {\cf19 return} Private.Ecx;\par
00371             \}\par
00372             {\cf17 set}\par
00373             \{\par
00374                 Private.Ecx = value;\par
00375                 StaleManagedStruct = {\cf17 true};\par
00376             \}\par
00377         \}\par
00378 \par
00379 \par
00380         {\cf17 public} uint Eax\par
00381         \{\par
00382             {\cf17 get}\par
00383             \{\par
00384                 {\cf19 if} (!WasBlit)\par
00385                 \{\par
00386                     Blit();\par
00387                 \}\par
00388                 {\cf19 return} Private.Eax;\par
00389             \}\par
00390             {\cf17 set}\par
00391             \{\par
00392                 Private.Eax = value;\par
00393                 StaleManagedStruct = {\cf17 true};\par
00394             \}\par
00395         \}\par
00396 \par
00397 \par
00398         {\cf17 public} uint Edx\par
00399         \{\par
00400             {\cf17 get}\par
00401             \{\par
00402                 {\cf19 if} (!WasBlit)\par
00403                 \{\par
00404                     Blit();\par
00405                 \}\par
00406                 {\cf19 return} Private.Edx;\par
00407             \}\par
00408             {\cf17 set}\par
00409             \{\par
00410                 Private.Edx = value;\par
00411                 StaleManagedStruct = {\cf17 true};\par
00412             \}\par
00413         \}\par
00414 \par
00415 \par
00416         {\cf17 public} uint Ebx\par
00417         \{\par
00418             {\cf17 get}\par
00419             \{\par
00420                 {\cf19 if} (!WasBlit)\par
00421                 \{\par
00422                     Blit();\par
00423                 \}\par
00424                 {\cf19 return} Private.Ebx;\par
00425             \}\par
00426             {\cf17 set}\par
00427             \{\par
00428                 Private.Ebx = value;\par
00429                 StaleManagedStruct = {\cf17 true};\par
00430             \}\par
00431         \}\par
00432 \par
00433 \par
00434         {\cf17 public} uint Esi\par
00435         \{\par
00436             {\cf17 get}\par
00437             \{\par
00438                 {\cf19 if} (!WasBlit)\par
00439                 \{\par
00440                     Blit();\par
00441                 \}\par
00442                 {\cf19 return} Private.Esi;\par
00443             \}\par
00444             {\cf17 set}\par
00445             \{\par
00446                 Private.Esi = value;\par
00447                 StaleManagedStruct = {\cf17 true};\par
00448             \}\par
00449         \}\par
00450 \par
00451 \par
00452         {\cf17 public} uint Edi\par
00453         \{\par
00454             {\cf17 get}\par
00455             \{\par
00456                 {\cf19 if} (!WasBlit)\par
00457                 \{\par
00458                     Blit();\par
00459                 \}\par
00460                 {\cf19 return} Private.Edi;\par
00461             \}\par
00462             {\cf17 set}\par
00463             \{\par
00464                 Private.Edi = value;\par
00465                 StaleManagedStruct = {\cf17 true};\par
00466             \}\par
00467         \}\par
00468 \par
00469 \par
00470         {\cf17 public} uint SegCs\par
00471         \{\par
00472             {\cf17 get}\par
00473             \{\par
00474                 {\cf19 if} (!WasBlit)\par
00475                 \{\par
00476                     Blit();\par
00477                 \}\par
00478                 {\cf19 return} Private.SegCs;\par
00479             \}\par
00480             {\cf17 set}\par
00481             \{\par
00482                 Private.SegCs = value;\par
00483                 StaleManagedStruct = {\cf17 true};\par
00484             \}\par
00485         \}\par
00486 \par
00487 \par
00488         {\cf17 public} uint EFlags\par
00489         \{\par
00490             {\cf17 get}\par
00491             \{\par
00492                 {\cf19 if} (!WasBlit)\par
00493                 \{\par
00494                     Blit();\par
00495                 \}\par
00496                 {\cf19 return} Private.EFlags;\par
00497             \}\par
00498             {\cf17 set}\par
00499             \{\par
00500                 Private.EFlags = value;\par
00501                 StaleManagedStruct = {\cf17 true};\par
00502             \}\par
00503         \}\par
00504 \par
00505 \par
00506 \par
00507         {\cf17 public} uint Esp\par
00508         \{\par
00509             {\cf17 get}\par
00510             \{\par
00511                 {\cf19 if} (!WasBlit)\par
00512                 \{\par
00513                     Blit();\par
00514                 \}\par
00515                 {\cf19 return} Private.Esp;\par
00516             \}\par
00517             {\cf17 set}\par
00518             \{\par
00519                 Private.Esp = value;\par
00520                 StaleManagedStruct = {\cf17 true};\par
00521             \}\par
00522         \}\par
00523 \par
00524 \par
00525 \par
00526         {\cf17 public} uint SegSs\par
00527         \{\par
00528             {\cf17 get}\par
00529             \{\par
00530                 {\cf19 if} (!WasBlit)\par
00531                 \{\par
00532                     Blit();\par
00533                 \}\par
00534                 {\cf19 return} Private.SegSs;\par
00535             \}\par
00536             {\cf17 set}\par
00537             \{\par
00538                 Private.SegSs = value;\par
00539                 StaleManagedStruct = {\cf17 true};\par
00540             \}\par
00541         \}\par
00542 \par
00543         \par
00544         {\cf17 public} {\cf18 byte}[] ExtendedRegisters\par
00545         \{\par
00546             {\cf17 get}\par
00547             \{\par
00548                 {\cf19 if} (!WasBlit)\par
00549                 \{\par
00550                     Blit();\par
00551                 \}\par
00552                 {\cf19 return} Private.ExtendedRegisters;\par
00553             \}\par
00554             {\cf17 set}\par
00555             \{\par
00556                 Private.ExtendedRegisters = value;\par
00557                 StaleManagedStruct = {\cf17 true};\par
00558             \}\par
00559         \}\par
00560                 \par
00561         {\cf17 public} Wow64Context(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, FreeOnCleanup)\par
00562         \{\par
00563 \par
00564         \}\par
00565 \par
00566         \par
00567 \par
00568         {\cf17 protected} {\cf17 override} {\cf18 void} Blit()\par
00569         \{\par
00570             {\cf19 if} (StaleManagedStruct)\par
00571             \{\par
00572                 Apply();\par
00573             \}\par
00574             {\cf19 if} (!WasBlit)\par
00575             \{\par
00576                 Private = Marshal.PtrToStructure<Wow64ContextLayout>(Native);\par
00577                 WasBlit = {\cf17 true};\par
00578             \}\par
00579         \}\par
00580 \par
00581        \par
00582         {\cf17 private} {\cf18 bool} disposedValue;\par
00583         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00584         \{\par
00585             {\cf19 if} (!disposedValue)\par
00586             \{\par
00587                 {\cf19 if} (FreeOnCleanup)\par
00588                 \{\par
00589                     NativeImports.NativeMethods.SimpleFree(Native);\par
00590                 \}\par
00591                 ClearNative();\par
00592                 disposedValue = {\cf17 true};\par
00593             \}\par
00594         \}\par
00595 \par
00596         {\cf17 protected} {\cf17 override} {\cf18 void} Apply()\par
00597         \{\par
00598             {\cf19 if} ( (StaleManagedStruct) && (Native != IntPtr.Zero))\par
00599             \{\par
00600                 Marshal.StructureToPtr(Private, Native, {\cf17 false});\par
00601                 StaleManagedStruct = {\cf17 false};\par
00602             \}\par
00603         \}\par
00604 \par
00605         Wow64ContextLayout Private;\par
00606     \}\par
00607 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MemoryNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v MemoryNative.cs}
{\xe \v MemoryNative.cs}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.MemoryNative}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read and write to native memory via Peek and Poke routines. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MemoryNative.cs\par \pard\plain 
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.NativeImports;\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Collections.Generic;\par
00004 {\cf17 using }System.Linq;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.Debugging.Process;\par
00008 {\cf17 using }InsightSheath.Debugging;\par
00009 {\cf17 namespace }InsightSheath\par
00010 \{\par
00015     {\cf17 public} {\cf17 static} {\cf17 class }MemoryNative\par
00016     \{\par
00022         {\cf17 public} {\cf17 static} uint Peek4(IntPtr Target)\par
00023         \{\par
00024             {\cf19 return} MemoryNativeInternal.Peek4(Target);\par
00025         \}\par
00026 \par
00032         {\cf17 public} {\cf17 static} {\cf18 void} Poke4(IntPtr Target, uint value)\par
00033         \{\par
00034             MemoryNativeInternal.Poke4(Target, value);\par
00035         \}\par
00036 \par
00043         {\cf17 public} {\cf17 static} {\cf18 void} SetDebugEventCallbackResponse(IntPtr ContState, DebugContState Response)\par
00044         \{\par
00045             MemoryNativeInternal.Poke4(ContState, (uint)Response);\par
00046         \}\par
00047 \par
00053         {\cf17 public} {\cf17 static} ulong Peek8(IntPtr Target)\par
00054         \{\par
00055             {\cf19 return} MemoryNativeInternal.Peek8(Target);\par
00056         \}\par
00057 \par
00064         {\cf17 public} {\cf17 static} {\cf18 bool} Poke8(IntPtr Target, ulong val)\par
00065         \{\par
00066             {\cf19 return} MemoryNativeInternal.Poke8(Target, val);\par
00067         \}\par
00068 \par
00076         {\cf17 public} {\cf17 static} {\cf18 bool} RemotePoke4(IntPtr ProcessHandle, uint val, IntPtr RemoteLocation)\par
00077         \{\par
00078             {\cf19 return} MemoryNativeInternal.RemotePoke4(ProcessHandle, val, RemoteLocation);\par
00079         \}\par
00080 \par
00088         {\cf17 public} {\cf17 static} {\cf18 bool} RemotePoke8(IntPtr ProcessHandle, ulong val, IntPtr RemoteLocation)\par
00089         \{\par
00090             {\cf19 return} MemoryNativeInternal.RemotePoke8(ProcessHandle, val, RemoteLocation);\par
00091         \}\par
00092     \}\par
00093 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Misc/EventDebug.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Misc/EventDebug.cs}
{\xe \v Misc/EventDebug.cs}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Misc.EventDebugAssist}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements an event debugger system for processing events. You will need to link a way to call {\b EventDebugAssist.FireEvents(DebugEvent)} in order to actually make to the thing work }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Misc}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EventDebug.cs\par \pard\plain 
{\tc\tcl2 \v Misc/EventDebug.cs}
{\xe \v Misc/EventDebug.cs}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }InsightSheath.Debugging;\par
00007 {\cf17 using }InsightSheath.Wrappers;\par
00008 \par
00009 {\cf17 namespace }InsightSheath.Misc\par
00010 \{\par
00014     {\cf17 public} {\cf17 class }EventDebugAssist\par
00015     \{\par
00016         \par
00021         {\cf17 public} delegate {\cf18 void} CreateProcessEventCallback(DebugEvent Ptr);\par
00026         {\cf17 public} delegate {\cf18 void} CreateThreadEventCallback(DebugEvent Ptr);\par
00031         {\cf17 public} delegate {\cf18 void} ExceptionDebugEventCallback(DebugEvent Ptr);\par
00036         {\cf17 public} delegate {\cf18 void} ExitProcessDebugEventCallback(DebugEvent Ptr);\par
00041         {\cf17 public} delegate {\cf18 void} ExitThreadDebugEventCallback(DebugEvent Ptr);\par
00046         {\cf17 public} delegate {\cf18 void} LoadDllDebugEventCallback(DebugEvent Ptr);\par
00051         {\cf17 public} delegate {\cf18 void} OutputDebugStringCallback(DebugEvent Ptr);\par
00056         {\cf17 public} delegate {\cf18 void} RipCallback(DebugEvent Ptr);\par
00061         {\cf17 public} delegate {\cf18 void} UnloadDebugEventCallback(DebugEvent Ptr);\par
00066         {\cf17 public} delegate {\cf18 void} GeneralDebugEventCallback(DebugEvent Ptr);\par
00067 \par
00071         {\cf17 public} {\cf17 event} CreateProcessEventCallback CreateProcessEvent;\par
00075         {\cf17 public} {\cf17 event} CreateThreadEventCallback CreateThreadEvent;\par
00079         {\cf17 public} {\cf17 event} ExceptionDebugEventCallback ExceptionEvent;\par
00083         {\cf17 public} {\cf17 event} ExitProcessDebugEventCallback ExitProcessEvent;\par
00087         {\cf17 public} {\cf17 event} ExitThreadDebugEventCallback ExitThreadEvent;\par
00091         {\cf17 public} {\cf17 event} LoadDllDebugEventCallback LoadDllEvent;\par
00095         {\cf17 public} {\cf17 event} OutputDebugStringCallback OutputDebugStringEvent;\par
00099         {\cf17 public} {\cf17 event} RipCallback RipEvent;\par
00103         {\cf17 public} {\cf17 event} UnloadDebugEventCallback UnloadDllEvent;\par
00107         {\cf17 public} {\cf17 event} GeneralDebugEventCallback GeneralEvent;\par
00108 \par
00113         {\cf17 public} {\cf17 virtual} {\cf18 void} FireEvents(DebugEvent Ptr)\par
00114         \{\par
00115             {\cf19 if} (Ptr != {\cf17 null})\par
00116             \{\par
00117                 GeneralEvent?.Invoke(Ptr);\par
00118                 {\cf19 switch} (Ptr.EventType)\par
00119                 \{\par
00120                     {\cf19 case} DebugEventType.CreateProcessEvent:\par
00121                         \{\par
00122                             CreateProcessEvent?.Invoke(Ptr);\par
00123                             {\cf19 break};\par
00124                         \}\par
00125                     {\cf19 case} DebugEventType.CreateTheadEvent:\par
00126                         \{\par
00127                             CreateThreadEvent?.Invoke(Ptr);\par
00128                             {\cf19 break};\par
00129                         \}\par
00130                     {\cf19 case} DebugEventType.ExceptionEvent:\par
00131                         \{\par
00132                             ExceptionEvent?.Invoke(Ptr);\par
00133                             {\cf19 break};\par
00134                         \}\par
00135                     {\cf19 case} DebugEventType.ExitProcessEvent:\par
00136                         \{\par
00137                             ExitProcessEvent?.Invoke(Ptr);\par
00138                             {\cf19 break};\par
00139                         \}\par
00140                     {\cf19 case} DebugEventType.ExitThreadEvent:\par
00141                         \{\par
00142                             ExitThreadEvent.Invoke(Ptr);\par
00143                             {\cf19 break};\par
00144                         \}\par
00145                     {\cf19 case} DebugEventType.LoadDllEvent:\par
00146                         \{\par
00147                             LoadDllEvent?.Invoke(Ptr);\par
00148                             {\cf19 break};\par
00149                         \}\par
00150                     {\cf19 case} DebugEventType.OutputDebugString:\par
00151                         \{\par
00152                             OutputDebugStringEvent?.Invoke(Ptr);\par
00153                             {\cf19 break};\par
00154                         \}\par
00155                     {\cf19 case} DebugEventType.RipEvent:\par
00156                         \{\par
00157                             RipEvent?.Invoke(Ptr);\par
00158                             {\cf19 break};\par
00159                         \}\par
00160                     {\cf19 case} DebugEventType.UnloadDllEvent:\par
00161                         \{\par
00162                             {\cf19 break};\par
00163                         \}\par
00164                     {\cf19 default}:\par
00165                         \{\par
00166                             GeneralEvent?.Invoke(Ptr);\par
00167                             {\cf19 break};\par
00168                         \}\par
00169                 \}\par
00170             \}\par
00171         \}\par
00172     \}\par
00173 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Misc/ReferenceCounter.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Misc/ReferenceCounter.cs}
{\xe \v Misc/ReferenceCounter.cs}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Misc.ReferenceCounter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
USed by the ReferenceCounterNativeStaticContainer to track and change a reference. This is primary used by the DebugEvent class collection as we're handing out Multiple REferences to the same Native Pointer like candy and need to take steps to prevent users of the library from prematuring freeing the same sheath. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Misc}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ReferenceCounter.cs\par \pard\plain 
{\tc\tcl2 \v Misc/ReferenceCounter.cs}
{\xe \v Misc/ReferenceCounter.cs}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 \par
00007 {\cf17 namespace }InsightSheath.Misc\par
00008 \{\par
00026     {\cf17 public} {\cf17 class }ReferenceCounter\par
00027     \{\par
00028         {\cf17 public} ulong AddRef()\par
00029         \{\par
00030             {\cf19 if} (RefContainer != ulong.MaxValue)\par
00031                 RefContainer++;\par
00032             {\cf19 return} RefContainer;\par
00033         \}\par
00034 \par
00035         {\cf17 public} ulong DecRef()\par
00036         \{\par
00037             {\cf19 if} (RefContainer != ulong.MinValue)\par
00038                 RefContainer--;\par
00039             {\cf19 return} RefContainer;\par
00040         \}\par
00041 \par
00042         {\cf17 public} ulong Ref\par
00043         \{\par
00044             {\cf17 get}\par
00045             \{\par
00046                 {\cf19 return} RefContainer;\par
00047             \}\par
00048             {\cf17 set}\par
00049             \{\par
00050                 RefContainer = value;\par
00051             \}\par
00052         \}\par
00053 \par
00054         {\cf17 private} ulong RefContainer;\par
00055 \par
00056         \par
00057     \}\par
00058 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/DebugEventNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/DebugEventNative.cs}
{\xe \v NativeImports/Debugging/DebugEventNative.cs}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.DebugEventNative}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in DebugEvent class }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DebugEventNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/DebugEventNative.cs}
{\xe \v NativeImports/Debugging/DebugEventNative.cs}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Debugging;\par
00002 {\cf17 using }InsightSheath.Wrappers;\par
00003 {\cf17 using }System;\par
00004 {\cf17 using }System.Collections.Generic;\par
00005 {\cf17 using }System.Linq;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 {\cf17 using }System.Text;\par
00008 {\cf17 using }System.Threading.Tasks;\par
00009 \par
00010 {\cf17 namespace }InsightSheath.NativeImports\par
00011 \{\par
00012 \par
00016     {\cf17 static} {\cf17 partial class }DebugEventNative\par
00017     \{\par
00023         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_GetProcessId"}, ExactSpelling = {\cf17 false})]\par
00024         {\cf17 public} {\cf17 static} {\cf17 extern} uint DebugEvent_GetProcessID(IntPtr LPDebugEvent);\par
00025 \par
00031         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_GetThreadId"}, ExactSpelling = {\cf17 false})]\par
00032         {\cf17 public} {\cf17 static} {\cf17 extern} uint DebugEvent_GetThreadID(IntPtr LPDebugEvent);\par
00033 \par
00039         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_GetEventType"}, ExactSpelling = {\cf17 false})]\par
00040         {\cf17 public} {\cf17 static} {\cf17 extern} DebugEventType DebugEvent_GetEventType(IntPtr LPDebugEvent);\par
00041 \par
00042 \par
00048         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_RipGetErrorType"}, ExactSpelling = {\cf17 false})]\par
00049         {\cf17 public} {\cf17 static} {\cf17 extern} RipErrorType DebugEvent_RipGetErrorType(IntPtr LPDebugEvent);\par
00050 \par
00051 \par
00052         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_RipGetError"}, ExactSpelling = {\cf17 false})]\par
00053         {\cf17 public} {\cf17 static} {\cf17 extern} uint DebugEvent_RipGetError(IntPtr LPDebugEvent);\par
00054 \par
00055         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_CreateProcessGetHFile"}, ExactSpelling = {\cf17 false})]\par
00056         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_CreateProcessGetFileHandle(IntPtr LPDebugEvent);\par
00057 \par
00058         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetFirstChance"}, ExactSpelling = {\cf17 false})]\par
00059         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_ExceptionInfo_GetFirstChance(IntPtr LPDebugEevent);\par
00060 \par
00061         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetExceptionInformation"}, ExactSpelling = {\cf17 false})]\par
00062         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_ExceptionInfo_GetExceptionInformation(IntPtr LPDebugEevent);\par
00063 \par
00064         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetExceptionArgumentCount"}, ExactSpelling = {\cf17 false})]\par
00065         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_ExceptionInfo_GetExceptionArgumentCount(IntPtr LPDebugEevent);\par
00066 \par
00067         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetExceptionAddress"}, ExactSpelling = {\cf17 false})]\par
00068         {\cf17 public} {\cf17 static} {\cf17 extern} UInt64 DebugEvent_ExceptionInfo_GetExceptionAddress(IntPtr LPDebugEevent);\par
00069 \par
00070         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetExceptionRecord"}, ExactSpelling = {\cf17 false})]\par
00071         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_ExceptionInfo_GetExceptionRecord(IntPtr LPDebugEevent);\par
00072 \par
00073         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetExceptionFlags"}, ExactSpelling = {\cf17 false})]\par
00074         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_ExceptionInfo_GetExceptionFlags(IntPtr LPDebugEevent);\par
00075 \par
00076         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExceptionInfo_GetExceptionCode"}, ExactSpelling = {\cf17 false})]\par
00077         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_ExceptionInfo_GetExceptionCode(IntPtr LPDebugEevent);\par
00078 \par
00079 \par
00080         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_LoadDllInfo_GetHFile"}, ExactSpelling = {\cf17 false})]\par
00081         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_LoadDllInfo_GetHFile(IntPtr LPDebugEevent);\par
00082 \par
00083         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_LoadDllInfo_GetBaseOfDll"}, ExactSpelling = {\cf17 false})]\par
00084         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_LoadDllInfo_GetBaseOfDll(IntPtr LPDebugEevent);\par
00085 \par
00086         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_LoadDllINfo_GetDebugInfoOffset"}, ExactSpelling = {\cf17 false})]\par
00087         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_LoadDllINfo_GetDebugInfoOffset(IntPtr LPDebugEevent);\par
00088 \par
00089 \par
00090         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_LoadDllINfo_GetDebugInfoSize"}, ExactSpelling = {\cf17 false})]\par
00091         {\cf17 public} {\cf17 static} {\cf17 extern} UInt32 DebugEvent_LoadDllINfo_GetDebugInfoSize(IntPtr LPDebugEevent);\par
00092 \par
00093 \par
00094         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_LoadDllInfo_GetImageNamge"}, ExactSpelling = {\cf17 false})]\par
00095         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_LoadDllInfo_GetImageNamge(IntPtr LPDebugEevent);\par
00096 \par
00097 \par
00098         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_LoadDllInfo_GetUnicodeFlag"}, ExactSpelling = {\cf17 false})]\par
00099         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 int} DebugEvent_LoadDllInfo_GetUnicodeFlag(IntPtr LPDebugEevent);\par
00100 \par
00101 \par
00102         \par
00103         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_UnloadDllInfo_GetBaseAddress"}, ExactSpelling = {\cf17 false})]\par
00104         {\cf17 public} {\cf17 static} {\cf17 extern} ulong DebugEvent_UnloadDllInfo_GetBaseAddress(IntPtr LPDebugEevent);\par
00105 \par
00106 \par
00107         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_CreateThreadInfo_GetThreadHandle"}, ExactSpelling = {\cf17 false})]\par
00108         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_CreateThreadInfo_GetThreadHandle(IntPtr LPDebugEevent);\par
00109 \par
00110 \par
00111         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_CreateThreadInfo_GetThreadStartAddress"}, ExactSpelling = {\cf17 false})]\par
00112         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_CreateThreadInfo_GetThreadStartAddress(IntPtr LPDebugEevent);\par
00113 \par
00114 \par
00115         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_CreateThreadInfo_GetThreadLocalBase"}, ExactSpelling = {\cf17 false})]\par
00116         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_CreateThreadInfo_GetThreadLocalBase(IntPtr LPDebugEevent);\par
00117 \par
00118 \par
00119         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExitThreadInfo_GetExitCode"}, ExactSpelling = {\cf17 false})]\par
00120         {\cf17 public} {\cf17 static} {\cf17 extern} uint DebugEvent_ExitThreadInfo_GetExitCode(IntPtr LPDebugEevent);\par
00121 \par
00122 \par
00123         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_ExitProcessInfo_GetExitCode"}, ExactSpelling = {\cf17 false})]\par
00124         {\cf17 public} {\cf17 static} {\cf17 extern} uint DebugEvent_ExitProcessInfo_GetExitCode(IntPtr LPDebugEevent);\par
00125 \par
00126 \par
00127 \par
00128         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_IsEventFrom32Bit"}, ExactSpelling = {\cf17 false})]\par
00129         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} DebugEvent_IsEventFrom32Bit(IntPtr LPDebugEevent);\par
00130 \par
00131 \par
00132         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugEvent_AllocateStructure"}, ExactSpelling = {\cf17 false})]\par
00133         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DebugEvent_AllocateStructure();\par
00134 \par
00135 \par
00136 \par
00137 \par
00138 \par
00139 \par
00140 \par
00141 \par
00142         {\cf20 /*}\par
00143 {\cf20         }\par
00144 {\cf20         */}\par
00145         {\cf20 //DWORD WINAPI DebugEvent_ExceptionInfo_GetFirstChance(LPDEBUG_EVENT Ptr)}\par
00146         {\cf20 //DWORD WINAPI Debug_Event_ExceptionInfo_GetFirstChange(LPDEBUG_EVENT Ptr)}\par
00147     \}\par
00148 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/Process/InsightMemoryNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/Process/InsightMemoryNative.cs}
{\xe \v NativeImports/Debugging/Process/InsightMemoryNative.cs}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.InternalInsightMemory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. Contains the routines imported from InsightAPI.DLL for use in the InsightMemory class. Not really planned to be accessible outside of this project. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightMemoryNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/Process/InsightMemoryNative.cs}
{\xe \v NativeImports/Debugging/Process/InsightMemoryNative.cs}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.Debugging.Process;\par
00008 {\cf17 namespace }InsightSheath.NativeImports\par
00009 \{\par
00013     {\cf17 internal} {\cf17 class }InternalInsightMemory\par
00014     \{\par
00020         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_MakeInstance"}, ExactSpelling = {\cf17 false})]\par
00021         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr MakeInstance();\par
00022 \par
00029         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_DupInstance"}, ExactSpelling = {\cf17 false})]\par
00030         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DupInstance(IntPtr That);\par
00031 \par
00032 \par
00039         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_KillInstance"}, ExactSpelling = {\cf17 false})]\par
00040         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} KillInstance(IntPtr That);\par
00041 \par
00042 \par
00043 \par
00044         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_SetTargetProcess"}, ExactSpelling = {\cf17 false})]\par
00045         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} SetTargetProcess(IntPtr That, ulong ProcessHandle, {\cf18 bool} HandleInstance);\par
00046 \par
00047 \par
00053         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_UpdateMemoryStats"}, ExactSpelling = {\cf17 false})]\par
00054         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} UpdateMemoryStats(IntPtr That);\par
00055 \par
00061         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetPageFaultCount"}, ExactSpelling = {\cf17 false})]\par
00062         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetPageFaultCount(IntPtr That);\par
00063 \par
00064 \par
00070 \par
00071         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetPeakWorkingSetSize"}, ExactSpelling = {\cf17 false})]\par
00072         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetPeakWorkingSetSize(IntPtr That);\par
00073 \par
00079 \par
00080         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetWorkingSetSize"}, ExactSpelling = {\cf17 false})]\par
00081         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetWorkingSetSize(IntPtr That);\par
00082 \par
00083 \par
00089         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetQuotaPeakPagedPoolUsage"}, ExactSpelling = {\cf17 false})]\par
00090         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetQuotaPeakPagedPoolUsage(IntPtr That);\par
00091 \par
00092 \par
00098 \par
00099         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetQuotaPagePoolUsage"}, ExactSpelling = {\cf17 false})]\par
00100         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetQuotaPagePoolUsage(IntPtr That);\par
00101 \par
00102 \par
00108 \par
00109         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetPeakNonPagePoolUsage"}, ExactSpelling = {\cf17 false})]\par
00110         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetPeakNonPagePoolUsage(IntPtr That);\par
00111 \par
00112 \par
00118 \par
00119         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetQuotaNonPagedPoolUsage"}, ExactSpelling = {\cf17 false})]\par
00120         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetQuotaNonPagedPoolUsage(IntPtr That);\par
00121 \par
00122 \par
00129         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetPageFileUsage"}, ExactSpelling = {\cf17 false})]\par
00130         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetPageFileUsage(IntPtr That);\par
00131 \par
00137 \par
00138         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetPeakPageFileUsage"}, ExactSpelling = {\cf17 false})]\par
00139         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetPeakPageFileUsage(IntPtr That);\par
00140 \par
00141 \par
00147 \par
00148         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetPrivateUsage"}, ExactSpelling = {\cf17 false})]\par
00149         {\cf17 public} {\cf17 static} {\cf17 extern} ulong GetPrivateUsage(IntPtr That);\par
00150 \par
00151 \par
00157         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetMemoryStatsBulk"}, ExactSpelling = {\cf17 false})]\par
00158         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightMemory_GetMemoryStatsBulk(IntPtr That);\par
00159 \par
00160 \par
00161 \par
00162         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_SetAutoRefreshMemoryStats"}, ExactSpelling = {\cf17 false})]\par
00163         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} SetAutoRefreshMemoryStats(IntPtr That, {\cf18 bool} Enable);\par
00164 \par
00165         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightMemory_GetAutoRefreshMemoryStats"}, ExactSpelling = {\cf17 false})]\par
00166         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} GetAutoRefreshMemoryStats(IntPtr That);\par
00167 \par
00168 \par
00169 \par
00170 \par
00171 \par
00172 \par
00173 \par
00174 \par
00175 \par
00176     \}\par
00177 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/Process/InsightProcessNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/Process/InsightProcessNative.cs}
{\xe \v NativeImports/Debugging/Process/InsightProcessNative.cs}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.InsightProcessInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. Contains the routines imported from InsightAPI.DLL for use in the InsightProcess class }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightProcessNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/Process/InsightProcessNative.cs}
{\xe \v NativeImports/Debugging/Process/InsightProcessNative.cs}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath;\par
00008 {\cf17 using }InsightSheath.Debugging.Process;\par
00009 {\cf17 namespace }InsightSheath.NativeImports\par
00010 \{\par
00011 \par
00012 \par
00016     {\cf17 internal} {\cf17 static} {\cf17 partial class }InsightProcessInternal\par
00017     \{\par
00018         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetMemoryStatsBulkPtr"}, ExactSpelling = {\cf17 false})]\par
00019         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetMemoryStatsBulkPtr(IntPtr That);\par
00020 \par
00021 \par
00022         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetPrivateUsage"}, ExactSpelling = {\cf17 false})]\par
00023         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetPrivateUsage(IntPtr That);\par
00024 \par
00025 \par
00026 \par
00027 \par
00028         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetPeakPageFileUsage"}, ExactSpelling = {\cf17 false})]\par
00029         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetPeakPageFileUsage(IntPtr That);\par
00030 \par
00031 \par
00032         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetPageFileUsage"}, ExactSpelling = {\cf17 false})]\par
00033         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetPageFileUsage(IntPtr That);\par
00034 \par
00035 \par
00036 \par
00037         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetQuotNonPagePoolUsage"}, ExactSpelling = {\cf17 false})]\par
00038         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetQuotNonPagePoolUsage(IntPtr That);\par
00039 \par
00040 \par
00041 \par
00042 \par
00043         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetQuotaPeakNonPagePoolUsage"}, ExactSpelling = {\cf17 false})]\par
00044         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetQuotaPeakNonPagePoolUsage(IntPtr That);\par
00045 \par
00046 \par
00047 \par
00048 \par
00049 \par
00050         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetQuotaPagePoolUsage"}, ExactSpelling = {\cf17 false})]\par
00051         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetQuotaPagePoolUsage(IntPtr That);\par
00052 \par
00053 \par
00054 \par
00055 \par
00056         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetQuotaPeakPagePoolUsage"}, ExactSpelling = {\cf17 false})]\par
00057         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetQuotaPeakPagePoolUsage(IntPtr That);\par
00058 \par
00059 \par
00060 \par
00061 \par
00062 \par
00063         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetWorkingSetSize"}, ExactSpelling = {\cf17 false})]\par
00064         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetWorkingSetSize(IntPtr That);\par
00065 \par
00066 \par
00067 \par
00068 \par
00069         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetPeakWorkingSet"}, ExactSpelling = {\cf17 false})]\par
00070         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetPeakWorkingSet(IntPtr That);\par
00071 \par
00072 \par
00073 \par
00074 \par
00075         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping ={\cf17 false}, CallingConvention = CallingConvention.Winapi,EntryPoint = {\cf22 "InsightProcess_GetPageFaultCount"}, ExactSpelling ={\cf17 false})]\par
00076         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetPageFaultCount(IntPtr That);\par
00077 \par
00084         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetDetourListSize"}, ExactSpelling = {\cf17 false})]\par
00085         {\cf17 public} {\cf17 static} {\cf17 extern} ulong InsightProcess_GetDetourListSize(IntPtr that);\par
00086 \par
00087         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetDetourListEntryReadOnly"}, ExactSpelling = {\cf17 false})]\par
00088         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr PSProcessInformation_GetDetourListIndex(IntPtr That,uint index);\par
00093         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_MakeInstance"}, ExactSpelling = {\cf17 false})]\par
00094         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr CreateInsightProcessNativeClass();\par
00100         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_DupInstance"}, ExactSpelling = {\cf17 false})]\par
00101         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DuplicateInsightProcessNativeClass(IntPtr that);\par
00102 \par
00103         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetStartupInfoClass"}, ExactSpelling = {\cf17 false})]\par
00104         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetStartupInfoClass(IntPtr That);\par
00109         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_KillInstance"}, ExactSpelling = {\cf17 false})]\par
00110         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_KillInstance(IntPtr that);\par
00111 \par
00112 \par
00118         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetProcessName"})]\par
00119         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetProcessName(IntPtr that, {\cf18 string} NewName);\par
00120 \par
00126         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetProcessName"})]\par
00127         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetProcessName(IntPtr That);\par
00128 \par
00129 \par
00135         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SpawnProcess"})]\par
00136         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_Spawn(IntPtr That);\par
00137 \par
00138 \par
00144         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetProcessArgument"})]\par
00145         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetProcessArgument(IntPtr that, {\cf18 string} NewArgument);\par
00146 \par
00147 \par
00153         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetProcessArgument"})]\par
00154         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetProcessArgument(IntPtr That);\par
00155 \par
00162         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetCreationFlags"})]\par
00163         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetCreationFlags(IntPtr That, uint NewFlags);\par
00164 \par
00171         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetCreationFlagDebug"})]\par
00172         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} PsProcessInformation_SetCreationFlagDebug(IntPtr That, uint NewFlags);\par
00173 \par
00180         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetCreationFlagDebugOnlyThis"})]\par
00181         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetCreationFlagDebugOnlyThis(IntPtr That, uint NewFlags);\par
00182 \par
00183 \par
00190         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetCreationFlagDebugSuspended"})]\par
00191         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetCreationFlagDebugSuspended(IntPtr That, uint NewFlags);\par
00192 \par
00199         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetCreationFlagDebugOnlyThisSuspended"})]\par
00200         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetCreationFlagDebugOnlyThisSuspended(IntPtr That, uint NewFlags);\par
00201 \par
00202         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_RequestDebugPriv"})]\par
00203        \par
00204         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} InsightProcess_RequestDebugPriv(IntPtr That, {\cf18 bool} NewMode);\par
00205 \par
00211         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetCreationFlags"})]\par
00212         {\cf17 public} {\cf17 static} {\cf17 extern} uint InsightProcess_GetCreationFlags(IntPtr That);\par
00213 \par
00214 \par
00215 \par
00216 \par
00217 \par
00223         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetWorkingDirectory"})]\par
00224         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetWorkingDirectory(IntPtr that, {\cf18 string} NewArgument);\par
00225 \par
00226 \par
00232         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetWorkingDirectory"})]\par
00233         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr PsProcessInformation_GetWorkingDirectory(IntPtr That);\par
00234 \par
00240 \par
00241         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetEnvInherit"})]\par
00242         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetInheritDefaultEnviroment(IntPtr That, {\cf18 bool} WantDefaultAlso);\par
00243 \par
00244 \par
00245         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_ClearEnvBlock"})]\par
00246         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_ClearExplicitEnviromentBlock(IntPtr That);\par
00247 \par
00248         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_AssignEnvValue"})]\par
00249         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetExplicitEnviromentValue(IntPtr That, {\cf18 string} Name, {\cf18 string} Value);\par
00250         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetEnvValue"})]\par
00251         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetExplicitEnviromentValue(IntPtr That, {\cf18 string} Name);\par
00252 \par
00253 \par
00254         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Ansi, EntryPoint = {\cf22 "InsightProcess_AddDetoursDllA"})]\par
00255         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} PsProcessInformation_AddDetourDllToLoad(IntPtr That, {\cf18 string} Name);\par
00256 \par
00257         {\cf20 // "InsightProcess_AddDetoursDllW" is not imported as the implementation just converts to ANSI before calling InsightProcess_AddDetoursDllA()}\par
00258         {\cf20 // the marshaling stuff will take care of that already.}\par
00259         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_ClearDetoursList"})]\par
00260         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_ClearDetourList(IntPtr That);\par
00261 \par
00262  \par
00263         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetDebugMode"})]\par
00264         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_SetDebugMode(IntPtr That, [MarshalAs(UnmanagedType.U4)] DebugModeType Ty);\par
00265 \par
00266         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetDebugMode"})]\par
00267         {\cf17 public} {\cf17 static} {\cf17 extern} DebugModeType InsightProcess_GetDebugMode(IntPtr That);\par
00268 \par
00269         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetDebugEventCallback"})]\par
00270         {\cf17 public} {\cf17 static} {\cf17 extern} Delegate InsightProcess_GetDebugCallbackRoutine(IntPtr that);\par
00271 \par
00272         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetDebugEventCallback"})]\par
00273         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_SetDebugCallbackRoutine(IntPtr that, [MarshalAs(UnmanagedType.FunctionPtr)] Delegate CallBack);\par
00274 \par
00275         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_PulseDebugThread"})]\par
00276         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_PulseDebugEvent(IntPtr that);\par
00277 \par
00278 \par
00279 \par
00280         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetMainThreadHandle"})]\par
00281         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetMainThreadHandle(IntPtr That);\par
00282 \par
00283         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetMainProcessHandle"})]\par
00284         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetMainProcessHandle(IntPtr That);\par
00285 \par
00286         \par
00287     \par
00288 \par
00289         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetCommandment"})]\par
00290         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} InsightProcess_GetCommandment(IntPtr That, uint Cmd);\par
00291 \par
00292 \par
00293         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_SetCommandment"})]\par
00294         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} InsightProcess_SetCommandment(IntPtr That, uint Cmd, {\cf18 bool} Enabled);\par
00295 \par
00296         \par
00297         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetMainProcessId"})]\par
00298         {\cf17 public} {\cf17 static} {\cf17 extern} uint InsightProcess_GetMainProcessId(IntPtr That);\par
00299 \par
00300         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "InsightProcess_GetMainThreadId"})]\par
00301         {\cf17 public} {\cf17 static} {\cf17 extern} DebugModeType InsightProcess_GetMainThreadId(IntPtr That);\par
00302 \par
00303 \par
00304         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_SetSymbolHandling"}, ExactSpelling = {\cf17 false})]\par
00305         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} InsightProcess_SetSymbolHandling(IntPtr That, {\cf18 bool} NewVal);\par
00306 \par
00307 \par
00308         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetSymbolHandling"}, ExactSpelling = {\cf17 false})]\par
00309         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} InsightProcess_GetSymbolHandling(IntPtr That);\par
00310 \par
00311         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetSymbolHandlerClass"}, ExactSpelling = {\cf17 false})]\par
00312         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_GetSymbolEngineClassPtr(IntPtr That);\par
00313 \par
00314         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_AddPriorityDllPathW"}, ExactSpelling = {\cf17 false}, CharSet= CharSet.Unicode)]\par
00315         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} InsightProcess_AddPriorityLoadLibraryPath(IntPtr that, {\cf18 string} NewLocation);\par
00316 \par
00317         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_GetPriorityDllPath_NumberOf"}, ExactSpelling = {\cf17 false})]\par
00318         {\cf17 public} {\cf17 static} {\cf17 extern} uint InsightProcess_GetProrityLoadLibraryPath_NumberOf(IntPtr that);\par
00319 \par
00320         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_IndexPriorityDllPath"}, ExactSpelling = {\cf17 false})]\par
00321         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr InsightProcess_IndexPriorityDllPath(IntPtr that, {\cf18 int} index);\par
00322 \par
00323         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "InsightProcess_ClearPriorityDllPath"}, ExactSpelling = {\cf17 false})]\par
00324         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} InsightProcess_ClearPriorityDllPath(IntPtr that);\par
00325 \par
00326 \par
00327 \par
00328 \par
00329 \par
00330     \}\par
00331 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/SymbolEngine/ApiVersionStructNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/SymbolEngine/ApiVersionStructNative.cs}
{\xe \v NativeImports/Debugging/SymbolEngine/ApiVersionStructNative.cs}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.DebugHelpApiVersionStructInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in DebugHelp_ApiVersionStruct }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ApiVersionStructNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/SymbolEngine/ApiVersionStructNative.cs}
{\xe \v NativeImports/Debugging/SymbolEngine/ApiVersionStructNative.cs}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.Win32Struct;\par
00008 {\cf17 using }InsightSheath.Debugging.SymbolEngine;\par
00009 {\cf17 namespace }InsightSheath.NativeImports\par
00010 \{\par
00011 \par
00015     {\cf17 internal} {\cf17 static} {\cf17 class }DebugHelpApiVersionStructInternal\par
00016     \{\par
00017         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugHelp_ApiVerionStruct_GetRevision"}, ExactSpelling = {\cf17 false})]\par
00018         {\cf17 public} {\cf17 static} {\cf17 extern} ushort DebugHelp_ApiVerion_GetRevision(IntPtr that);\par
00019         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugHelp_ApiVerionStruct_GetMajor"}, ExactSpelling = {\cf17 false})]\par
00020         {\cf17 public} {\cf17 static} {\cf17 extern} ushort DebugHelp_ApiVerion_GetMajor(IntPtr that);\par
00021         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "DebugHelp_ApiVerionStruct_GetMinor"}, ExactSpelling = {\cf17 false})]\par
00022         {\cf17 public} {\cf17 static} {\cf17 extern} ushort DebugHelp_ApiVerion_GetMinor(IntPtr that);\par
00023         {\cf20 /*}\par
00024 {\cf20         DebugHelp_ApiVerionStruct_GetMajor}\par
00025 {\cf20         DebugHelp_ApiVerionStruct_GetMinor}\par
00026 {\cf20 }\par
00027 {\cf20         DebugHelp_ApiVerionStruct_GetRevision}\par
00028 {\cf20         */}\par
00029     \}\par
00030 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/SymbolEngine/InsightHunterNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/SymbolEngine/InsightHunterNative.cs}
{\xe \v NativeImports/Debugging/SymbolEngine/InsightHunterNative.cs}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.InsightHunterInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in InsightHunter class }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightHunterNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/SymbolEngine/InsightHunterNative.cs}
{\xe \v NativeImports/Debugging/SymbolEngine/InsightHunterNative.cs}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Debugging.SymbolEngine;\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Collections.Generic;\par
00004 {\cf17 using }System.Linq;\par
00005 {\cf17 using }System.Runtime.InteropServices;\par
00006 {\cf17 using }System.Text;\par
00007 {\cf17 using }System.Threading.Tasks;\par
00008 {\cf17 using }static InsightSheath.Debugging.SymbolEngine.InsightHunter;\par
00009 \par
00010 \par
00011 {\cf17 namespace }InsightSheath.NativeImports\par
00012 \{\par
00016     {\cf17 internal} {\cf17 static} {\cf17 partial class }InsightHunterInternal\par
00017     \{\par
00023         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_GetImageHelpVersionData"}, ExactSpelling = {\cf17 false})]\par
00024       \par
00025         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr Insight_GetImageHelpVersionData(IntPtr That);\par
00026         {\cf20 //Insight_GetImageHelpVersionData}\par
00027 \par
00028         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_SetImageHelpCompatability"}, ExactSpelling = {\cf17 false})]\par
00029         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_SetImageHelpCompatability(IntPtr That, ushort Major, ushort Minor, ushort Revision);\par
00030             {\cf20 //Insight_SetImageHelpCompatability}\par
00031         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_LoadExeSymbolInfo"}, ExactSpelling = {\cf17 false})]\par
00032         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_LoadExeSymbolInfo(IntPtr That, IntPtr DebugEventPtr);\par
00033         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_LoadDllSymbolInfo"}, ExactSpelling = {\cf17 false})]\par
00034         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_LoadDllSymbolInfo(IntPtr That, IntPtr DebugEventPtr);\par
00035 \par
00036         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_UnLoadExeSymbolInfo"}, ExactSpelling = {\cf17 false})]\par
00037         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_UnLoadExeSymbolInfo(IntPtr That, IntPtr DebugEventPtr);\par
00038         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_SetParentWindow"}, ExactSpelling = {\cf17 false})]\par
00039         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_SetParentWindow(IntPtr that, IntPtr TargetWindow);\par
00040 \par
00041         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_GetThreadSync"}, ExactSpelling = {\cf17 false})]\par
00042         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_GetThreadSync(IntPtr That);\par
00043 \par
00044 \par
00045         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_SetThreadSync"}, ExactSpelling = {\cf17 false})]\par
00046         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_SetThreadSync(IntPtr That, {\cf18 bool} EnableSync);\par
00047 \par
00048         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_RefreshLoadedModules"}, ExactSpelling = {\cf17 false})]\par
00049         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_RefreshLoadedModules(IntPtr That);\par
00050 \par
00051 \par
00052         {\cf20 // BOOL WINAPI Insight_EnumerateLoadedSymbolsW(InsightHunter* that, wchar_t* Symbol, SymbolSearchCallback* Api)}\par
00053         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_EnumerateLoadedSymbolsW"}, ExactSpelling = {\cf17 false})]\par
00054         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_EnumerateLoadedSymbolsW(IntPtr That, {\cf18 string} SymbolSeardch,  InsightHunter_SymbolSearchCallBackRoutine DotNotCallback);\par
00055 \par
00056         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_GetSymbolOptions"}, ExactSpelling = {\cf17 false})]\par
00057         {\cf17 public} {\cf17 static} {\cf17 extern} SymbolOptionsFlags Insight_GetSymbolOptions(IntPtr That);\par
00058 \par
00059         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_GetSymbolOptions"}, ExactSpelling = {\cf17 false})]\par
00060         {\cf17 public} {\cf17 static} {\cf17 extern} SymbolOptionsFlags Insight_SetSymbolOptions(IntPtr That, SymbolOptionsFlags OptionMask);\par
00061 \par
00062         \par
00063         {\cf20 // BOOL WINAPI Insight_EnumerateLoadedSymbolsW(InsightHunter* that, wchar_t* Symbol, SymbolSearchCallback* Api)}\par
00064         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "Insight_EnumerateSourceFiles"}, ExactSpelling = {\cf17 false})]\par
00065         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Insight_EnumerateSourceFilesW(IntPtr That, {\cf18 string} SearchString, InsightHunter_SymbolSourceCallbackRoutine DotNotCallback);\par
00066 \par
00067     \}\par
00068 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/SymbolEngine/SymbolInfoNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/SymbolEngine/SymbolInfoNative.cs}
{\xe \v NativeImports/Debugging/SymbolEngine/SymbolInfoNative.cs}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.SymbolInfoInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in SymbolInfo class }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SymbolInfoNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/SymbolEngine/SymbolInfoNative.cs}
{\xe \v NativeImports/Debugging/SymbolEngine/SymbolInfoNative.cs}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 {\cf17 using }InsightSheath.Wrappers;\par
00008 {\cf17 using }InsightSheath.Debugging.SymbolEngine;\par
00009 \par
00010 {\cf17 namespace }InsightSheath.NativeImports\par
00011 \{\par
00015     {\cf17 internal} {\cf17 static} {\cf17 class }SymbolInfoInternal\par
00016     \{\par
00017         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetStructSize"}, ExactSpelling = {\cf17 false})]\par
00018         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetStructSize(IntPtr That);\par
00019 \par
00020         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetStructSize"}, ExactSpelling = {\cf17 false})]\par
00021         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetTypeIndex(IntPtr That);\par
00022 \par
00023         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetStructSize"}, ExactSpelling = {\cf17 false})]\par
00024         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetSymbolSize(IntPtr That);\par
00025 \par
00026 \par
00027         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetFlags"}, ExactSpelling = {\cf17 false})]\par
00028         {\cf17 public} {\cf17 static} {\cf17 extern} SymbolFlags SymbolInfo_GetFlags(IntPtr That);\par
00029 \par
00030 \par
00031         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetVal"}, ExactSpelling = {\cf17 false})]\par
00032         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetVal(IntPtr That);\par
00033 \par
00034 \par
00035 \par
00036         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetReg"}, ExactSpelling = {\cf17 false})]\par
00037         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetReg(IntPtr That);\par
00038 \par
00039 \par
00040 \par
00041         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetValOrReg"}, ExactSpelling = {\cf17 false})]\par
00042         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetValOrReg(IntPtr That);\par
00043 \par
00044 \par
00045 \par
00046         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetScope"}, ExactSpelling = {\cf17 false})]\par
00047         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetScope(IntPtr That);\par
00048 \par
00049 \par
00050 \par
00051         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetName"}, ExactSpelling = {\cf17 false})]\par
00052         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr SymbolInfo_GetName(IntPtr That);\par
00053 \par
00054 \par
00055 \par
00056         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetNameCharCount"}, ExactSpelling = {\cf17 false})]\par
00057         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetNameLemngth(IntPtr That);\par
00058 \par
00059 \par
00060 \par
00061         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetIndex"}, ExactSpelling = {\cf17 false})]\par
00062         {\cf17 public} {\cf17 static} {\cf17 extern} uint SymbolInfo_GetIndex(IntPtr That);\par
00063 \par
00064 \par
00065         \par
00066         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfoW_GetModBase"}, ExactSpelling = {\cf17 false})]\par
00067         {\cf17 public} {\cf17 static} {\cf17 extern} ulong SymbolInfo_GetModuleBase(IntPtr That);\par
00068 \par
00069         \par
00070 \par
00071 \par
00072 \par
00073         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "SymbolInfo_GetTagType"}, ExactSpelling = {\cf17 false})]\par
00074         {\cf17 public} {\cf17 static} {\cf17 extern} SymbolTagType SymbolInfo_GetTagType(IntPtr That);\par
00075 \par
00076 \par
00077     \}\par
00078 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Debugging/Thread/ThreadContextNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/Thread/ThreadContextNative.cs}
{\xe \v NativeImports/Debugging/Thread/ThreadContextNative.cs}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.ThreadContextInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in ThreadContext class }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ThreadContextNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Debugging/Thread/ThreadContextNative.cs}
{\xe \v NativeImports/Debugging/Thread/ThreadContextNative.cs}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Runtime.InteropServices.ComTypes;\par
00006 {\cf17 using }System.Text;\par
00007 {\cf17 using }System.Threading.Tasks;\par
00008 {\cf17 using }InsightSheath.Wrappers;\par
00009 {\cf17 using }InsightSheath.Debugging.Thread;\par
00010 \par
00011 {\cf17 namespace }InsightSheath.NativeImports\par
00012 \{\par
00016     {\cf17 internal} {\cf17 enum} ThreadConext_Arguments: uint\par
00017     \{\par
00018         UseHandle = 0,\par
00019         UseThreadId = 1\par
00020     \}\par
00021 \par
00025     {\cf17 static} {\cf17 class }ThreadContextInternal\par
00026     \{\par
00034         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetThreadDescriptionW"})]\par
00035         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_SetTheadDescriptionW(IntPtr That, [MarshalAs(UnmanagedType.LPWStr)] {\cf18 string} NewDescription);\par
00042         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadDescriptionW"})]\par
00043         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 string} ThreadContext_GetThreadDescriptionW(IntPtr that);\par
00044 \par
00052         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_CreateInstance"})]\par
00053         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_CreateInstance(ulong HandleOrThreadId, uint Flags);\par
00054 \par
00061         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_KillInstance"})]\par
00062         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_KillInstance(IntPtr That);\par
00063 \par
00064         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetTargetThread"})]\par
00065         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_SetTargetThread(IntPtr That, IntPtr HandleOfThread, ThreadConext_Arguments Flags);\par
00066 \par
00072         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetPriority"})]\par
00073         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 int} ThreadContext_GetPriority(IntPtr That);\par
00074 \par
00075         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetPriority"})]\par
00076         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_SetPriority(IntPtr That, {\cf18 int} NewPriority);\par
00077 \par
00078         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_DupInstance"})]\par
00079         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_DupInstance(IntPtr That);\par
00080 \par
00081 \par
00082         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadTimeCreationTime"})]\par
00083         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_GetThreadTimeCreationTime(IntPtr That);\par
00084 \par
00085         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadTimeExitTime"})]\par
00086         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_GetThreadTimeExitTime(IntPtr That);\par
00087 \par
00088         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadTimeUserTime"})]\par
00089         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_GetThreadTimeUserTime(IntPtr That);\par
00090 \par
00091         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadTimeKernelTime"})]\par
00092         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_GetThreadTimeKernelTime(IntPtr That);\par
00093 \par
00099         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetTargetThreadId"})]\par
00100         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_GetTargetThreadId(IntPtr That);\par
00101 \par
00102 \par
00103         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetIdealProcessor"})]\par
00104         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_GetIdealProcessor(IntPtr That);\par
00105 \par
00106         \par
00107         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetIdealProcessor"})]\par
00108         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_SetIdealProcessor(IntPtr That, uint NewIdealProcessor);\par
00109 \par
00110 \par
00111         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadPriorityBoostSetting"})]\par
00112         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_GetThreadPriorityBoostSetting(IntPtr That);\par
00113 \par
00114         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetThreadPriorityBoostSetting"})]\par
00115         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_SetThreadPriorityBoostSetting(IntPtr That, {\cf18 bool} EnablePriorityBoost);\par
00116 \par
00117         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetThreadProcessAffinityMask"})]\par
00118         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_GetThreadProcessAffinityMask(IntPtr That);\par
00119 \par
00120 \par
00121         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetThreadProcessAffinityMask"})]\par
00122         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_SetThreadProcessAffinityMask(IntPtr That, uint NewIdealProcessor);\par
00123 \par
00124         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SuspendThread"})]\par
00130         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_SuspendThread(IntPtr that);\par
00131 \par
00132         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_ResumeThread"})]\par
00138         {\cf17 public} {\cf17 static} {\cf17 extern} uint ThreadContext_ResumeThread(IntPtr that);\par
00139 \par
00140         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetContext"})]\par
00146         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_GetContext(IntPtr that);\par
00147 \par
00148 \par
00149         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetContext"})]\par
00156         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_SetContext(IntPtr that, IntPtr NewContext);\par
00157 \par
00158 \par
00159         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_GetWow64Context"})]\par
00165         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr ThreadContext_GetWow64Context(IntPtr that);\par
00166 \par
00167 \par
00168 \par
00169 \par
00170         [DllImport({\cf22 "InsightApi.Dll"}, BestFitMapping = {\cf17 false}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "ThreadContext_SetWow64Context"})]\par
00176         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} ThreadContext_SetWow64Context(IntPtr that, IntPtr NewContext);\par
00177 \par
00178 \par
00179 \par
00180     \}\par
00181 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/DetoursNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/DetoursNative.cs}
{\xe \v NativeImports/DetoursNative.cs}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.NativeMethods}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DetoursNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/DetoursNative.cs}
{\xe \v NativeImports/DetoursNative.cs}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.NativeImports\par
00009 \{\par
00010     {\cf17 internal} {\cf17 static} {\cf17 partial class }NativeMethods\par
00011     \{\par
00012         [DllImport({\cf22 "InsightApi.Dll"},CallingConvention= CallingConvention.Winapi, SetLastError ={\cf17 true},EntryPoint ={\cf22 "DetourEnumerateModulesEx"})]\par
00013         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DetourEnumerateModulesEx(IntPtr hProcess, IntPtr hModule);\par
00014     \}\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/ImageHlpNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/ImageHlpNative.cs}
{\xe \v NativeImports/ImageHlpNative.cs}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.NativeMethods}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ImageHlpNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/ImageHlpNative.cs}
{\xe \v NativeImports/ImageHlpNative.cs}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.NativeImports\par
00009 \{\par
00010     {\cf17 internal} {\cf17 static} {\cf17 partial class }NativeMethods\par
00011     \{\par
00012         [DllImport({\cf22 "InsightAPI.dll"},CallingConvention= CallingConvention.Winapi, EntryPoint = {\cf22 "ImageHlp_GetBaseOfImage"})]\par
00013         {\cf17 public} {\cf17 static} {\cf17 extern} ulong ImageHlp64_GetBaseOfImage(IntPtr ImageHlpModule64);\par
00014     \}\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/MemoryNativeInternal.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/MemoryNativeInternal.cs}
{\xe \v NativeImports/MemoryNativeInternal.cs}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.MemoryNativeInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. Imports the Poke/Peek routines for both remote and local }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MemoryNativeInternal.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/MemoryNativeInternal.cs}
{\xe \v NativeImports/MemoryNativeInternal.cs}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.NativeImports\par
00009 \{\par
00013     {\cf17 internal} {\cf17 static} {\cf17 class }MemoryNativeInternal\par
00014     \{\par
00020         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilPeek4"})]\par
00021         {\cf17 public} {\cf17 static} {\cf17 extern} uint Peek4(IntPtr NativePtr);\par
00022 \par
00029         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilPoke4"})]\par
00030         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr Poke4(IntPtr NativePtr, uint NewValue);\par
00031 \par
00037         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilPeek8"})]\par
00038         {\cf17 public} {\cf17 static} {\cf17 extern} ulong Peek8(IntPtr NativePtr);\par
00039 \par
00045         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilPoke8"})]\par
00046         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} Poke8(IntPtr NativePtr, ulong NewValue);\par
00047 \par
00048 \par
00049 \par
00057         [DllImport({\cf22 "InsightApi.dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "RemotePoke8"})]\par
00058         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} RemotePoke8(IntPtr ProcessHandle, ulong value, IntPtr remote_location);\par
00059 \par
00060 \par
00068         [DllImport({\cf22 "InsightApi.dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "RemotePoke4"})]\par
00069         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} RemotePoke4(IntPtr ProcessHandle, uint value, IntPtr remote_location);\par
00070 \par
00071 \par
00072 \par
00073     \}\par
00074 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/UtilityNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/UtilityNative.cs}
{\xe \v NativeImports/UtilityNative.cs}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.NativeMethods}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UtilityNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/UtilityNative.cs}
{\xe \v NativeImports/UtilityNative.cs}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.NativeImports\par
00009 \{\par
00010     {\cf17 internal} {\cf17 static} {\cf17 partial class }NativeMethods\par
00011     \{\par
00018         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention=CallingConvention.Winapi, EntryPoint ={\cf22 "UtilGetModuleNameViaHandle"})]\par
00019         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr GetModuleNameViaHandleInternal(IntPtr ProcessHandle, IntPtr ModuleHandle);\par
00020 \par
00027         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilFreeModuleNameViaHandle"})]\par
00028         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} FreeModuleNameViaHandleInternal(IntPtr NativeStringPtr);\par
00029 \par
00035         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilGetFileNameViaHandle"})]\par
00036         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr GetFileNameViaHandle(IntPtr FileHandle);\par
00037 \par
00038 \par
00045         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilFreeFileNameViaHandle"})]\par
00046         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} FreeFileNameViaHandleInternal(IntPtr NativeStringPtr);\par
00047 \par
00057         [DllImport({\cf22 "InsightApi.dll"}, EntryPoint = {\cf22 "UtilDuplicateHandleIntoTarget"}, CallingConvention= CallingConvention.Winapi,SetLastError ={\cf17 true})]\par
00058         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr DuplicateHandleIntoTarget(IntPtr CurrentHandle, UInt32 Access, {\cf18 bool} CopyAccess, IntPtr TargetProcess, {\cf18 bool} Inherit);\par
00059 \par
00060 \par
00061 \par
00062         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilGetPEMachineTypeW"})]\par
00063         {\cf17 public} {\cf17 static} {\cf17 extern} MachineType GetPEMachineType([MarshalAs(UnmanagedType.LPWStr)]{\cf18 string} Str);\par
00064         \par
00070 \par
00071         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilOpenProcessForMemory"})]\par
00072         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr OpenProcessForMemoryAccess(uint ProcessID);\par
00073 \par
00074         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilOpenProcesForQueryInformation"})]\par
00075         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr OpenProcesForQueryInformation(uint ProcessID);\par
00076 \par
00077         \par
00083         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "OpenProcessNow"})]\par
00084         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr OpenProcessNow(uint ProcessID);\par
00090         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "UtilOpenProcessForDuplicatingHandle"})]\par
00091         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr OpenProcessForDuplicatingHandle(uint ProcessID);\par
00092 \par
00099         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, EntryPoint = {\cf22 "RemoteRead_SimpleFree"})]\par
00100         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr SimpleFree(IntPtr NativeStringPtr);\par
00101 \par
00102 \par
00108         [DllImport({\cf22 "kernel32.dll"}, CallingConvention=CallingConvention.Winapi)]\par
00109         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} CloseHandle(IntPtr Handle);\par
00110     \}\par
00111 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Win32Struct/Remote/RemoteStructureNatives.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Win32Struct/Remote/RemoteStructureNatives.cs}
{\xe \v NativeImports/Win32Struct/Remote/RemoteStructureNatives.cs}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.RemoteStructureInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in RemoteStructure class exports }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RemoteStructureNatives.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Win32Struct/Remote/RemoteStructureNatives.cs}
{\xe \v NativeImports/Win32Struct/Remote/RemoteStructureNatives.cs}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.Win32Struct;\par
00008 {\cf17 using }InsightSheath.Win32Struct.Remote;\par
00009 {\cf17 namespace }InsightSheath.NativeImports\par
00010 \{\par
00014     {\cf17 static} {\cf17 class }RemoteStructureInternal\par
00015     \{\par
00023         [DllImport({\cf22 "InsightApi.dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "RemoteReadUnicodeString"})]\par
00024         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr RemoteReadUnicodeString(IntPtr ProcessHandle, IntPtr RemoteLocation, {\cf18 bool} TargetIs32Bit);\par
00025 \par
00026     \par
00033         [DllImport({\cf22 "InsightApi.dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "RemoteFreeUnicodeString"})]\par
00034         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr RemoteFreeUnicodeString(IntPtr RemoteLocation, {\cf18 bool} TargetIs32Bit);\par
00035 \par
00041         {\cf17 public} {\cf17 static} IntPtr RemoteFreeUnicodeString(IntPtr RemoteLocation)\par
00042         \{\par
00043             {\cf19 return} RemoteFreeUnicodeString(RemoteLocation, {\cf17 false});\par
00044         \}\par
00045 \par
00046 \par
00047         [DllImport({\cf22 "InsightApi.dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "RemoteReadObjectAttributes"})]\par
00048         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr RemoteReadObjectAttributes(IntPtr ProcessHandle, IntPtr RemoteLocation, {\cf18 bool} TargetIs32Bit);\par
00049 \par
00050         [DllImport({\cf22 "InsightApi.dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "RemoteFreeObjectAttributes"})]\par
00051         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} RemoteFreeObjectAttributes(IntPtr RemoteLocation, {\cf18 bool} TargetIs32Bit);\par
00052 \par
00053 \par
00054 \par
00055 \par
00063         [DllImport({\cf22 "InsightApi.dll"},CallingConvention= CallingConvention.Winapi, CharSet= CharSet.Unicode, EntryPoint = {\cf22 "RemoteReadStringW"}, SetLastError ={\cf17 true})]\par
00064         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr RemoteReadStringInternal(IntPtr ProcessHandle, IntPtr RemoteLocation, ulong char_count);\par
00071         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "RemoteReadDebugString"})]\par
00072         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr RemoteReadDebugStringInternal(IntPtr ProcessHandle, IntPtr DebugEventPtr);\par
00073 \par
00078         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "RemoteFreeDebugString"})]\par
00079         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 void} RemoteFreeDebugStringInternal(IntPtr Memory);\par
00080 \par
00081         {\cf20 //  VOID* WINAPI RemoteReadPointer(HANDLE Process, VOID* Target, DWORD pointerSize)}\par
00082 \par
00090         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode, EntryPoint = {\cf22 "RemoteReadPointer"})]\par
00091         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr RemoteReadPointer(IntPtr TargetProcess, IntPtr TargetLocation, uint PointerSize);\par
00092     \}\par
00093 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NativeImports/Win32Struct/StartupInfoExWNative.cs File Reference\par \pard\plain 
{\tc\tcl2 \v NativeImports/Win32Struct/StartupInfoExWNative.cs}
{\xe \v NativeImports/Win32Struct/StartupInfoExWNative.cs}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.NativeImports.StartupInfoExWInternal}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal Class. This imports the routines used in StartupInfoExW class. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.NativeImports}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StartupInfoExWNative.cs\par \pard\plain 
{\tc\tcl2 \v NativeImports/Win32Struct/StartupInfoExWNative.cs}
{\xe \v NativeImports/Win32Struct/StartupInfoExWNative.cs}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath.Win32Struct;\par
00008 {\cf17 namespace }InsightSheath.NativeImports\par
00009 \{\par
00013     {\cf17 internal} {\cf17 static} {\cf17 class }StartupInfoExWInternal\par
00014     \{\par
00015         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_MakeInstance"})]\par
00016         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfoWrapper_MakeInstance();\par
00017 \par
00018         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_DupInstance"})]\par
00019         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfoWrapper_DuplicateInstance(IntPtr Native);\par
00020 \par
00021 \par
00022         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_DeleteInstance"})]\par
00023         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_DeleteInstance(IntPtr Native);\par
00024 \par
00025         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetlpDesktopW"})]\par
00026         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfoWrapper_GetDesktop(IntPtr Native);\par
00027 \par
00028         [DllImport({\cf22 "InsightApi.Dll"}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetlpDesktopW"})]\par
00029         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfoWrapper_SetDesktop(IntPtr Native, {\cf18 string} Desktop);\par
00030 \par
00031 \par
00032         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupUpInfo_GetlpTitleW"})]\par
00033         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfoWrapper_GetTitle(IntPtr Native);\par
00034 \par
00035         [DllImport({\cf22 "InsightApi.Dll"}, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartUpInfo_SetlpTitleW"})]\par
00036         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfoWrapper_SetTitle(IntPtr Native, {\cf18 string} Title);\par
00037 \par
00038 \par
00039         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwX"})]\par
00040         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfoWrapper_GetdwX(IntPtr Native);\par
00041         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwX"})]\par
00042         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_SetdwX(IntPtr Native, uint dwX);\par
00043 \par
00044         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwY"})]\par
00045         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfoWrapper_GetdwY(IntPtr Native);\par
00046         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwY"})]\par
00047         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_SetdwY(IntPtr Native, uint dwY);\par
00048 \par
00049 \par
00050 \par
00051         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwXCountChars"})]\par
00052         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfoWrapper_GetdwXCountChars(IntPtr Native);\par
00053         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwXCountChars"})]\par
00054         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_SetdwXCountChars(IntPtr Native, uint dwX);\par
00055 \par
00056 \par
00057         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwYSize"})]\par
00058         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfoWrapper_GetYSize(IntPtr Native);\par
00059         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwYSize"})]\par
00060         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_SetYSize(IntPtr Native, uint dwY);\par
00061 \par
00062 \par
00063 \par
00064         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwXSize"})]\par
00065         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfoWrapper_GetXSize(IntPtr Native);\par
00066         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwXSize"})]\par
00067         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_SetXSize(IntPtr Native, uint dwY);\par
00068 \par
00069 \par
00070 \par
00071 \par
00072 \par
00073         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwYCountChars"})]\par
00074         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfoWrapper_GetdwYCountChars(IntPtr Native);\par
00075         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwYCountChars"})]\par
00076         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfoWrapper_SetdwYCountChars(IntPtr Native, uint dwY);\par
00077 \par
00078         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwFillAttributes"})]\par
00079         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfo_GetdwFillAttributes(IntPtr Native);\par
00080         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwFillAttribute"})]\par
00081         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfo_SetdwFillAttribute(IntPtr Native, uint dwAttributes);\par
00082 \par
00083 \par
00084         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetdwFlags"})]\par
00085         {\cf17 public} {\cf17 static} {\cf17 extern} uint StartupInfo_GetdwFlags(IntPtr Native);\par
00086         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetdwFlags"})]\par
00087         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfo_SetdwFlags(IntPtr Native, uint dwFlags);\par
00088 \par
00089 \par
00090         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GetwShowWindow"})]\par
00091         {\cf17 public} {\cf17 static} {\cf17 extern} ushort StartupInfo_GetShowWindow(IntPtr Native);\par
00092         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SetwShowWindow"})]\par
00093         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfo_SetShowWindow(IntPtr Native, ushort ShowWindowAttr);\par
00094 \par
00095 \par
00096 \par
00097 \par
00098         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GethStdInput"})]\par
00099         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfo_GetStdInput(IntPtr Native);\par
00100         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SethStdInput"})]\par
00101         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfo_SetStdInput(IntPtr Native, IntPtr NewHandle);\par
00102 \par
00103         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GethStdOutput"})]\par
00104         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfo_GetStdOutput(IntPtr Native);\par
00105         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SethStdOutput"})]\par
00106         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfo_SetStdOutput(IntPtr Native, IntPtr NewHandle);\par
00107 \par
00108 \par
00109 \par
00110         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_GethStdError"})]\par
00111         {\cf17 public} {\cf17 static} {\cf17 extern} IntPtr StartupInfo_GetStdError(IntPtr Native);\par
00112         [DllImport({\cf22 "InsightApi.Dll"}, CallingConvention = CallingConvention.Winapi, SetLastError = {\cf17 true}, EntryPoint = {\cf22 "StartupInfo_SethStdError"})]\par
00113         {\cf17 public} {\cf17 static} {\cf17 extern} {\cf18 bool} StartupInfo_SetStdError(IntPtr Native, IntPtr NewHandle);\par
00114 \par
00115 \par
00116 \par
00117 \par
00118 \par
00119 \par
00120 \par
00121     \}\par
00122 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
.NETCoreApp,Version=v5.0.AssemblyAttributes.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // <autogenerated />}\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Reflection;\par
00004 [assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute({\cf22 ".NETCoreApp,Version=v5.0"}, FrameworkDisplayName = {\cf22 ""})]\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debug64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debug64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Debug64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
.NETCoreApp,Version=v5.0.AssemblyAttributes.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debug64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Debug64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // <autogenerated />}\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Reflection;\par
00004 [assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute({\cf22 ".NETCoreApp,Version=v5.0"}, FrameworkDisplayName = {\cf22 ""})]\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debugx64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debugx64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Debugx64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
.NETCoreApp,Version=v5.0.AssemblyAttributes.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debugx64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Debugx64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // <autogenerated />}\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Reflection;\par
00004 [assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute({\cf22 ".NETCoreApp,Version=v5.0"}, FrameworkDisplayName = {\cf22 ""})]\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Release/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Release/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Release/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
.NETCoreApp,Version=v5.0.AssemblyAttributes.cs\par \pard\plain 
{\tc\tcl2 \v obj/Release/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Release/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // <autogenerated />}\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Reflection;\par
00004 [assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute({\cf22 ".NETCoreApp,Version=v5.0"}, FrameworkDisplayName = {\cf22 ""})]\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Release64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Release64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Release64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
.NETCoreApp,Version=v5.0.AssemblyAttributes.cs\par \pard\plain 
{\tc\tcl2 \v obj/Release64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\xe \v obj/Release64/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // <autogenerated />}\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Reflection;\par
00004 [assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute({\cf22 ".NETCoreApp,Version=v5.0"}, FrameworkDisplayName = {\cf22 ""})]\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debug/net5.0/FileSandBoxSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debug/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\xe \v obj/Debug/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileSandBoxSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debug/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\xe \v obj/Debug/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "FileSandBoxSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Debug"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "FileSandBoxSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "FileSandBoxSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Release/net5.0/FileSandBoxSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Release/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\xe \v obj/Release/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileSandBoxSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Release/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\xe \v obj/Release/net5.0/FileSandBoxSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "FileSandBoxSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Release"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "FileSandBoxSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "FileSandBoxSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debug/net5.0/InsightSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debug/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Debug/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debug/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Debug/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "InsightSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Debug"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "InsightSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "InsightSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debug64/net5.0/InsightSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debug64/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Debug64/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debug64/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Debug64/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "InsightSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Debug64"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "InsightSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "InsightSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Debugx64/net5.0/InsightSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Debugx64/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Debugx64/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Debugx64/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Debugx64/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "InsightSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Debugx64"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "InsightSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "InsightSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Release/net5.0/InsightSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Release/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Release/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Release/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Release/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "InsightSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Release"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "InsightSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "InsightSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
obj/Release64/net5.0/InsightSheath.AssemblyInfo.cs File Reference\par \pard\plain 
{\tc\tcl2 \v obj/Release64/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Release64/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InsightSheath.AssemblyInfo.cs\par \pard\plain 
{\tc\tcl2 \v obj/Release64/net5.0/InsightSheath.AssemblyInfo.cs}
{\xe \v obj/Release64/net5.0/InsightSheath.AssemblyInfo.cs}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //------------------------------------------------------------------------------}\par
00002 {\cf20 // <auto-generated>}\par
00003 {\cf20 //     This code was generated by a tool.}\par
00004 {\cf20 //     Runtime Version:4.0.30319.42000}\par
00005 {\cf20 //}\par
00006 {\cf20 //     Changes to this file may cause incorrect behavior and will be lost if}\par
00007 {\cf20 //     the code is regenerated.}\par
00008 {\cf20 // </auto-generated>}\par
00009 {\cf20 //------------------------------------------------------------------------------}\par
00010 \par
00011 {\cf17 using }System;\par
00012 {\cf17 using }System.Reflection;\par
00013 \par
00014 [assembly: System.Reflection.AssemblyCompanyAttribute({\cf22 "InsightSheath"})]\par
00015 [assembly: System.Reflection.AssemblyConfigurationAttribute({\cf22 "Release64"})]\par
00016 [assembly: System.Reflection.AssemblyFileVersionAttribute({\cf22 "1.0.0.0"})]\par
00017 [assembly: System.Reflection.AssemblyInformationalVersionAttribute({\cf22 "1.0.0"})]\par
00018 [assembly: System.Reflection.AssemblyProductAttribute({\cf22 "InsightSheath"})]\par
00019 [assembly: System.Reflection.AssemblyTitleAttribute({\cf22 "InsightSheath"})]\par
00020 [assembly: System.Reflection.AssemblyVersionAttribute({\cf22 "1.0.0.0"})]\par
00021 \par
00022 {\cf20 // Generated by the MSBuild WriteCodeFragment class.}\par
00023 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Telemetry/AntiDebuggerReader.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Telemetry/AntiDebuggerReader.cs}
{\xe \v Telemetry/AntiDebuggerReader.cs}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.CheckRemoteDebuggerPresentSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.AntiDebuggerReaderExtensions}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class includes code to read exceptions generated via the AntiDebugger telemetry. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.AntiDebuggerReaderExtentionCheckers}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class includes extentions to check if the exception in the DebugEvent is the correct type }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Telemetry}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AntiDebuggerReader.cs\par \pard\plain 
{\tc\tcl2 \v Telemetry/AntiDebuggerReader.cs}
{\xe \v Telemetry/AntiDebuggerReader.cs}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }InsightSheath.Wrappers;\par
00007 {\cf17 using }InsightSheath.Debugging;\par
00008 \par
00009 {\cf17 namespace }InsightSheath.Telemetry\par
00010 \{\par
00011 \par
00012     {\cf17 public} {\cf17 class }CheckRemoteDebuggerPresentSettings : GeneralTelemtryHelperStruct\par
00013     \{\par
00014 \par
00018         {\cf17 public} IntPtr ReturnValue;\par
00019 \par
00023         {\cf17 public} IntPtr Process;\par
00027         {\cf17 public} IntPtr OutputBool\par
00028         \{\par
00029             {\cf17 get}\par
00030             \{\par
00031                 {\cf19 return} ForceHandlePtr;\par
00032             \}\par
00033         \}\par
00034 \par
00035         \par
00036         {\cf17 public} CheckRemoteDebuggerPresentSettings(uint ProcessId, uint ThreadID, IntPtr Forcehandle, IntPtr LastError, MachineType Type) : base(ProcessId, ThreadID, Forcehandle, LastError, Type)\par
00037         \{\par
00038             \par
00039         \}\par
00040     \}\par
00041 \par
00045     {\cf17 public} {\cf17 static} {\cf17 class }AntiDebuggerReaderExtensions\par
00046     \{\par
00050         {\cf17 public} {\cf17 static} readonly uint FixedExceptionCode = 0x68ACB7AA;\par
00051         {\cf17 public} {\cf17 enum} NotificationType\par
00052         \{\par
00053             IsDebuggerPresent = 0,\par
00054             CheckRemoteDebuggerPresent = 1,\par
00055             NtCreateThreadEx = 2,\par
00056             NtQueryThreadInfo = 3,\par
00057             NtSetThreadInfo = 4\par
00058         \}\par
00059 \par
00060         {\cf17 const} uint CheckRemoteDebug_ProcessHandle = 2;\par
00061         {\cf17 const} uint CheckRemoteDebug_OutputBool = 3;\par
00062         {\cf17 const} uint CheckRemoteDebug_ReturnValue = 4;\par
00063 \par
00064 \par
00065         {\cf17 public} {\cf17 static} NotificationType GetAntiDebugNotificationType({\cf17 this} DebugEventExceptionInfo that)\par
00066         \{\par
00067             {\cf19 return} (NotificationType)that.ExceptionParameter64[GeneralTelemetry.ExceptionSubType];\par
00068         \}\par
00069 \par
00070         {\cf17 public} {\cf17 static} CheckRemoteDebuggerPresentSettings GetCheckRemoteDebuggerPresentSettings({\cf17 this} DebugEventExceptionInfo that)\par
00071         \{\par
00072             CheckRemoteDebuggerPresentSettings ret;\par
00073             var Args = that.ExceptionParameter64;\par
00074             MachineType Type;\par
00075             {\cf19 if} (that.IsEventFrom32BitProcess)\par
00076             \{\par
00077                 Type = MachineType.MachineI386;\par
00078             \}\par
00079             {\cf19 else}\par
00080             \{\par
00081                 Type = MachineType.MachineAmd64;\par
00082             \}\par
00083             ret = {\cf17 new} CheckRemoteDebuggerPresentSettings(that.ProcessID, that.ThreadID, {\cf17 new} IntPtr(({\cf18 long})Args[CheckRemoteDebug_OutputBool]), {\cf17 new} IntPtr( GeneralTelemetry.LastError_Ptr), Type  );\par
00084             {\cf19 return} ret;\par
00085         \}\par
00086     \}\par
00087 \par
00091     {\cf17 public} {\cf17 static} {\cf17 class }AntiDebuggerReaderExtentionCheckers\par
00092     \{\par
00093         \par
00094 \par
00095         {\cf17 public} {\cf17 static} {\cf18 bool} IsAntiDebuggerTelemetryException({\cf17 this} DebugEvent that)\par
00096         \{\par
00097             {\cf19 if} (that.EventType == DebugEventType.ExceptionEvent)\par
00098             \{\par
00099                 {\cf19 if} ((uint)that.GetDebugEventExceptionInfo().ExceptionCode == AntiDebuggerReaderExtensions.FixedExceptionCode)\par
00100                 \{\par
00101                     {\cf19 return} {\cf17 true};\par
00102                 \}\par
00103             \}\par
00104             {\cf19 return} {\cf17 false};\par
00105         \}\par
00106 \par
00107         {\cf17 public} {\cf17 static} {\cf18 bool} IsAntiDebuggerTelemetryException({\cf17 this} DebugEventExceptionInfo that)\par
00108         \{\par
00109             {\cf19 if} (that.EventType == DebugEventType.ExceptionEvent)\par
00110             \{\par
00111                 {\cf19 if} ((uint)that.ExceptionCode == AntiDebuggerReaderExtensions.FixedExceptionCode)\par
00112                 \{\par
00113                     {\cf19 return} {\cf17 true};\par
00114                 \}\par
00115             \}\par
00116             {\cf19 return} {\cf17 false};\par
00117         \}\par
00118 \par
00119     \}\par
00120 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Telemetry/GeneralTelemetry.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Telemetry/GeneralTelemetry.cs}
{\xe \v Telemetry/GeneralTelemetry.cs}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.GeneralTelemetry}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
holds some common defines between the included telemetry projects. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.GeneralTelemtryHelperStruct}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General common values/code between the telemetry reader code. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Telemetry}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GeneralTelemetry.cs\par \pard\plain 
{\tc\tcl2 \v Telemetry/GeneralTelemetry.cs}
{\xe \v Telemetry/GeneralTelemetry.cs}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Win32Struct.Remote;\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Collections.Generic;\par
00004 {\cf17 using }System.Linq;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 {\cf17 using }InsightSheath;\par
00008 \par
00009 {\cf17 namespace }InsightSheath.Telemetry\par
00010 \{\par
00014     {\cf17 internal} {\cf17 static} {\cf17 class }GeneralTelemetry\par
00015     \{\par
00019         {\cf17 public} {\cf17 const} uint ExceptionSubType = 0;\par
00023         {\cf17 public} {\cf17 const} uint LastError_Ptr = 1;\par
00024     \}\par
00025 \par
00029     {\cf17 public} {\cf17 abstract} {\cf17 class }GeneralTelemtryHelperStruct\par
00030     \{\par
00031         {\cf17 public} GeneralTelemtryHelperStruct(uint ProcessId, uint ThreadID, IntPtr ForceHandle, IntPtr LastError, MachineType Type)\par
00032         \{\par
00033             this.ProcessId = ProcessId;\par
00034             ThreadId = ThreadID;\par
00035             ForceHandlePtr = ForceHandle;\par
00036             LastErrorPtr = LastError;\par
00037             this.Type = Type;\par
00038         \}\par
00042         {\cf17 public} readonly MachineType Type;\par
00043 \par
00047         {\cf17 public} readonly uint ProcessId;\par
00051         {\cf17 public} readonly uint ThreadId;\par
00055         {\cf17 public} readonly IntPtr ForceHandlePtr;\par
00059         {\cf17 public} readonly IntPtr LastErrorPtr;\par
00060 \par
00061 \par
00066         {\cf17 public} {\cf18 void} SetForceHandle(IntPtr ReplacementHandle)\par
00067         \{\par
00068             {\cf20 //IntPtr handle = NativeImports.NativeMethods.OpenProcessNow(dwProcessId);}\par
00069             IntPtr handle = HelperRoutines.OpenProcessForHandleDuplicating(ProcessId);\par
00070             {\cf19 try}\par
00071             \{\par
00072                 {\cf20 /* Caution. This code is size Dependant on knowing the target's handle size*/}\par
00073                 {\cf19 if} (Type == MachineType.MachineI386) {\cf20 /* 4 byte pointer / handle size*/}\par
00074                 \{\par
00075                     {\cf20 //if ((uint)ReplacementHandle.ToInt32() != InvalidHandleValue32)}\par
00076                     {\cf19 if} ((uint)ReplacementHandle.ToInt32() != Int32.MaxValue)\par
00077                     \{\par
00078                         IntPtr duphandle = NativeImports.NativeMethods.DuplicateHandleIntoTarget(ReplacementHandle, 0, {\cf17 true}, handle, {\cf17 true});\par
00079                         MemoryNative.RemotePoke4(handle, (uint)duphandle.ToInt32(), ForceHandlePtr);\par
00080                     \}\par
00081                     {\cf19 else}\par
00082                     \{\par
00083                         {\cf20 //RemoteStructure.RemotePoke4(handle, InvalidHandleValue32, ForceHandlePtr);}\par
00084                         MemoryNative.RemotePoke4(handle, Int32.MaxValue, ForceHandlePtr);\par
00085                     \}\par
00086                 \}\par
00087                 {\cf19 else} {\cf20 /* 8 byte pointer / handle size */}\par
00088                 \{\par
00089                     {\cf20 //if ((ulong)ReplacementHandle.ToInt64() != InvalidHandleValue64)}\par
00090                     {\cf19 if} ((ulong)ReplacementHandle.ToInt64() != Int64.MaxValue)\par
00091                     \{\par
00092                         IntPtr duphandle = NativeImports.NativeMethods.DuplicateHandleIntoTarget(ReplacementHandle, 0, {\cf17 true}, handle, {\cf17 true});\par
00093                         MemoryNative.RemotePoke8(handle, (ulong)duphandle.ToInt64(), ForceHandlePtr);\par
00094                     \}\par
00095                     {\cf19 else}\par
00096                     \{\par
00097                         {\cf20 //RemoteStructure.RemotePoke8(handle, InvalidHandleValue64, ForceHandlePtr);}\par
00098                         MemoryNative.RemotePoke8(handle, {\cf18 int}.MaxValue, ForceHandlePtr);\par
00099                     \}\par
00100                 \}\par
00101 \par
00102 \par
00103             \}\par
00104             {\cf19 finally}\par
00105             \{\par
00106                 HelperRoutines.CloseHandle(handle);\par
00107             \}\par
00108         \}\par
00109 \par
00110 \par
00114         {\cf17 public} {\cf18 void} SetForceHandle()\par
00115         \{\par
00116             {\cf19 if} (Type == MachineType.MachineI386)\par
00117             \{\par
00118                 SetForceHandle(0xffffffff);\par
00119             \}\par
00120             {\cf19 else}\par
00121             \{\par
00122                 SetForceHandle(0xffffffffffffffff);\par
00123             \}\par
00124         \}\par
00129         {\cf17 public} {\cf18 void} SetForceHandle(ulong HandleValue)\par
00130         \{\par
00131             IntPtr handle = HelperRoutines.OpenProcessForHandleDuplicating(ProcessId);\par
00132             {\cf19 try}\par
00133             \{\par
00134                 {\cf20 //if (HandleValue != InvalidHandleValue64)}\par
00135                 {\cf19 if} (HandleValue != ulong.MaxValue)\par
00136                 \{\par
00137                     IntPtr duphandle = NativeImports.NativeMethods.DuplicateHandleIntoTarget({\cf17 new} IntPtr(({\cf18 long})HandleValue), 0, {\cf17 true}, handle, {\cf17 true});\par
00138                     MemoryNative.RemotePoke8(handle, (ulong)duphandle.ToInt64(), ForceHandlePtr);\par
00139                 \}\par
00140                 {\cf19 else}\par
00141                 \{\par
00142                     {\cf20 //RemoteStructure.RemotePoke8(handle, InvalidHandleValue64, ForceHandlePtr);}\par
00143                     MemoryNative.RemotePoke8(handle, ulong.MaxValue, ForceHandlePtr);\par
00144                 \}\par
00145 \par
00146 \par
00147             \}\par
00148             {\cf19 finally}\par
00149             \{\par
00150                 HelperRoutines.CloseHandle(handle);\par
00151             \}\par
00152         \}\par
00153 \par
00154 \par
00159         {\cf17 public} {\cf18 void} SetForceHandle(uint HandleValue)\par
00160         \{\par
00161             IntPtr handle = HelperRoutines.OpenProcessForHandleDuplicating(ProcessId);\par
00162             {\cf19 try}\par
00163             \{\par
00164                 {\cf20 //if (HandleValue != InvalidHandleValue32)}\par
00165                 {\cf19 if} (HandleValue != Int32.MaxValue)\par
00166                 \{\par
00167                     IntPtr duphandle = NativeImports.NativeMethods.DuplicateHandleIntoTarget({\cf17 new} IntPtr(HandleValue), 0, {\cf17 true}, handle, {\cf17 true});\par
00168                     MemoryNative.RemotePoke4(handle, (uint)duphandle.ToInt32(), ForceHandlePtr);\par
00169                 \}\par
00170                 {\cf19 else}\par
00171                 \{\par
00172                     {\cf20 //RemoteStructure.RemotePoke4(handle, InvalidHandleValue32, ForceHandlePtr);}\par
00173                     MemoryNative.RemotePoke4(handle, Int32.MaxValue, ForceHandlePtr);\par
00174                 \}\par
00175 \par
00176 \par
00177             \}\par
00178             {\cf19 finally}\par
00179             \{\par
00180                 HelperRoutines.CloseHandle(handle);\par
00181             \}\par
00182         \}\par
00183 \par
00184 \par
00185 \par
00186 \par
00191         {\cf17 public} {\cf18 void} SetLastErrorValue(uint NewValue)\par
00192         \{\par
00193             IntPtr handle = NativeImports.NativeMethods.OpenProcessForMemoryAccess(ProcessId);\par
00194             {\cf19 try}\par
00195             \{\par
00196                 MemoryNative.RemotePoke4(handle, NewValue, LastErrorPtr);\par
00197             \}\par
00198             {\cf19 finally}\par
00199             \{\par
00200                 HelperRoutines.CloseHandle(handle);\par
00201             \}\par
00202         \}\par
00203 \par
00204 \par
00205     \}\par
00206 \par
00207 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Telemetry/GenericTelemetryException.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Telemetry/GenericTelemetryException.cs}
{\xe \v Telemetry/GenericTelemetryException.cs}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.GenericTelemetryException}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Telemetry}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GenericTelemetryException.cs\par \pard\plain 
{\tc\tcl2 \v Telemetry/GenericTelemetryException.cs}
{\xe \v Telemetry/GenericTelemetryException.cs}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 \par
00007 {\cf17 namespace }InsightSheath.Telemetry\par
00008 \{\par
00009     {\cf17 public} {\cf17 abstract} {\cf17 class }GenericTelemetryException\par
00010     \{\par
00011     \}\par
00012 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Telemetry/IoDeviceTelemetryReader.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Telemetry/IoDeviceTelemetryReader.cs}
{\xe \v Telemetry/IoDeviceTelemetryReader.cs}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Telemetry.LARGE_INTEGER}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Large structure for getting {\b LARGE_INTEGER} structs into .Net Hands }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.IoDeviceTelememtryExceptionCommonValues}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.IoDeviceTelemetryExceptionExtensionsCheckers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.IoDeviceTelemetryNtCreateFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.IoDeviceTelemetyCreateFile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This structure contains data from an exception generated via CreateFileA/W. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Telemetry.IoDeviceTelemetryReaderExtensions}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An Exception from the debug event struct that was generated via the IoException {\b Telemetry} DLL. This class should contain code to read exceptions generated from telemetry dll IoDeviceTelemetry }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Telemetry}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Telemetry.NtCreationDisposition} : uint \{ {\b InsightSheath.Telemetry.Supersede} = 0x00000000
, {\b InsightSheath.Telemetry.Open} = 0x00000001
, {\b InsightSheath.Telemetry.Create} = 0x00000002
, {\b InsightSheath.Telemetry.OpenIf} = 0x00000003
, {\b InsightSheath.Telemetry.Overwrite} = 0x00000004
, {\b InsightSheath.Telemetry.OverwriteIf} = 0x00000005
, {\b InsightSheath.Telemetry.MaxDisposition} = 0x00000005
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
From once again winnt.h for values.  }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Telemetry.CreationDisposition} : uint \{ {\b InsightSheath.Telemetry.CreateNew} = 1
, {\b InsightSheath.Telemetry.CreateAlways} = 2
, {\b InsightSheath.Telemetry.OpenExisting} = 3
, {\b InsightSheath.Telemetry.OpenAlways} = 4
, {\b InsightSheath.Telemetry.TruncateExisting} = 5
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Action to be taken by CreateFileA/W }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Telemetry.AccessMasks} : uint \{ {\b InsightSheath.Telemetry.NoAccess} = 0
, {\b InsightSheath.Telemetry.MetaData} = NoAccess
, {\b InsightSheath.Telemetry.Delete} = 0x00010000
, {\b InsightSheath.Telemetry.ReadControl} = 0x00020000
, {\b InsightSheath.Telemetry.FileReadData} = 0x1
, {\b InsightSheath.Telemetry.FileListDirectory} = FileReadData
, {\b InsightSheath.Telemetry.FileReadAttributes} = 0x0080
, {\b InsightSheath.Telemetry.FileReadEa} = 0x0008
, {\b InsightSheath.Telemetry.FileWriteData} = 0x0002
, {\b InsightSheath.Telemetry.FileWriteAttributes} = 0x0100
, {\b InsightSheath.Telemetry.FileWriteEa} = 0x0010
, {\b InsightSheath.Telemetry.FileAppendData} = 0x0004
, {\b InsightSheath.Telemetry.WriteDac} = 0x00040000
, {\b InsightSheath.Telemetry.WriteOwner} = 0x00080000
, {\b InsightSheath.Telemetry.Synchronize} = 0x00100000
, {\b InsightSheath.Telemetry.FileExecute} = 0x0020
, {\b InsightSheath.Telemetry.FileTraverse} = FileExecute
, {\b InsightSheath.Telemetry.GenericRead} = 0x80000000
, {\b InsightSheath.Telemetry.GenericWrite} = 0x40000000
, {\b InsightSheath.Telemetry.GenericExecute} = 0x20000000
, {\b InsightSheath.Telemetry.GenericAll} = 0x10000000
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/262970b7-cd4a-41f4-8c4d-5a27f0092aaa, Windows SDK winnt.h and , these are the accessible flags }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Telemetry.ShareMasks} : uint \{ {\b InsightSheath.Telemetry.NoShare} = 0
, {\b InsightSheath.Telemetry.ShareDelete} = 0x00000004
, {\b InsightSheath.Telemetry.ShareRead} = 0x00000001
, {\b InsightSheath.Telemetry.ShareWrite} = 0x00000002
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Share mode for CreateFileA/W }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IoDeviceTelemetryReader.cs\par \pard\plain 
{\tc\tcl2 \v Telemetry/IoDeviceTelemetryReader.cs}
{\xe \v Telemetry/IoDeviceTelemetryReader.cs}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }InsightSheath.Wrappers;\par
00007 {\cf17 using }InsightSheath.Misc;\par
00008 {\cf17 using }System.Runtime.InteropServices;\par
00009 {\cf17 using }System.IO;\par
00010 {\cf17 using }InsightSheath.Debugging;\par
00011 {\cf17 using }InsightSheath.Win32Struct.Remote;\par
00012 {\cf17 using }InsightSheath.Win32Struct;\par
00013 \par
00014 {\cf17 namespace }InsightSheath.Telemetry\par
00015 \{\par
00016 \par
00020     [StructLayout(LayoutKind.Explicit)]\par
00021     {\cf17 public} {\cf17 struct }LARGE_INTEGER\par
00022     \{\par
00023         \par
00024         [FieldOffset(0)]\par
00025         {\cf17 public} UInt32 LowPart;\par
00026         [FieldOffset(4)]\par
00027         {\cf17 public} Int32 HighPart;\par
00028         [FieldOffset(0)]\par
00029         {\cf17 public} ulong QuadPart;\par
00030     \}\par
00031 \par
00032 \par
00033     {\cf17 public} {\cf17 class }IoDeviceTelememtryExceptionCommonValues : GeneralTelemtryHelperStruct\par
00034     \{\par
00035         {\cf17 public} IoDeviceTelememtryExceptionCommonValues(uint ProcessId, uint ThreadID, IntPtr ForceHandle, IntPtr LastError, MachineType Type) : base(ProcessId, ThreadID, ForceHandle, LastError, Type)\par
00036         \{\par
00037 \par
00038         \}\par
00039         \par
00040 \par
00041 \par
00045         {\cf17 public} {\cf17 static} readonly uint InvalidHandleValue32 = (0xffffffff);\par
00049         {\cf17 public} {\cf17 static} readonly ulong InvalidHandleValue64 = (0xffffffffffffffff);\par
00050 \par
00051     \}\par
00052 \par
00053 \par
00057     {\cf17 public} {\cf17 enum} NtCreationDisposition : uint \par
00058     \{\par
00062         Supersede = 0x00000000,\par
00066         Open = 0x00000001,\par
00070         Create = 0x00000002,\par
00074         OpenIf = 0x00000003,\par
00078         Overwrite = 0x00000004,\par
00082         OverwriteIf = 0x00000005,\par
00083         MaxDisposition = 0x00000005\par
00084     \}\par
00085 \par
00086 \par
00090     {\cf17 public} {\cf17 enum} CreationDisposition: uint\par
00091     \{ \par
00095         CreateNew = 1,\par
00099         CreateAlways = 2,\par
00103         OpenExisting = 3,\par
00107         OpenAlways = 4,\par
00111         TruncateExisting = 5\par
00112     \}\par
00113 \par
00114     \par
00115     [Flags]\par
00122     {\cf17 public} {\cf17 enum} AccessMasks: uint\par
00123     \{\par
00127         NoAccess = 0,\par
00131         MetaData = NoAccess,\par
00132 \par
00136         Delete = 0x00010000,\par
00140         ReadControl = 0x00020000,\par
00144         FileReadData = 0x1,\par
00148         FileListDirectory = FileReadData,\par
00152         FileReadAttributes = 0x0080,\par
00156         FileReadEa = 0x0008,\par
00160         FileWriteData = 0x0002,\par
00164         FileWriteAttributes = 0x0100,\par
00168         FileWriteEa = 0x0010,\par
00172         FileAppendData = 0x0004,\par
00176         WriteDac = 0x00040000,\par
00180         WriteOwner = 0x00080000,\par
00184         Synchronize = 0x00100000,\par
00188         FileExecute = 0x0020,\par
00192         FileTraverse = FileExecute,\par
00193 \par
00197         GenericRead = 0x80000000,\par
00201         GenericWrite = 0x40000000,\par
00205         GenericExecute = 0x20000000,\par
00209         GenericAll = 0x10000000\par
00210     \}\par
00211 \par
00212     \par
00213 \par
00217     [Flags]\par
00218     {\cf17 public} {\cf17 enum} ShareMasks: uint\par
00219     \{\par
00223         NoShare = 0,\par
00227         ShareDelete = 0x00000004,\par
00231         ShareRead = 0x00000001,\par
00235         ShareWrite = 0x00000002\par
00236     \}\par
00237 \par
00238     {\cf17 public} {\cf17 static} {\cf17 class }IoDeviceTelemetryExceptionExtensionsCheckers\par
00239     \{\par
00245         {\cf17 public} {\cf17 static} {\cf18 bool} IsIoDeviceTelemetryException({\cf17 this} DebugEventExceptionInfo that)\par
00246         \{\par
00247             {\cf19 if} ((uint)that.ExceptionCode == IoDeviceTelemetryReaderExtensions.FixedExceptionCode)\par
00248             \{\par
00249                 {\cf19 return} {\cf17 true};\par
00250             \}\par
00251             {\cf19 return} {\cf17 false};\par
00252         \}\par
00258         {\cf17 public} {\cf17 static} {\cf18 bool} IsIoDeviceTelemetryException({\cf17 this} DebugEvent that)\par
00259         \{\par
00260             {\cf19 if} (that.EventType == DebugEventType.ExceptionEvent)\par
00261             \{\par
00262                 {\cf19 if} ((uint)that.GetDebugEventExceptionInfo().ExceptionCode == IoDeviceTelemetryReaderExtensions.FixedExceptionCode)\par
00263                 \{\par
00264                     {\cf19 return} {\cf17 true};\par
00265                 \}\par
00266             \}\par
00267             {\cf19 return} {\cf17 false};\par
00268         \}\par
00269 \par
00270     \}\par
00271 \par
00272     {\cf17 public} {\cf17 class }IoDeviceTelemetryNtCreateFile: IoDeviceTelememtryExceptionCommonValues\par
00273     \{\par
00274 \par
00275         {\cf17 public} IoDeviceTelemetryNtCreateFile(uint ProcessId, uint ThreadID, IntPtr ForceHandle, IntPtr LastError, MachineType Type): base(ProcessId, ThreadID, ForceHandle, LastError, Type)\par
00276         \{\par
00277 \par
00278         \}\par
00282         {\cf17 public} readonly IntPtr FileOutHandle;\par
00286         {\cf17 public} AccessMasks DesiredAccess;\par
00290         {\cf17 public} WindowsObjectAttributes ObjectAttributes;\par
00294         {\cf17 public} readonly IntPtr IoStatusBlock;\par
00298         {\cf17 public} LARGE_INTEGER AllocationSize;\par
00302         {\cf17 public} FileAttributes FileAttributes;\par
00306         {\cf17 public} FileShare ShareAccess;\par
00310         {\cf17 public} uint CreationOptions;\par
00314         {\cf17 public} NtCreationDisposition CreateDisposition;\par
00318         {\cf17 public} IntPtr EaBuffer;\par
00322         {\cf17 public} ulong EaSize;\par
00323 \par
00327         {\cf20 //public readonly IntPtr ForceHandle;   <- now in generic parent class}\par
00331 {\cf20 }        {\cf20 //public readonly IntPtr ReturnValue <- ow in generic parent class;}\par
00332 \par
00333 \par
00334         \par
00339         {\cf17 public} {\cf18 void} SetReturnValue(uint ReturnValue)\par
00340         \{\par
00341             SetLastErrorValue(ReturnValue);\par
00342         \}\par
00343     \}\par
00344 \par
00345     \par
00346 \par
00350     {\cf17 public} {\cf17 class }IoDeviceTelemetyCreateFile: IoDeviceTelememtryExceptionCommonValues\par
00351     \{\par
00352         {\cf17 public} IoDeviceTelemetyCreateFile(uint dwProcess, uint dwThread, IntPtr HandlePtr, IntPtr ErrorPtr, MachineType Type): base(dwProcess, dwThread, HandlePtr, ErrorPtr, Type)\par
00353         \{\par
00354             FileName = {\cf17 null};\par
00355             DesiredAccess = AccessMasks.NoAccess;\par
00356             SharedMode = FileShare.None;\par
00357             SecurityAttrib = IntPtr.Zero;\par
00358             CreateDisposition = 0;\par
00359             FlagsAndAttributes = 0;\par
00360             TemplateFile = IntPtr.Zero;\par
00361         \}\par
00362 \par
00363 \par
00367         {\cf17 public} {\cf18 string} FileName;\par
00371         {\cf17 public} AccessMasks DesiredAccess;\par
00375         {\cf17 public} FileShare SharedMode;\par
00379         {\cf17 public} IntPtr SecurityAttrib;\par
00383         {\cf17 public} CreationDisposition CreateDisposition;\par
00387         {\cf17 public} uint FlagsAndAttributes;\par
00391         {\cf17 public} IntPtr TemplateFile;\par
00395         {\cf20 //public readonly IntPtr ForceHandle;}\par
00396 \par
00400         {\cf20 //public  readonly IntPtr ForceLastError;}\par
00401 \par
00402         \par
00403 \par
00404     \}\par
00405 \par
00406 \par
00410     {\cf17 public} {\cf17 static} {\cf17 class }IoDeviceTelemetryReaderExtensions\par
00411     \{\par
00412         {\cf17 const} uint ExceptionArgType = 0;\par
00413 \par
00414 \par
00415 \par
00416         {\cf20 //const uint ExceptionSubType = 0;}\par
00417         {\cf20 //const uint LastError_Ptr = 1;}\par
00418 \par
00419 \par
00420         {\cf20 /* if exception is NotificationType.CreateFile */}\par
00421         {\cf17 const} uint CreateFile_FilenamePtr = 2;\par
00422         {\cf17 const} uint CreateFile_FileNameCharLen = 3;\par
00423         {\cf17 const} uint CreateFile_DesiredAccess = 4;\par
00424         {\cf17 const} uint CreateFile_ShareMode = 5;\par
00425         {\cf17 const} uint CreateFile_SecurityPtr = 6;\par
00426         {\cf17 const} uint CreateFile_CreationDisposition = 7;\par
00427         {\cf17 const} uint CreateFile_FlagsAndAttribs = 8;\par
00428         {\cf17 const} uint CreateFile_TemplateFile = 9;\par
00429         {\cf17 const} uint CreateFile_OvrridePtr = 10;\par
00430 \par
00431 \par
00432         {\cf17 const} uint NtCreateFile_ReturnHandle = 2;\par
00433         {\cf17 const} uint NtCreateFile_DesiredAccess = 3;\par
00434         {\cf17 const} uint NtCreateFile_ObjectAttributes = 4;\par
00435         {\cf17 const} uint NtCreateFile_IoStatusBlock = 5;\par
00436         {\cf17 const} uint NtCreateFile_AllocationSize = 6;\par
00437         {\cf17 const} uint NtCreateFile_FileAttributs = 7;\par
00438         {\cf17 const} uint NtCreateFile_ShareAccess = 8;\par
00439         {\cf17 const} uint NtCreateFile_CreateDisposition = 9;\par
00440         {\cf17 const} uint NtCreateFile_CreateOptions = 10;\par
00441         {\cf17 const} uint NtCreateFile_EaBuffer = 11;\par
00442         {\cf17 const} uint NtCreateFile_EaLength = 12;\par
00443         {\cf17 const} uint NtCreateFile_OverwriteHandle = 13;\par
00444 \par
00445 \par
00446         {\cf20 /* if exception is NotificationType.NTCreateFIle*/}\par
00447         {\cf20 /*}\par
00448 {\cf20          * ExceptionArgs[EXCEPTION_LAST_ERROR] = (ULONG)ReturnValue;}\par
00449 {\cf20     ExceptionArgs[NTCF_AW_OUTPUTHANDLE] = (ULONG)FileHandle;}\par
00450 {\cf20     ExceptionArgs[NTCT_AW_DESIRED_ACCESS] = (ULONG)DesiredAccess;}\par
00451 {\cf20     ExceptionArgs[NTCT_AW_OBJECT_ATTRIBUTES] = (ULONG)ObjectAttributes;}\par
00452 {\cf20     ExceptionArgs[NTCT_AW_IOSTATUSBLOCK] = (ULONG)IoStatusBlock;}\par
00453 {\cf20     ExceptionArgs[NTCT_AW_ALLOCATION_SIZE] = (ULONG)AllocationSize;}\par
00454 {\cf20     ExceptionArgs[NTCT_AW_FILEATRIBUTES] = (ULONG)FileAttributes;}\par
00455 {\cf20     ExceptionArgs[NTCT_AW_SHARE_ACCESS] = (ULONG)ShareAccess;}\par
00456 {\cf20     ExceptionArgs[NTCT_AW_CREATEOPTION] = (ULONG)CreateDisposition;}\par
00457 {\cf20     ExceptionArgs[NTCT_AW_EABUFFER] = (ULONG)EaBuffer;}\par
00458 {\cf20     ExceptionArgs[NTCT_AW_EALENGTH] = (ULONG)EaLength;}\par
00459 {\cf20     ExceptionArgs[NTCT_AW_OVERRIDE_HANDLE] = (ULONG)OverwriteHandle;}\par
00460 {\cf20          */}\par
00461 \par
00462 \par
00463 \par
00467         {\cf20 //public static readonly uint FixedExceptionCode = 0x68ACB7A9;}\par
00468         {\cf20 // DEBUG ONLY x86 and x64 exception tracking down}\par
00469         {\cf17 public} {\cf17 static} readonly uint FixedExceptionCode = 2;\par
00470         {\cf17 public} {\cf17 enum} NotificationType\par
00471         \{\par
00475             CreateFile = 1,\par
00479             CreateFileTransacted = 2,\par
00483             CloseHandle = 3,\par
00487             NtCreateFile = 4,\par
00491             NtOpenFile =5\par
00492         \}\par
00493 \par
00499         {\cf17 public} {\cf17 static} NotificationType GetIoDeviceExceptionType({\cf17 this} DebugEventExceptionInfo that)\par
00500         \{\par
00501             {\cf19 return} (NotificationType)that.ExceptionParameter64[GeneralTelemetry.ExceptionSubType];\par
00502         \}\par
00503 \par
00504  \par
00510         {\cf17 public} {\cf17 static} IoDeviceTelemetryNtCreateFile GetNtCreateFileSettings({\cf17 this} DebugEventExceptionInfo that)\par
00511         \{\par
00512             IoDeviceTelemetryNtCreateFile ret;\par
00513             MachineType Type;\par
00514             IntPtr Handle = HelperRoutines.OpenProcessForVirtualMemory(that.ProcessID);\par
00515             var arguments = that.ExceptionParameter64;\par
00516             {\cf19 if} (that.IsEventFrom32BitProcess)\par
00517             \{\par
00518                 Type = MachineType.MachineI386;\par
00519             \}\par
00520             {\cf19 else}\par
00521             \{\par
00522                 Type = MachineType.MachineAmd64;\par
00523             \}\par
00524             {\cf19 try}\par
00525             \{\par
00526                 ret = {\cf17 new} IoDeviceTelemetryNtCreateFile(that.ProcessID, that.ThreadID, {\cf17 new} IntPtr(({\cf18 long})arguments[NtCreateFile_ReturnHandle]), {\cf17 new} IntPtr(({\cf18 long})arguments[GeneralTelemetry.LastError_Ptr]), Type) ;\par
00527 {\cf20 //                ret.ReturnValue = new IntPtr((long)arguments[LastError_Ptr]);}\par
00528   {\cf20 //              ret.FileOutHandle = new IntPtr((long)arguments[NtCreateFile_ReturnHandle]);}\par
00529                 ret.DesiredAccess = (AccessMasks) arguments[NtCreateFile_DesiredAccess];\par
00530                 {\cf19 if} (arguments[NtCreateFile_ObjectAttributes] == 0)\par
00531                 \{\par
00532                     ret.ObjectAttributes = {\cf17 null};\par
00533                 \}\par
00534                 {\cf19 else}\par
00535                 \{\par
00536                     {\cf20 //ret.ObjectAttributes = new Structs.WindowsObjectAttributes(new IntPtr((long)arguments[NtCreateFile_ObjectAttributes]));}\par
00537                     {\cf19 if} (arguments[NtCreateFile_ObjectAttributes] != 0)\par
00538                     \{\par
00539                         ret.ObjectAttributes = RemoteStructure.RemoteReadObjectAttributes(Handle, {\cf17 new} IntPtr(({\cf18 long})arguments[NtCreateFile_ObjectAttributes]), that.IsEventFrom32BitProcess, {\cf17 true});\par
00540                     \}\par
00541                     {\cf19 else}\par
00542                     \{\par
00543                         ret.ObjectAttributes = {\cf17 null}; \par
00544                     \}\par
00545                     \par
00546                 \}\par
00547                 {\cf19 if} (arguments[NtCreateFile_AllocationSize] != 0)\par
00548                 \{\par
00549                     ret.AllocationSize = Marshal.PtrToStructure<LARGE_INTEGER>({\cf17 new} IntPtr(({\cf18 long})arguments[NtCreateFile_AllocationSize]));\par
00550                 \}\par
00551                 {\cf19 else}\par
00552                 \{\par
00553                     ret.AllocationSize = {\cf17 new} LARGE_INTEGER();\par
00554                 \}\par
00555                 ret.FileAttributes = (FileAttributes) arguments[NtCreateFile_FileAttributs];\par
00556                 ret.ShareAccess = (FileShare) arguments[NtCreateFile_ShareAccess];\par
00557                 \par
00558                 ret.CreateDisposition = (NtCreationDisposition) arguments[NtCreateFile_CreateDisposition];\par
00559                 ret.CreationOptions = (uint)arguments[NtCreateFile_CreateOptions];\par
00560                 ret.EaBuffer = {\cf17 new} IntPtr(({\cf18 long})arguments[NtCreateFile_EaBuffer]);\par
00561                 ret.EaSize = arguments[NtCreateFile_EaLength];\par
00562                 {\cf20 //ret.ForceHandle = new IntPtr((long)arguments[NtCreateFile_OverwriteHandle]);}\par
00563                 {\cf19 return} ret;\par
00564             \}\par
00565             {\cf19 finally}\par
00566             \{\par
00567                 HelperRoutines.CloseHandle(Handle);\par
00568             \}\par
00569         \}\par
00570 \par
00576         {\cf17 public} {\cf17 static} IoDeviceTelemetyCreateFile GetCreateFileSettings({\cf17 this} DebugEventExceptionInfo that)\par
00577         \{\par
00578             MachineType type;\par
00579             IoDeviceTelemetyCreateFile ret;\par
00580             var Arguments = that.ExceptionParameter64;\par
00581             IntPtr Handle = HelperRoutines.OpenProcessForVirtualMemory(that.ProcessID);\par
00582 \par
00583             {\cf19 try}\par
00584             \{\par
00585                 {\cf19 if} (that.IsEventFrom32BitProcess)\par
00586                 \{\par
00587                     type = MachineType.MachineI386;\par
00588                 \}\par
00589                 {\cf19 else}\par
00590                 \{\par
00591                     type = MachineType.MachineAmd64;\par
00592                 \}\par
00593                 ret = {\cf17 new} IoDeviceTelemetyCreateFile(that.ProcessID, that.ThreadID, (IntPtr)Arguments[CreateFile_OvrridePtr], (IntPtr)Arguments[GeneralTelemetry.LastError_Ptr], type)\par
00594                 \{\par
00595                     FileName = RemoteStructure.RemoteReadString(Handle, {\cf17 new} IntPtr(({\cf18 long})Arguments[CreateFile_FilenamePtr]), Arguments[CreateFile_FileNameCharLen]),\par
00596                     DesiredAccess = (AccessMasks)Arguments[CreateFile_DesiredAccess],\par
00597                     SharedMode = (FileShare)Arguments[CreateFile_ShareMode],\par
00598                     SecurityAttrib = {\cf17 new} IntPtr(({\cf18 long})Arguments[CreateFile_SecurityPtr]),\par
00599                     CreateDisposition = (CreationDisposition)Arguments[CreateFile_CreationDisposition],\par
00600                     FlagsAndAttributes = (uint)Arguments[CreateFile_FlagsAndAttribs],\par
00601                     TemplateFile = {\cf17 new} IntPtr(({\cf18 long})Arguments[CreateFile_TemplateFile])\par
00602                 \};\par
00603 \par
00604 \par
00605             \}\par
00606             {\cf19 finally}\par
00607             \{\par
00608                 HelperRoutines.CloseHandle(Handle);\par
00609             \}\par
00610             {\cf19 return} ret;\par
00611         \}\par
00612 \par
00613     \}\par
00614 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Utility.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Utility.cs}
{\xe \v Utility.cs}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.HelperRoutines}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class contains various miscellaneous routines that while not tied directly to the library's purpose, they are used throughout the Sheath and wrappers. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.MachineType} \{ {\b InsightSheath.MachineInvalid} = 0
, {\b InsightSheath.MachineI386} = 0x014c
, {\b InsightSheath.MachineIA64} = 0x0200
, {\b InsightSheath.MachineAmd64} = 0x8664
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Machine Type values extractable }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Utility.cs\par \pard\plain 
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 using }InsightSheath.NativeImports;\par
00009 \par
00010 {\cf17 namespace }InsightSheath\par
00011 \{\par
00015     {\cf17 public} {\cf17 enum} MachineType\par
00016     \{\par
00020         MachineInvalid = 0,\par
00024         MachineI386 = 0x014c,\par
00028         MachineIA64 = 0x0200,\par
00032         MachineAmd64 = 0x8664\par
00033     \}\par
00034     \par
00035 \par
00039     {\cf17 public} {\cf17 static} {\cf17 class }HelperRoutines\par
00040     \{\par
00041 \par
00048         {\cf17 public} {\cf17 static} MachineType GetPEMachineType({\cf18 string} TargetExe)\par
00049         \{\par
00050             {\cf19 return} NativeMethods.GetPEMachineType(TargetExe);\par
00051         \}\par
00052 \par
00062         {\cf17 public} {\cf17 static} IntPtr DuplicateHandleToRemote(IntPtr CurrentHandle, uint Access, {\cf18 bool} CopyAccess, IntPtr TargetProcess, {\cf18 bool} AllowInherit)\par
00063         \{\par
00064             {\cf19 return} NativeMethods.DuplicateHandleIntoTarget(CurrentHandle, Access, CopyAccess, TargetProcess, AllowInherit);\par
00065         \}\par
00071         {\cf17 public} {\cf17 static} {\cf18 string} GetProcessNameViaHandle(IntPtr ProcessHandle)\par
00072         \{\par
00073             {\cf19 return} GetModuleNameViaHandle(ProcessHandle, IntPtr.Zero);\par
00074         \}\par
00080         {\cf17 public} {\cf17 static} {\cf18 string} GetModuleNameViaHandle(IntPtr ProcessHandle)\par
00081         \{\par
00082             {\cf19 return} GetModuleNameViaHandle(ProcessHandle, IntPtr.Zero);\par
00083         \}\par
00084 \par
00091         {\cf17 public} {\cf17 static} {\cf18 string} GetModuleNameViaHandle(IntPtr ProcessHandle, IntPtr HModule)\par
00092         \{\par
00093             IntPtr retPtr = NativeMethods.GetModuleNameViaHandleInternal(ProcessHandle, HModule );\par
00094             {\cf19 if} (retPtr == IntPtr.Zero)\par
00095             \{\par
00096                 {\cf19 return} {\cf17 null};\par
00097             \}\par
00098             {\cf19 else}\par
00099             \{\par
00100                 {\cf18 string} ret = Marshal.PtrToStringUni(retPtr);\par
00101                 NativeMethods.FreeModuleNameViaHandleInternal(retPtr);\par
00102                 {\cf19 return} ret;\par
00103             \}\par
00104         \}\par
00105 \par
00111         {\cf17 public} {\cf17 static} {\cf18 string} GetFileNameViaHandle(IntPtr FileHandle)\par
00112         \{\par
00113             IntPtr retPtr = NativeMethods.GetFileNameViaHandle(FileHandle);\par
00114             {\cf19 if} (retPtr == IntPtr.Zero)\par
00115             \{\par
00116                 {\cf19 return} {\cf17 null};\par
00117             \}\par
00118             {\cf19 else}\par
00119             \{\par
00120                 {\cf18 string} ret = Marshal.PtrToStringUni(retPtr);\par
00121                 NativeMethods.FreeFileNameViaHandleInternal(retPtr);\par
00122                 {\cf19 return} ret;\par
00123             \}\par
00124         \}\par
00130 \par
00131         {\cf17 public} {\cf17 static} IntPtr OpenProcessForVirtualMemory(uint ProcessId)\par
00132         \{\par
00133             {\cf19 return} NativeMethods.OpenProcessForMemoryAccess(ProcessId);\par
00134         \}\par
00135 \par
00141         {\cf17 public} {\cf17 static} IntPtr OpenProcessForQueryInformation(uint ProcessId)\par
00142         \{\par
00143             {\cf19 return} NativeMethods.OpenProcesForQueryInformation(ProcessId);\par
00144         \}\par
00145 \par
00151         {\cf17 public} {\cf17 static} IntPtr OpenProcessForHandleDuplicating(uint ProcessID)\par
00152         \{\par
00153             {\cf19 return} NativeMethods.OpenProcessForDuplicatingHandle(ProcessID);\par
00154         \}\par
00155 \par
00156 \par
00163         {\cf17 public} {\cf17 static} {\cf18 bool} CloseHandle(IntPtr Handle)\par
00164         \{\par
00165             {\cf19 return} NativeMethods.CloseHandle(Handle);\par
00166         \}\par
00167     \}\par
00168 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/ObjectAttributes_x64.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/ObjectAttributes_x64.cs}
{\xe \v Win32Struct/ObjectAttributes_x64.cs}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Win32Struct.ObjectAttributes64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a 64-bit process Specs from  }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ObjectAttributes_x64.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/ObjectAttributes_x64.cs}
{\xe \v Win32Struct/ObjectAttributes_x64.cs}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Win32Struct\par
00009 \{\par
00010 \par
00017     [StructLayout(LayoutKind.Sequential)]\par
00018     {\cf17 public} {\cf17 struct }ObjectAttributes64\par
00019     \{\par
00023         {\cf17 public} uint Length;\par
00027         {\cf17 public} ulong RootDirectory;\par
00031         {\cf17 public} ulong ObjectName;\par
00035         {\cf17 public} uint Attributes;\par
00039         {\cf17 public} ulong SecurityDescriptor;\par
00043         {\cf17 public} ulong SecurityQoS;\par
00044     \};\par
00045 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/ObjectAttributes_x86.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/ObjectAttributes_x86.cs}
{\xe \v Win32Struct/ObjectAttributes_x86.cs}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Win32Struct.ObjectAttributes32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the Object Attributes struct for a Wow / x86 bit process. Specs from  }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ObjectAttributes_x86.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/ObjectAttributes_x86.cs}
{\xe \v Win32Struct/ObjectAttributes_x86.cs}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Win32Struct\par
00009 \{\par
00010 \par
00015     [StructLayout(LayoutKind.Sequential)]\par
00016 \par
00017     {\cf17 public} {\cf17 struct }ObjectAttributes32\par
00018     \{\par
00022         {\cf17 public} uint Length;\par
00026         {\cf17 public} uint RootDirectory;\par
00030         {\cf17 public} uint ObjectName;\par
00034         {\cf17 public} uint Attributes;\par
00038         {\cf17 public} uint SecurityDescriptor;\par
00042         {\cf17 public} uint SecurityQoS;\par
00043 \par
00048         {\cf17 public} ObjectAttributes64 Promotion()\par
00049         \{\par
00050             var ret = {\cf17 new} ObjectAttributes64\par
00051             \{\par
00052                 Length = Length,\par
00053                 RootDirectory = RootDirectory,\par
00054                 ObjectName = ObjectName,\par
00055                 Attributes = Attributes,\par
00056                 SecurityDescriptor = SecurityDescriptor,\par
00057                 SecurityQoS = SecurityQoS\par
00058             \};\par
00059             {\cf19 return} ret;\par
00060         \}\par
00061     \};\par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/Remote/RemoteStructure.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/Remote/RemoteStructure.cs}
{\xe \v Win32Struct/Remote/RemoteStructure.cs}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Win32Struct.Remote.RemoteStructure}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Imports the RemoteRead and RemoteWrite structures for dealing with extracting data from the target process during various events. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct.Remote}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RemoteStructure.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/Remote/RemoteStructure.cs}
{\xe \v Win32Struct/Remote/RemoteStructure.cs}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.NativeImports;\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Collections.Generic;\par
00004 {\cf17 using }System.ComponentModel;\par
00005 {\cf17 using }System.Linq;\par
00006 {\cf17 using }System.Runtime.InteropServices;\par
00007 {\cf17 using }System.Text;\par
00008 {\cf17 using }System.Threading.Tasks;\par
00009 {\cf17 using }InsightSheath.Win32Struct;\par
00010 {\cf17 using }InsightSheath.Debugging;\par
00011 {\cf17 namespace }InsightSheath.Win32Struct.Remote\par
00012 \{\par
00016     {\cf17 public} {\cf17 static} {\cf17 class }RemoteStructure\par
00017     \{\par
00018         {\cf17 public} {\cf17 enum} PointerSize\par
00019         \{\par
00020             Size4 = 4,\par
00021             Size8 = 8\par
00022         \}\par
00023 \par
00024 \par
00025 \par
00033         {\cf17 public} {\cf17 static} IntPtr RemoteReadPointer(IntPtr ProcessHandle, IntPtr Location, PointerSize Size)\par
00034         \{\par
00035             {\cf19 switch} (Size)\par
00036             \{\par
00037                 {\cf19 case} PointerSize.Size4:\par
00038                     {\cf19 return} RemoteStructureInternal.RemoteReadPointer(ProcessHandle, Location, 4);\par
00039                 {\cf19 case} PointerSize.Size8:\par
00040                     {\cf19 return} RemoteStructureInternal.RemoteReadPointer(ProcessHandle, Location, 8);\par
00041                 {\cf19 default}:\par
00042                     {\cf19 return} IntPtr.Zero;\par
00043             \}\par
00044         \}\par
00045 \par
00046         {\cf17 public} {\cf17 static} WindowsObjectAttributes RemoteReadObjectAttributes(IntPtr ProcessHandle, IntPtr Location, {\cf18 bool} IsTarget32Bit,  {\cf18 bool} FreeOnCleanup)\par
00047         \{\par
00048             IntPtr target;\par
00049             target = RemoteStructureInternal.RemoteReadObjectAttributes(ProcessHandle, Location, IsTarget32Bit);\par
00050             {\cf19 if} (target != IntPtr.Zero)\par
00051             \{\par
00052                 var ret = {\cf17 new} WindowsObjectAttributes(target, FreeOnCleanup);\par
00053                 {\cf19 if} (IsTarget32Bit)\par
00054                 \{\par
00055                     ret.StructType = StructModeType.Machinex86;\par
00056                 \}\par
00057                 {\cf19 else}\par
00058                 \{\par
00059                     ret.StructType = StructModeType.Machinex64;\par
00060                 \}\par
00061                 {\cf19 return} ret;\par
00062             \}\par
00063             {\cf19 return} {\cf17 null};\par
00064         \}\par
00065 \par
00066 \par
00067         \par
00076         {\cf17 public} {\cf17 static} WindowsUnicodeString RemoteReadUnicodeString(IntPtr ProcessHandle, IntPtr Location, {\cf18 bool} IsTarget32Bit, {\cf18 bool} FreeOnCleanup)\par
00077         \{\par
00078             IntPtr retptr = IntPtr.Zero;\par
00079             WindowsUnicodeString ret;\par
00080             retptr = RemoteStructureInternal.RemoteReadUnicodeString(ProcessHandle, Location, IsTarget32Bit);\par
00081             {\cf19 if} (retptr != IntPtr.Zero)\par
00082             \{\par
00083                 ret = {\cf17 new} WindowsUnicodeString(retptr, FreeOnCleanup, StructModeType.Machinex64);\par
00084                 {\cf19 return} ret;\par
00085             \}\par
00086             {\cf19 return} {\cf17 null};\par
00087         \}\par
00088 \par
00089 \par
00097         {\cf17 public} {\cf17 static} {\cf18 string} RemoteReadString(IntPtr ProcessHandle, IntPtr StringLocation, ulong CharCount)\par
00098         \{\par
00099             {\cf18 string} str = {\cf17 null};\par
00100             IntPtr ret = RemoteStructureInternal.RemoteReadStringInternal(ProcessHandle, StringLocation, CharCount);\par
00101             {\cf19 if} (ret != IntPtr.Zero)\par
00102             \{\par
00103                 str = Marshal.PtrToStringUni(ret);\par
00104                 NativeMethods.SimpleFree(ret);\par
00105             \}\par
00106             {\cf19 return} str;\par
00107 \par
00108         \}\par
00109 \par
00116         {\cf17 public} {\cf17 static} {\cf18 string} RemoteReadDebugString(IntPtr ProcessHandle, IntPtr DebugEventStruct)\par
00117         \{\par
00118             IntPtr RetPtr = RemoteStructureInternal.RemoteReadDebugStringInternal(ProcessHandle, DebugEventStruct);\par
00119             {\cf19 if} (RetPtr == IntPtr.Zero)\par
00120             \{\par
00121                 {\cf19 return} {\cf17 null};\par
00122             \}\par
00123             {\cf19 else}\par
00124             \{\par
00125                 {\cf18 string} ret = Marshal.PtrToStringUni(RetPtr);\par
00126                 RemoteStructureInternal.RemoteFreeDebugStringInternal(RetPtr);\par
00127                 {\cf19 return} ret;\par
00128             \}\par
00129         \}\par
00130     \}\par
00131 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/StartupInfoExW.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/StartupInfoExW.cs}
{\xe \v Win32Struct/StartupInfoExW.cs}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Win32Struct.StartupInfoExW}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for the {\b StartupInfoExW} struct handler exported in InsightApi.dll. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Win32Struct.StartupInfoExW_Flags} : uint \{ {\b InsightSheath.Win32Struct.Startf_ForceOnFeed} = 0x00000040
, {\b InsightSheath.Win32Struct.Startf_ForceOffFeedback} = 0x00000080
, {\b InsightSheath.Win32Struct.Startf_PreventPinning} = 0x00002000
, {\b InsightSheath.Win32Struct.Startf_RunFullScreen} = 0x00000020
, {\b InsightSheath.Win32Struct.Startf_TitleIsAppId} = 0x00001000
, {\b InsightSheath.Win32Struct.Startf_TitleIsLinkName} = 0x00000800
, {\b InsightSheath.Win32Struct.Startf_UntrustedSource} = 0x00008000
, {\b InsightSheath.Win32Struct.Startf_UseCountChars} = 0x00000008
, {\b InsightSheath.Win32Struct.Startf_UseFillAttribute} = 0x00000010
, {\b InsightSheath.Win32Struct.Startf_UseHotKey} = 0x00000200
, {\b InsightSheath.Win32Struct.Startf_UsePosition} = 0x00000004
, {\b InsightSheath.Win32Struct.Startf_UseShowWindow} = 0x00000001
, {\b InsightSheath.Win32Struct.Startf_UseSize} = 0x00000002
, {\b InsightSheath.Win32Struct.Startf_UseStdHandles} = 0x00000100
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See  entry for dwFlags for the meaning of these values. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Win32Struct.StartupInfoExW_ShowWindow} : ushort \{ {\b InsightSheath.Win32Struct.Hide} = 0
, {\b InsightSheath.Win32Struct.ShowNormal} = 1
, {\b InsightSheath.Win32Struct.Normal} = ShowNormal
, {\b InsightSheath.Win32Struct.ShowMinimized} = 2
, {\b InsightSheath.Win32Struct.ShowMaximized} = 3
, {\b InsightSheath.Win32Struct.Maximize} = ShowMaximized
, {\b InsightSheath.Win32Struct.ShowNoActivate} = 4
, {\b InsightSheath.Win32Struct.Show} = 5
, {\b InsightSheath.Win32Struct.Minimized} = 6
, {\b InsightSheath.Win32Struct.ShowMinNoActive} = 7
, {\b InsightSheath.Win32Struct.ShowNa} = 8
, {\b InsightSheath.Win32Struct.ShowRestore} = 9
, {\b InsightSheath.Win32Struct.ShowDefault} = 10
, {\b InsightSheath.Win32Struct.ForceMinimize} = 11
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lifted from  these let you specify how starting window will do }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StartupInfoExW.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/StartupInfoExW.cs}
{\xe \v Win32Struct/StartupInfoExW.cs}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Wrappers;\par
00002 {\cf17 using }InsightSheath.NativeImports;\par
00003 {\cf17 using }System;\par
00004 {\cf17 using }System.Collections.Generic;\par
00005 {\cf17 using }System.Linq;\par
00006 {\cf17 using }System.Text;\par
00007 {\cf17 using }System.Threading.Tasks;\par
00008 {\cf17 using }System.Runtime.InteropServices;\par
00009 {\cf17 using }System.Diagnostics;\par
00010 {\cf17 using }InsightSheath.Abstract;\par
00011 \par
00012 {\cf17 namespace }InsightSheath.Win32Struct\par
00013 \{\par
00017     {\cf17 public} {\cf17 enum} StartupInfoExW_Flags : uint\par
00018     \{\par
00019         Startf_ForceOnFeed = 0x00000040,\par
00020         Startf_ForceOffFeedback = 0x00000080,\par
00021         Startf_PreventPinning = 0x00002000,\par
00022         Startf_RunFullScreen = 0x00000020,\par
00023         Startf_TitleIsAppId = 0x00001000,\par
00024         Startf_TitleIsLinkName = 0x00000800,\par
00025         Startf_UntrustedSource = 0x00008000,\par
00026         Startf_UseCountChars = 0x00000008,\par
00027         Startf_UseFillAttribute = 0x00000010,\par
00028         Startf_UseHotKey = 0x00000200,\par
00029         Startf_UsePosition = 0x00000004,\par
00030         Startf_UseShowWindow = 0x00000001,\par
00031         Startf_UseSize = 0x00000002,\par
00032         Startf_UseStdHandles = 0x00000100\par
00033     \}\par
00034 \par
00035 \par
00039     {\cf17 public} {\cf17 enum} StartupInfoExW_ShowWindow : ushort\par
00040     \{\par
00041         Hide = 0,\par
00042         ShowNormal = 1,\par
00043         Normal = ShowNormal,\par
00044         ShowMinimized = 2,\par
00045         ShowMaximized = 3,\par
00046         Maximize = ShowMaximized,\par
00047         ShowNoActivate = 4,\par
00048         Show = 5,\par
00049         Minimized = 6,\par
00050         ShowMinNoActive = 7,\par
00051         ShowNa = 8,\par
00052         ShowRestore = 9,\par
00056         ShowDefault = 10,\par
00057         ForceMinimize = 11\par
00058     \}\par
00059 \par
00060 \par
00064     {\cf17 public} {\cf17 class }StartupInfoExW: NativeStaticContainer\par
00065     \{\par
00070         {\cf17 public} {\cf17 static} StartupInfoExW MakeInstance()\par
00071         \{\par
00072             {\cf19 return} {\cf17 null};\par
00073         \}\par
00074         {\cf17 public} StartupInfoExW(IntPtr Native): base(Native)\par
00075         \{\par
00076 \par
00077         \}\par
00078 \par
00079         {\cf17 public} StartupInfoExW(IntPtr Native, {\cf18 bool} FreeConCleanup): base(Native, FreeConCleanup)\par
00080         \{\par
00081 \par
00082         \}\par
00083 \par
00084         {\cf17 private} {\cf18 bool} disposedValue;\par
00085         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00086         \{\par
00087             {\cf19 if} (!disposedValue)\par
00088             \{\par
00089                 {\cf19 if} (FreeOnCleanup)\par
00090                 \{\par
00091                     StartupInfoExWInternal.StartupInfoWrapper_DeleteInstance(Native);\par
00092                     ClearNative();\par
00093                 \}\par
00094                 disposedValue = {\cf17 true};\par
00095             \}\par
00096             \par
00097         \}\par
00098 \par
00099 \par
00103         {\cf17 public} {\cf18 string} Desktop\par
00104         \{\par
00105             {\cf17 get}\par
00106             \{\par
00107                 IntPtr ret = StartupInfoExWInternal.StartupInfoWrapper_GetDesktop(Native);\par
00108                 {\cf19 if} (ret != IntPtr.Zero)\par
00109                 \{\par
00110                     {\cf19 return} Marshal.PtrToStringUni(ret);\par
00111                 \}\par
00112                 {\cf19 return} {\cf17 null};\par
00113             \}\par
00114             {\cf17 set}\par
00115             \{\par
00116                 StartupInfoExWInternal.StartupInfoWrapper_SetDesktop(Native, value);\par
00117             \}\par
00118         \}\par
00119 \par
00123         {\cf17 public} {\cf18 string} Title\par
00124         \{\par
00125             {\cf17 get}\par
00126             \{\par
00127                 IntPtr ret = StartupInfoExWInternal.StartupInfoWrapper_GetTitle(Native);\par
00128                 {\cf19 if} (ret != IntPtr.Zero)\par
00129                 \{\par
00130                     {\cf19 return} Marshal.PtrToStringUni(ret);\par
00131                 \}\par
00132                 {\cf19 return} {\cf17 null};\par
00133             \}\par
00134             {\cf17 set}\par
00135             \{\par
00136                 StartupInfoExWInternal.StartupInfoWrapper_SetTitle(Native, value);\par
00137             \}\par
00138         \}\par
00139 \par
00143         {\cf17 public} uint X\par
00144         \{\par
00145             {\cf17 get}\par
00146             \{\par
00147                 {\cf19 return} StartupInfoExWInternal.StartupInfoWrapper_GetdwX(Native);\par
00148             \}\par
00149             {\cf17 set}\par
00150             \{\par
00151                 {\cf19 if} (FlagSetterHelper)\par
00152                 \{\par
00153                     Flags |= StartupInfoExW_Flags.Startf_UsePosition ;\par
00154                 \}\par
00155                 StartupInfoExWInternal.StartupInfoWrapper_SetdwX(Native, value);\par
00156             \}\par
00157         \}\par
00158 \par
00162         {\cf17 public} uint Y\par
00163         \{\par
00164             {\cf17 get}\par
00165             \{\par
00166                 {\cf19 return} StartupInfoExWInternal.StartupInfoWrapper_GetdwY(Native);\par
00167             \}\par
00168             {\cf17 set}\par
00169             \{\par
00170                 {\cf19 if} (FlagSetterHelper)\par
00171                 \{\par
00172                     Flags |= StartupInfoExW_Flags.Startf_UseSize;\par
00173                 \}\par
00174                 StartupInfoExWInternal.StartupInfoWrapper_SetdwY(Native, value);\par
00175             \}\par
00176         \}\par
00177 \par
00181         {\cf17 public} uint XSize\par
00182         \{\par
00183             {\cf17 get}\par
00184             \{\par
00185                 {\cf19 return} StartupInfoExWInternal.StartupInfoWrapper_GetXSize(Native);\par
00186             \}\par
00187             {\cf17 set}\par
00188             \{\par
00189                 {\cf19 if} (FlagSetterHelper)\par
00190                 \{\par
00191                     Flags |= StartupInfoExW_Flags.Startf_UseSize;\par
00192                 \}\par
00193                 StartupInfoExWInternal.StartupInfoWrapper_SetXSize(Native, value);\par
00194             \}\par
00195         \}\par
00196 \par
00197 \par
00201         {\cf17 public} uint YSize\par
00202         \{\par
00203             {\cf17 get}\par
00204             \{\par
00205                 {\cf19 return} StartupInfoExWInternal.StartupInfoWrapper_GetYSize(Native);\par
00206             \}\par
00207             {\cf17 set}\par
00208             \{\par
00209                 {\cf19 if} (FlagSetterHelper)\par
00210                 \{\par
00211                     Flags |= StartupInfoExW_Flags.Startf_UseCountChars;\par
00212                 \}\par
00213                 StartupInfoExWInternal.StartupInfoWrapper_SetYSize(Native, value);\par
00214             \}\par
00215         \}\par
00216 \par
00220         {\cf17 public} uint XCountChars\par
00221         \{\par
00222             {\cf17 get}\par
00223             \{\par
00224                 {\cf19 return} StartupInfoExWInternal.StartupInfoWrapper_GetdwXCountChars(Native);\par
00225             \}\par
00226             {\cf17 set}\par
00227             \{\par
00228                 {\cf19 if} (FlagSetterHelper)\par
00229                 \{\par
00230                     Flags |= StartupInfoExW_Flags.Startf_UseCountChars;\par
00231                 \}\par
00232                 StartupInfoExWInternal.StartupInfoWrapper_SetdwXCountChars(Native, value);\par
00233             \}\par
00234         \}\par
00238         {\cf17 public} uint YCountChars\par
00239         \{\par
00240             {\cf17 get}\par
00241             \{\par
00242                 {\cf19 return} StartupInfoExWInternal.StartupInfoWrapper_GetdwYCountChars(Native);\par
00243             \}\par
00244             {\cf17 set}\par
00245             \{\par
00246                 StartupInfoExWInternal.StartupInfoWrapper_SetdwYCountChars(Native, value);\par
00247             \}\par
00248         \}\par
00249 \par
00253         {\cf17 public} uint FillAtribute\par
00254         \{\par
00255             {\cf17 get}\par
00256             \{\par
00257                 {\cf19 return} StartupInfoExWInternal.StartupInfo_GetdwFillAttributes(Native);\par
00258             \}\par
00259             {\cf17 set}\par
00260             \{\par
00261                 {\cf19 if} (FlagSetterHelper)\par
00262                 \{\par
00263                     Flags |= StartupInfoExW_Flags.Startf_UseFillAttribute;\par
00264                 \}\par
00265                 StartupInfoExWInternal.StartupInfo_SetdwFillAttribute(Native, value);\par
00266             \}\par
00267         \}\par
00268 \par
00272         {\cf17 public} StartupInfoExW_Flags Flags\par
00273         \{\par
00274             {\cf17 get}\par
00275             \{\par
00276                 {\cf19 return} (StartupInfoExW_Flags)StartupInfoExWInternal.StartupInfo_GetdwFlags(Native);\par
00277             \}\par
00278             {\cf17 set}\par
00279             \{\par
00280                 StartupInfoExWInternal.StartupInfo_SetdwFlags(Native, (uint)value);\par
00281             \}\par
00282         \}\par
00286         {\cf17 public} StartupInfoExW_ShowWindow ShowWindow\par
00287         \{\par
00288             {\cf17 get}\par
00289             \{\par
00290                 {\cf19 return} (StartupInfoExW_ShowWindow)StartupInfoExWInternal.StartupInfo_GetShowWindow(Native);\par
00291             \}\par
00292             {\cf17 set}\par
00293             \{\par
00294                 {\cf19 if} (FlagSetterHelper)\par
00295                 \{\par
00296                     Flags |= StartupInfoExW_Flags.Startf_UseShowWindow;\par
00297                 \}\par
00298                 StartupInfoExWInternal.StartupInfo_SetShowWindow(Native, (ushort) value);\par
00299             \}\par
00300         \}\par
00301 \par
00305         {\cf17 public} IntPtr StandardInput\par
00306         \{\par
00307             {\cf17 get}\par
00308             \{\par
00309                 {\cf19 return} StartupInfoExWInternal.StartupInfo_GetStdInput(Native);\par
00310             \}\par
00311             {\cf17 set}\par
00312             \{\par
00313                 StartupInfoExWInternal.StartupInfo_SetStdInput(Native, value);\par
00314             \}\par
00315         \}\par
00316 \par
00320         {\cf17 public} IntPtr StandardOutput\par
00321         \{\par
00322             {\cf17 get}\par
00323             \{\par
00324                 {\cf19 return} StartupInfoExWInternal.StartupInfo_GetStdOutput(Native);\par
00325             \}\par
00326             {\cf17 set}\par
00327             \{\par
00328                 {\cf19 if} (FlagSetterHelper)\par
00329                 \{\par
00330                     Flags |= StartupInfoExW_Flags.Startf_UseStdHandles;\par
00331                 \}\par
00332                 StartupInfoExWInternal.StartupInfo_SetStdOutput(Native, value);\par
00333             \}\par
00334         \}\par
00335 \par
00339 \par
00340         {\cf17 public} IntPtr StandardError\par
00341         \{\par
00342             {\cf17 get}\par
00343             \{\par
00344                 {\cf19 return} StartupInfoExWInternal.StartupInfo_GetStdError(Native);\par
00345             \}\par
00346             {\cf17 set}\par
00347             \{\par
00348                 {\cf19 if} (FlagSetterHelper)\par
00349                 \{\par
00350                     Flags |= StartupInfoExW_Flags.Startf_UseStdHandles;\par
00351                 \}\par
00352                 StartupInfoExWInternal.StartupInfo_SetStdError(Native, value);\par
00353             \}\par
00354 \par
00355         \}\par
00356 \par
00357 \par
00361         {\cf17 public} {\cf18 bool} FlagSetterHelper\par
00362         \{\par
00363             {\cf17 get}\par
00364             \{\par
00365                 {\cf19 return} FlagSetterContainer;\par
00366             \}\par
00367             {\cf17 set}\par
00368             \{\par
00369                 FlagSetterContainer = value;\par
00370             \}\par
00371         \}\par
00372         {\cf17 protected} {\cf18 bool} FlagSetterContainer;\par
00373     \}\par
00374 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/UserProcessParameters_x64.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/UserProcessParameters_x64.cs}
{\xe \v Win32Struct/UserProcessParameters_x64.cs}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Win32Struct.UserProcessParameters64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x64 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserProcessParameters_x64.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/UserProcessParameters_x64.cs}
{\xe \v Win32Struct/UserProcessParameters_x64.cs}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Win32Struct\par
00009 \{\par
00010 \par
00014     [StructLayout(LayoutKind.Sequential)]\par
00015     {\cf17 public} {\cf17 struct }UserProcessParameters64\par
00016     \{\par
00017         [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = 16)]\par
00018         {\cf17 public} {\cf18 byte}[] Reserved1;\par
00019         [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U4, SizeConst = 10)]\par
00020         {\cf17 public} ulong[] Reserved2;\par
00021         {\cf17 public} UnicodeString64 ImagePathName;\par
00022         {\cf17 public} UnicodeString64 CommandLine;\par
00023     \}\par
00024 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/UserProcessParameters_x86.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/UserProcessParameters_x86.cs}
{\xe \v Win32Struct/UserProcessParameters_x86.cs}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Win32Struct.UserProcessParameters32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the x86 version of the Native struct RTL_USER_PROCESS_PARAMETERS as documented here and comparing offsets between the struct in the OffsetAttrib sample project for Windows 10.  }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserProcessParameters_x86.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/UserProcessParameters_x86.cs}
{\xe \v Win32Struct/UserProcessParameters_x86.cs}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Win32Struct\par
00009 \{\par
00013     [StructLayout(LayoutKind.Sequential)]\par
00014     {\cf17 public} {\cf17 struct }UserProcessParameters32\par
00015     \{\par
00016         [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = 16)]\par
00017         {\cf17 public} {\cf18 byte}[] Reserved1;\par
00018         [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U4, SizeConst = 10)]\par
00019         {\cf17 public} uint[] Reserved2;\par
00020         {\cf17 public} UnicodeString32 ImagePathName;\par
00021         {\cf17 public} UnicodeString32 CommandLine;\par
00022     \}\par
00023 \par
00024 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/WindowsObjectAttributes.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/WindowsObjectAttributes.cs}
{\xe \v Win32Struct/WindowsObjectAttributes.cs}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Win32Struct.WindowsObjectAttributes}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
made from specs here  }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WindowsObjectAttributes.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/WindowsObjectAttributes.cs}
{\xe \v Win32Struct/WindowsObjectAttributes.cs}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Abstract;\par
00002 {\cf17 using }InsightSheath.NativeImports;\par
00003 {\cf17 using }InsightSheath.Wrappers;\par
00004 {\cf17 using }System;\par
00005 {\cf17 using }System.Collections.Generic;\par
00006 {\cf17 using }System.Linq;\par
00007 {\cf17 using }System.Runtime.InteropServices;\par
00008 {\cf17 using }System.Text;\par
00009 {\cf17 using }System.Threading.Tasks;\par
00010 \par
00011 {\cf17 namespace }InsightSheath.Win32Struct\par
00012 \{\par
00013 \par
00014 \par
00015 \par
00019     {\cf17 public} {\cf17 class }WindowsObjectAttributes: PlatformDependantNativeStruct\par
00020     \{\par
00021         {\cf17 public}  WindowsObjectAttributes(IntPtr Native)   : base(Native)\par
00022         \{\par
00023 \par
00024         \}\par
00025 \par
00026         {\cf17 public} WindowsObjectAttributes(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, FreeOnCleanup)\par
00027         \{\par
00028 \par
00029         \}\par
00030 \par
00031         {\cf17 public} WindowsObjectAttributes(IntPtr Native, {\cf18 bool} FreeOnCleanup, StructModeType StructType) : base(Native, FreeOnCleanup, StructType)\par
00032         \{\par
00033 \par
00034         \}\par
00035         {\cf17 public} WindowsObjectAttributes(IntPtr Native, StructModeType StructType) : base(Native, StructType)\par
00036         \{\par
00037 \par
00038         \}\par
00039 \par
00040         {\cf17 private} {\cf18 bool} disposedValue;\par
00045         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00046         \{\par
00047             {\cf19 if} (!disposedValue)\par
00048             \{\par
00049                 {\cf18 bool} bit32Mode;\par
00050                 {\cf19 if} (StructType == StructModeType.Machinex86)\par
00051                 \{\par
00052                     bit32Mode = {\cf17 true};\par
00053                 \}\par
00054                 {\cf19 else}\par
00055                 \{\par
00056                     {\cf19 if} (StructModeType.Machinex64 == StructType)\par
00057                     \{\par
00058                         bit32Mode = {\cf17 false};\par
00059                     \}\par
00060                     {\cf19 else}\par
00061                     \{\par
00062                         {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00063                     \}\par
00064                 \}\par
00065                 {\cf19 if} (FreeOnCleanup)\par
00066                 \{\par
00067                     RemoteStructureInternal.RemoteFreeObjectAttributes(Native, bit32Mode);\par
00068                 \}\par
00069                 ClearNative();\par
00070                 disposedValue = {\cf17 true};\par
00071             \}\par
00072             base.Dispose(disposing);\par
00073         \}\par
00074         {\cf17 protected} {\cf17 override} {\cf18 void} Blit()\par
00075         \{\par
00076             {\cf19 if} (!WasBlit)\par
00077             \{\par
00078                 WasBlit = {\cf17 true};\par
00079                 {\cf19 switch} (StructTypeContainer)\par
00080                 \{\par
00081                     {\cf19 case} StructModeType.Machinex64:\par
00082                         \{\par
00083                             Ret64 = Marshal.PtrToStructure<ObjectAttributes64>(Native);\par
00084                         \}\par
00085                         {\cf19 break};\par
00086                     {\cf19 case} StructModeType.Machinex86:\par
00087                         \{\par
00088                             Ret32 = Marshal.PtrToStructure<ObjectAttributes32>(Native);\par
00089                         \}\par
00090                         {\cf19 break};\par
00091                     {\cf19 default}: {\cf19 throw}  ThrowNewInvalidOpMessage(GetType().Name);\par
00092                 \}\par
00093 \par
00094             \}\par
00095         \}\par
00096 \par
00100         {\cf17 protected} {\cf17 override} {\cf18 void} Apply()\par
00101         \{\par
00102             {\cf19 throw} {\cf17 new} NotImplementedException();\par
00103         \}\par
00104 \par
00105 \par
00106 \par
00107 \par
00111         {\cf17 public} ulong Length\par
00112         \{\par
00113             {\cf17 get}\par
00114             \{\par
00115                 Blit();\par
00116                 {\cf19 switch} (StructTypeContainer)\par
00117                 \{\par
00118                     {\cf19 case} StructModeType.Machinex64: {\cf19 return} Ret64.Length;\par
00119                     {\cf19 case} StructModeType.Machinex86: {\cf19 return} Ret32.Length;\par
00120                 \}\par
00121                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00122             \}\par
00123         \}\par
00124 \par
00129         {\cf17 public} IntPtr RootDirectory\par
00130         \{\par
00131             {\cf17 get}\par
00132             \{\par
00133                 Blit();\par
00134                 {\cf19 switch} (StructTypeContainer)\par
00135                 \{\par
00136                     {\cf19 case} StructModeType.Machinex64:\par
00137                         \{\par
00138                             {\cf19 if} (Ret64.RootDirectory != 0)\par
00139                             \{\par
00140                                 {\cf19 return} {\cf17 new} IntPtr((uint)Ret64.RootDirectory);\par
00141                             \}\par
00142                             {\cf19 return} IntPtr.Zero;\par
00143                         \}\par
00144                     {\cf19 case} StructModeType.Machinex86:\par
00145                         \{\par
00146                             {\cf19 if} (Ret32.RootDirectory != 0)\par
00147                             \{\par
00148                                 {\cf19 return} {\cf17 new} IntPtr(Ret32.RootDirectory);\par
00149                             \}\par
00150                             {\cf19 return} IntPtr.Zero;\par
00151                         \}\par
00152                 \}\par
00153                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00154             \}\par
00155         \}\par
00156 \par
00161         {\cf17 public} WindowsUnicodeString ObjectName\par
00162         \{\par
00163             {\cf17 get}\par
00164             \{\par
00165                 Blit();\par
00166                 {\cf19 switch} (StructTypeContainer)\par
00167                 \{\par
00168                     {\cf19 case} StructModeType.Machinex64:\par
00169                         \{\par
00170                             {\cf19 if} (Ret64.ObjectName == 0)\par
00171                             \{\par
00172                                 {\cf19 return} {\cf17 null};\par
00173                             \}\par
00174                             {\cf19 else}\par
00175                             \{\par
00176                                 WindowsUnicodeString ret = {\cf17 new} WindowsUnicodeString({\cf17 new}  IntPtr(({\cf18 long})Ret64.ObjectName), {\cf17 false}, StructModeType.Machinex64);\par
00177                                 \par
00178                                 {\cf19 return} ret;\par
00179                             \}\par
00180                         \}\par
00181                     {\cf19 case} StructModeType.Machinex86:\par
00182                         \{\par
00183                             {\cf19 if} (Ret32.ObjectName == 0)\par
00184                             \{\par
00185                                 {\cf19 return} {\cf17 null};\par
00186                             \}\par
00187                             {\cf19 else}\par
00188                             \{\par
00189                                 WindowsUnicodeString ret = {\cf17 new} WindowsUnicodeString({\cf17 new} IntPtr(({\cf18 int})Ret32.ObjectName), {\cf17 false}, StructModeType.Machinex86);\par
00190                                 \par
00191                                 {\cf19 return} ret;\par
00192                             \}\par
00193                         \}\par
00194                 \}\par
00195                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00196             \}\par
00197         \}\par
00198 \par
00203         {\cf17 public} uint Attributes\par
00204         \{\par
00205             {\cf17 get}\par
00206             \{\par
00207                 {\cf19 switch} (StructTypeContainer)\par
00208                 \{\par
00209                     {\cf19 case} StructModeType.Machinex64:\par
00210                         {\cf19 return} Ret64.Attributes;\par
00211                     {\cf19 case} StructModeType.Machinex86:\par
00212                         {\cf19 return} Ret32.Attributes;\par
00213                 \}\par
00214                 {\cf19 throw} {\cf17 new} InvalidOperationException();\par
00215             \}\par
00216         \}\par
00217 \par
00226         {\cf17 public} IntPtr SecurityDescriptor\par
00227         \{\par
00228             {\cf17 get}\par
00229             \{\par
00230                 {\cf19 switch} (StructTypeContainer)\par
00231                 \{\par
00232                     {\cf19 case} StructModeType.Machinex64:\par
00233                         {\cf19 if} (Ret64.SecurityDescriptor == 0)\par
00234                         \{\par
00235                             {\cf19 return} IntPtr.Zero;\par
00236                         \}\par
00237                         {\cf19 return} {\cf17 new} IntPtr((uint) Ret64.SecurityDescriptor);\par
00238                     {\cf19 case} StructModeType.Machinex86:\par
00239                         {\cf19 if} (Ret32.SecurityDescriptor == 0)\par
00240                         \{\par
00241                             {\cf19 return} IntPtr.Zero;\par
00242                         \}\par
00243                         {\cf19 return} {\cf17 new} IntPtr(Ret32.SecurityDescriptor);\par
00244                 \}\par
00245                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00246             \}\par
00247         \}\par
00256         {\cf17 public} IntPtr SecurityQualityOfService\par
00257         \{\par
00258             {\cf17 get}\par
00259             \{\par
00260                 {\cf19 switch} (StructTypeContainer)\par
00261                 \{\par
00262                     {\cf19 case} StructModeType.Machinex64:\par
00263                         {\cf19 if} (Ret64.SecurityQoS == 0)\par
00264                         \{\par
00265                             {\cf19 return} IntPtr.Zero;\par
00266                         \}\par
00267                         {\cf19 return} {\cf17 new} IntPtr((uint)Ret64.SecurityQoS);\par
00268                     {\cf19 case} StructModeType.Machinex86:\par
00269                         {\cf19 if} (Ret32.SecurityQoS == 0)\par
00270                         \{\par
00271                             {\cf19 return} IntPtr.Zero;\par
00272                         \}\par
00273                         {\cf19 return} {\cf17 new} IntPtr(Ret32.SecurityQoS);\par
00274                 \}\par
00275                 {\cf19 throw}  ThrowNewInvalidOpMessage(GetType().Name);\par
00276             \}\par
00277         \}\par
00278 \par
00282         ObjectAttributes32 Ret32;\par
00286         ObjectAttributes64 Ret64;\par
00287         \par
00288     \}\par
00289 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/WindowsUnicodeString.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/WindowsUnicodeString.cs}
{\xe \v Win32Struct/WindowsUnicodeString.cs}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Win32Struct.UnicodeString32}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processed that are Wow/32- bit this is what our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from either a local native pointer or remote/other process. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InsightSheath.Win32Struct.UnicodeString64}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For processes that are 64-bit, this is our UNICODE_STRING struct looks like when read from. Suitable for Marshaling from a source. Take care that you handle if your pointer to the native structure {\b UnicodeString32.Buffer} points to a remote/ non local memory buffer or not. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Win32Struct.WindowsUnicodeString}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encapsulates both a {\b UnicodeString32} or {\b UnicodeString64} and lets one indicate which one to use based on {\b WindowsUnicodeString.StructType} You can use HelperRoutines.GetPEMachineType(string) on the process your dealing with to find what value was set as the machine type }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsightSheath.Win32Struct.StructModeType} \{ {\b InsightSheath.Win32Struct.MachineUnknown} = 0
, {\b InsightSheath.Win32Struct.Machinex86} = 1
, {\b InsightSheath.Win32Struct.Machinex64} = 2
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum used by certain classes that encapsulate Native Structs that contain pointers whose size may not match {\i our}  pointer size. One will need to set the PlatformDependantNativeStruct.StructType in a child class to flag which version to use }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WindowsUnicodeString.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/WindowsUnicodeString.cs}
{\xe \v Win32Struct/WindowsUnicodeString.cs}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }InsightSheath.Wrappers;\par
00002 {\cf17 using }System;\par
00003 {\cf17 using }System.Collections.Generic;\par
00004 {\cf17 using }System.Linq;\par
00005 {\cf17 using }System.Runtime.InteropServices;\par
00006 {\cf17 using }System.Text;\par
00007 {\cf17 using }System.Threading.Tasks;\par
00008 {\cf17 using }InsightSheath.Abstract;\par
00009 {\cf17 using }InsightSheath.NativeImports;\par
00010 \par
00011 {\cf17 namespace }InsightSheath.Win32Struct\par
00012 \{\par
00013 \par
00017     {\cf17 public} {\cf17 enum} StructModeType\par
00018     \{\par
00022         MachineUnknown = 0,\par
00026         Machinex86 = 1,\par
00030         Machinex64 = 2\par
00031     \}\par
00032 \par
00033 \par
00034 \par
00035     {\cf20 /*}\par
00036 {\cf20      *  struct UNICODE_STRING32}\par
00037 {\cf20     \{}\par
00038 {\cf20         USHORT Length;}\par
00039 {\cf20         USHORT MaxLength;}\par
00040 {\cf20         UINT Buffer;}\par
00041 {\cf20     \};}\par
00042 {\cf20 }\par
00046 {\cf20     struct UNICODE_STRING64}\par
00047 {\cf20     \{}\par
00048 {\cf20         USHORT Length;}\par
00049 {\cf20         USHORT MaxLength;}\par
00050 {\cf20         INT Padding; // alights buffer to correct location}\par
00051 {\cf20         ULONGLONG Buffer;}\par
00052 {\cf20     \};*/}\par
00053 \par
00058     [StructLayout(LayoutKind.Sequential)]\par
00059     {\cf17 public} {\cf17 struct }UnicodeString32\par
00060     \{\par
00064         {\cf17 public} ushort Length;\par
00068         {\cf17 public} ushort MaxLength;\par
00072         {\cf17 public} uint Buffer;\par
00073     \}\par
00074 \par
00081     [StructLayout(LayoutKind.Sequential)]\par
00082     {\cf17 public} {\cf17 struct }UnicodeString64\par
00083     \{\par
00087         {\cf17 public} ushort Length;\par
00091         {\cf17 public} ushort MaxLength;\par
00095         {\cf17 public} uint Padding;\par
00099         {\cf17 public} ulong Buffer;\par
00100     \}\par
00101 \par
00102 \par
00103     \par
00107     {\cf17 public} {\cf17 class }WindowsUnicodeString: PlatformDependantNativeStruct\par
00108     \{\par
00113         {\cf17 public} WindowsUnicodeString(IntPtr Native): base(Native)\par
00114         \{\par
00115             StructType = StructModeType.MachineUnknown;\par
00116         \}\par
00117 \par
00122         {\cf17 public} WindowsUnicodeString(IntPtr Native, {\cf18 bool} FreeOnCleanup): base(Native, FreeOnCleanup)\par
00123         \{\par
00124             StructType = StructModeType.MachineUnknown;\par
00125         \}\par
00126 \par
00133         {\cf17 public} WindowsUnicodeString(IntPtr Native, {\cf18 bool} FreeOnCleanup, StructModeType StructType) : base(Native, FreeOnCleanup, StructType)\par
00134         \{\par
00135 \par
00136         \}\par
00137 \par
00143         {\cf17 public} WindowsUnicodeString(IntPtr Native, StructModeType StructType): base(Native, StructType)\par
00144         \{\par
00145 \par
00146         \}\par
00147 \par
00151         ~WindowsUnicodeString()\par
00152         \{\par
00153             Dispose({\cf17 false});\par
00154         \}\par
00155 \par
00159         {\cf17 protected} {\cf17 override} {\cf18 void} Blit()\par
00160         \{\par
00161             \{\par
00162                 {\cf19 if} (!WasBlit)\par
00163                 \{\par
00164                     {\cf19 switch} (StructType)\par
00165                     \{\par
00166                         {\cf19 case} StructModeType.Machinex64:\par
00167                             \{\par
00168                                 Machine64 = Marshal.PtrToStructure<UnicodeString64>(Native);\par
00169                                 {\cf19 break};\par
00170                             \}\par
00171                         {\cf19 case} StructModeType.Machinex86:\par
00172                             \{\par
00173                                 Machine32 = Marshal.PtrToStructure<UnicodeString32>(Native);\par
00174                                 {\cf19 break};\par
00175                             \}\par
00176                         {\cf19 default}:\par
00177                             \{\par
00178                                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00179                             \}\par
00180                     \}\par
00181 \par
00182                     WasBlit = {\cf17 true};\par
00183                 \}\par
00184             \}\par
00185         \}\par
00186 \par
00187 \par
00188         {\cf17 private} {\cf18 bool} disposedValue;\par
00195         {\cf17 protected} {\cf17 override} {\cf18 void} Dispose({\cf18 bool} disposing)\par
00196         \{\par
00197             {\cf19 if} (!disposedValue)\par
00198             \{\par
00199                 {\cf18 bool} bit32Mode;\par
00200                 {\cf19 if} (this.StructType == StructModeType.Machinex86)\par
00201                 \{\par
00202                     bit32Mode = {\cf17 true};\par
00203                 \}\par
00204                 {\cf19 else}\par
00205                 \{\par
00206                     bit32Mode = {\cf17 false};\par
00207                     {\cf19 if} (StructType == StructModeType.MachineUnknown)\par
00208                     \{\par
00209                         {\cf19 throw} ThrowNewInvalidOpMessage(this.GetType().Name);\par
00210                     \}\par
00211                 \}\par
00212 \par
00213                 {\cf19 if} (FreeOnCleanup)\par
00214                 \{\par
00215                     RemoteStructureInternal.RemoteFreeUnicodeString(Native);\par
00216                     ClearNative();\par
00217                 \}\par
00218                 disposedValue = {\cf17 true};\par
00219             \}\par
00220             base.Dispose(disposing);\par
00221         \}\par
00222 \par
00223         \par
00224 \par
00228         {\cf17 public} {\cf18 int} Length\par
00229         \{\par
00230             {\cf17 get} \par
00231             \{\par
00232                 Blit();\par
00233                 {\cf19 if} (StructType == StructModeType.Machinex64)\par
00234                 \{\par
00235                     {\cf19 return} Machine64.Length;\par
00236                 \}\par
00237                 {\cf19 if} (StructType == StructModeType.Machinex86)\par
00238                 \{\par
00239                     {\cf19 return} Machine32.Length;\par
00240                 \}\par
00241 \par
00242                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00243             \}\par
00244         \}\par
00245 \par
00249         {\cf17 public} {\cf18 int} MaxLength\par
00250         \{\par
00251             {\cf17 get}\par
00252             \{\par
00253                 Blit();\par
00254                 {\cf19 if} (StructType == StructModeType.Machinex64)\par
00255                 \{\par
00256                     {\cf19 return} Machine64.MaxLength;\par
00257                 \}\par
00258                 {\cf19 if} (StructType == StructModeType.Machinex86)\par
00259                 \{\par
00260                     {\cf19 return} Machine32.MaxLength;\par
00261                 \}\par
00262 \par
00263                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00264             \}\par
00265         \}\par
00266 \par
00270         {\cf17 public} ulong BufferPtr\par
00271         \{\par
00272             {\cf17 get}\par
00273             \{\par
00274                 Blit();\par
00275                 {\cf19 if} (StructType == StructModeType.Machinex64)\par
00276                 \{\par
00277                     {\cf19 return} Machine64.Buffer;\par
00278                 \}\par
00279                 {\cf19 if} (StructType == StructModeType.Machinex86)\par
00280                 \{\par
00281                     {\cf19 return} Machine32.Buffer;\par
00282                 \}\par
00283                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00284             \}\par
00285         \}\par
00286 \par
00292         {\cf17 public} {\cf18 string} Buffer\par
00293         \{\par
00294             {\cf17 get}\par
00295             \{\par
00296                 Blit();\par
00297                 {\cf19 if} (StructType == StructModeType.Machinex64)\par
00298                 \{\par
00299                     {\cf19 return} Marshal.PtrToStringUni({\cf17 new} IntPtr(({\cf18 long})Machine64.Buffer));\par
00300                 \}\par
00301                 {\cf19 if} (StructType == StructModeType.Machinex86)\par
00302                 \{\par
00303                     {\cf19 return} Marshal.PtrToStringUni({\cf17 new} IntPtr(({\cf18 int})Machine32.Buffer));\par
00304                 \}\par
00305                 {\cf19 throw} ThrowNewInvalidOpMessage(GetType().Name);\par
00306             \}\par
00307         \}\par
00308 \par
00309 \par
00315         {\cf17 public} {\cf17 override} {\cf18 string} ToString()\par
00316         \{\par
00317             {\cf19 if} (BufferPtr == 0)\par
00318             \{\par
00319                 {\cf19 return} {\cf17 null};\par
00320             \}\par
00321             {\cf19 return} Buffer;\par
00322         \}\par
00323 \par
00327         {\cf17 protected} {\cf17 override} {\cf18 void} Apply()\par
00328         \{\par
00329             {\cf19 throw} {\cf17 new} NotImplementedException();\par
00330         \}\par
00331 \par
00332 \par
00336         UnicodeString64 Machine64;\par
00340         UnicodeString32 Machine32;\par
00341         \par
00342     \}\par
00343 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Win32Struct/WindowsUserProcessParameter.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Win32Struct/WindowsUserProcessParameter.cs}
{\xe \v Win32Struct/WindowsUserProcessParameter.cs}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Win32Struct.WindowsUserProcessParameter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Win32Struct}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WindowsUserProcessParameter.cs\par \pard\plain 
{\tc\tcl2 \v Win32Struct/WindowsUserProcessParameter.cs}
{\xe \v Win32Struct/WindowsUserProcessParameter.cs}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Runtime.InteropServices;\par
00005 {\cf17 using }System.Text;\par
00006 {\cf17 using }System.Threading.Tasks;\par
00007 \par
00008 {\cf17 namespace }InsightSheath.Win32Struct\par
00009 \{\par
00010     {\cf20 /*}\par
00011 {\cf20     struct RTL_USER32}\par
00012 {\cf20     \{}\par
00013 {\cf20         BYTE Reserved1[16];}\par
00014 {\cf20         UINT32 Reserved2[10];}\par
00015 {\cf20         UNICODE_STRING32 ImagePathName;}\par
00016 {\cf20         UNICODE_STRING32 CommandLine;}\par
00017 {\cf20     \};}\par
00018 {\cf20     struct RTL_USER64}\par
00019 {\cf20     \{}\par
00020 {\cf20         BYTE Reserved1[16];}\par
00021 {\cf20         UINT64 Reserved2[10];}\par
00022 {\cf20         UNICODE_STRING64 ImagePathName;}\par
00023 {\cf20         UNICODE_STRING64 CommandLine;}\par
00024 {\cf20     \};*/}\par
00025 \par
00026 \par
00027     {\cf17 public} {\cf17 class }WindowsUserProcessParameter \par
00028     \{\par
00029 \par
00030     \par
00031         UserProcessParameters32 Marshal32;\par
00032         UserProcessParameters64 Marshal64;\par
00033 \par
00034     \}\par
00035 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Wrappers/Detours.cs File Reference\par \pard\plain 
{\tc\tcl2 \v Wrappers/Detours.cs}
{\xe \v Wrappers/Detours.cs}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InsightSheath.Wrappers.Detours}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intended for wrapps }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b InsightSheath.Wrappers}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Detours.cs\par \pard\plain 
{\tc\tcl2 \v Wrappers/Detours.cs}
{\xe \v Wrappers/Detours.cs}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System;\par
00002 {\cf17 using }System.Collections.Generic;\par
00003 {\cf17 using }System.Linq;\par
00004 {\cf17 using }System.Text;\par
00005 {\cf17 using }System.Threading.Tasks;\par
00006 {\cf17 using }InsightSheath.NativeImports;\par
00007 {\cf17 namespace }InsightSheath.Wrappers\par
00008 \{\par
00009  \par
00013     {\cf17 public} {\cf17 static} {\cf17 class }Detours\par
00014     \{\par
00022         {\cf17 public} {\cf17 static} IntPtr DetourEnumerateModulesEx(IntPtr hProcess, IntPtr hModule)\par
00023         \{\par
00024             {\cf19 return} NativeMethods.DetourEnumerateModulesEx(hProcess, hModule);\par
00025         \}\par
00026     \}\par
00027 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
